{"ast":null,"code":"(function (Prism) {\n  /**\n   * Returns the placeholder for the given language id and index.\n   *\n   * @param {string} language\n   * @param {string|number} index\n   * @returns {string}\n   */\n  function getPlaceholder(language, index) {\n    return '___' + language.toUpperCase() + index + '___';\n  }\n\n  Object.defineProperties(Prism.languages['markup-templating'] = {}, {\n    buildPlaceholders: {\n      /**\n       * Tokenize all inline templating expressions matching `placeholderPattern`.\n       *\n       * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns\n       * `true` will be replaced.\n       *\n       * @param {object} env The environment of the `before-tokenize` hook.\n       * @param {string} language The language id.\n       * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.\n       * @param {(match: string) => boolean} [replaceFilter]\n       */\n      value: function (env, language, placeholderPattern, replaceFilter) {\n        if (env.language !== language) {\n          return;\n        }\n\n        var tokenStack = env.tokenStack = [];\n        env.code = env.code.replace(placeholderPattern, function (match) {\n          if (typeof replaceFilter === 'function' && !replaceFilter(match)) {\n            return match;\n          }\n\n          var i = tokenStack.length;\n          var placeholder; // Check for existing strings\n\n          while (env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1) {\n            ++i;\n          } // Create a sparse array\n\n\n          tokenStack[i] = match;\n          return placeholder;\n        }); // Switch the grammar to markup\n\n        env.grammar = Prism.languages.markup;\n      }\n    },\n    tokenizePlaceholders: {\n      /**\n       * Replace placeholders with proper tokens after tokenizing.\n       *\n       * @param {object} env The environment of the `after-tokenize` hook.\n       * @param {string} language The language id.\n       */\n      value: function (env, language) {\n        if (env.language !== language || !env.tokenStack) {\n          return;\n        } // Switch the grammar back\n\n\n        env.grammar = Prism.languages[language];\n        var j = 0;\n        var keys = Object.keys(env.tokenStack);\n\n        function walkTokens(tokens) {\n          for (var i = 0; i < tokens.length; i++) {\n            // all placeholders are replaced already\n            if (j >= keys.length) {\n              break;\n            }\n\n            var token = tokens[i];\n\n            if (typeof token === 'string' || token.content && typeof token.content === 'string') {\n              var k = keys[j];\n              var t = env.tokenStack[k];\n              var s = typeof token === 'string' ? token : token.content;\n              var placeholder = getPlaceholder(language, k);\n              var index = s.indexOf(placeholder);\n\n              if (index > -1) {\n                ++j;\n                var before = s.substring(0, index);\n                var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), 'language-' + language, t);\n                var after = s.substring(index + placeholder.length);\n                var replacement = [];\n\n                if (before) {\n                  replacement.push.apply(replacement, walkTokens([before]));\n                }\n\n                replacement.push(middle);\n\n                if (after) {\n                  replacement.push.apply(replacement, walkTokens([after]));\n                }\n\n                if (typeof token === 'string') {\n                  tokens.splice.apply(tokens, [i, 1].concat(replacement));\n                } else {\n                  token.content = replacement;\n                }\n              }\n            } else if (token.content\n            /* && typeof token.content !== 'string' */\n            ) {\n                walkTokens(token.content);\n              }\n          }\n\n          return tokens;\n        }\n\n        walkTokens(env.tokens);\n      }\n    }\n  });\n})(Prism);","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/github/react-snippy/node_modules/prismjs/components/prism-markup-templating.js"],"names":["Prism","getPlaceholder","language","index","toUpperCase","Object","defineProperties","languages","buildPlaceholders","value","env","placeholderPattern","replaceFilter","tokenStack","code","replace","match","i","length","placeholder","indexOf","grammar","markup","tokenizePlaceholders","j","keys","walkTokens","tokens","token","content","k","t","s","before","substring","middle","Token","tokenize","after","replacement","push","apply","splice","concat"],"mappings":"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","sourcesContent":["(function (Prism) {\n\n\t/**\n\t * Returns the placeholder for the given language id and index.\n\t *\n\t * @param {string} language\n\t * @param {string|number} index\n\t * @returns {string}\n\t */\n\tfunction getPlaceholder(language, index) {\n\t\treturn '___' + language.toUpperCase() + index + '___';\n\t}\n\n\tObject.defineProperties(Prism.languages['markup-templating'] = {}, {\n\t\tbuildPlaceholders: {\n\t\t\t/**\n\t\t\t * Tokenize all inline templating expressions matching `placeholderPattern`.\n\t\t\t *\n\t\t\t * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns\n\t\t\t * `true` will be replaced.\n\t\t\t *\n\t\t\t * @param {object} env The environment of the `before-tokenize` hook.\n\t\t\t * @param {string} language The language id.\n\t\t\t * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.\n\t\t\t * @param {(match: string) => boolean} [replaceFilter]\n\t\t\t */\n\t\t\tvalue: function (env, language, placeholderPattern, replaceFilter) {\n\t\t\t\tif (env.language !== language) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar tokenStack = env.tokenStack = [];\n\n\t\t\t\tenv.code = env.code.replace(placeholderPattern, function (match) {\n\t\t\t\t\tif (typeof replaceFilter === 'function' && !replaceFilter(match)) {\n\t\t\t\t\t\treturn match;\n\t\t\t\t\t}\n\t\t\t\t\tvar i = tokenStack.length;\n\t\t\t\t\tvar placeholder;\n\n\t\t\t\t\t// Check for existing strings\n\t\t\t\t\twhile (env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1) {\n\t\t\t\t\t\t++i;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create a sparse array\n\t\t\t\t\ttokenStack[i] = match;\n\n\t\t\t\t\treturn placeholder;\n\t\t\t\t});\n\n\t\t\t\t// Switch the grammar to markup\n\t\t\t\tenv.grammar = Prism.languages.markup;\n\t\t\t}\n\t\t},\n\t\ttokenizePlaceholders: {\n\t\t\t/**\n\t\t\t * Replace placeholders with proper tokens after tokenizing.\n\t\t\t *\n\t\t\t * @param {object} env The environment of the `after-tokenize` hook.\n\t\t\t * @param {string} language The language id.\n\t\t\t */\n\t\t\tvalue: function (env, language) {\n\t\t\t\tif (env.language !== language || !env.tokenStack) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Switch the grammar back\n\t\t\t\tenv.grammar = Prism.languages[language];\n\n\t\t\t\tvar j = 0;\n\t\t\t\tvar keys = Object.keys(env.tokenStack);\n\n\t\t\t\tfunction walkTokens(tokens) {\n\t\t\t\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\t\t\t\t// all placeholders are replaced already\n\t\t\t\t\t\tif (j >= keys.length) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar token = tokens[i];\n\t\t\t\t\t\tif (typeof token === 'string' || (token.content && typeof token.content === 'string')) {\n\t\t\t\t\t\t\tvar k = keys[j];\n\t\t\t\t\t\t\tvar t = env.tokenStack[k];\n\t\t\t\t\t\t\tvar s = typeof token === 'string' ? token : token.content;\n\t\t\t\t\t\t\tvar placeholder = getPlaceholder(language, k);\n\n\t\t\t\t\t\t\tvar index = s.indexOf(placeholder);\n\t\t\t\t\t\t\tif (index > -1) {\n\t\t\t\t\t\t\t\t++j;\n\n\t\t\t\t\t\t\t\tvar before = s.substring(0, index);\n\t\t\t\t\t\t\t\tvar middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), 'language-' + language, t);\n\t\t\t\t\t\t\t\tvar after = s.substring(index + placeholder.length);\n\n\t\t\t\t\t\t\t\tvar replacement = [];\n\t\t\t\t\t\t\t\tif (before) {\n\t\t\t\t\t\t\t\t\treplacement.push.apply(replacement, walkTokens([before]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treplacement.push(middle);\n\t\t\t\t\t\t\t\tif (after) {\n\t\t\t\t\t\t\t\t\treplacement.push.apply(replacement, walkTokens([after]));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (typeof token === 'string') {\n\t\t\t\t\t\t\t\t\ttokens.splice.apply(tokens, [i, 1].concat(replacement));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttoken.content = replacement;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (token.content /* && typeof token.content !== 'string' */) {\n\t\t\t\t\t\t\twalkTokens(token.content);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn tokens;\n\t\t\t\t}\n\n\t\t\t\twalkTokens(env.tokens);\n\t\t\t}\n\t\t}\n\t});\n\n}(Prism));\n"]},"metadata":{},"sourceType":"script"}