{"ast":null,"code":"\"use strict\";\n\n;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\n\nvar path_1 = tslib_1.__importDefault(require(\"./path\"));\n\nvar scope_1 = tslib_1.__importDefault(require(\"./scope\"));\n\nfunction nodePathPlugin(fork) {\n  var types = fork.use(types_1.default);\n  var n = types.namedTypes;\n  var b = types.builders;\n  var isNumber = types.builtInTypes.number;\n  var isArray = types.builtInTypes.array;\n  var Path = fork.use(path_1.default);\n  var Scope = fork.use(scope_1.default);\n\n  var NodePath = function NodePath(value, parentPath, name) {\n    if (!(this instanceof NodePath)) {\n      throw new Error(\"NodePath constructor cannot be invoked without 'new'\");\n    }\n\n    Path.call(this, value, parentPath, name);\n  };\n\n  var NPp = NodePath.prototype = Object.create(Path.prototype, {\n    constructor: {\n      value: NodePath,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperties(NPp, {\n    node: {\n      get: function () {\n        Object.defineProperty(this, \"node\", {\n          configurable: true,\n          value: this._computeNode()\n        });\n        return this.node;\n      }\n    },\n    parent: {\n      get: function () {\n        Object.defineProperty(this, \"parent\", {\n          configurable: true,\n          value: this._computeParent()\n        });\n        return this.parent;\n      }\n    },\n    scope: {\n      get: function () {\n        Object.defineProperty(this, \"scope\", {\n          configurable: true,\n          value: this._computeScope()\n        });\n        return this.scope;\n      }\n    }\n  });\n\n  NPp.replace = function () {\n    delete this.node;\n    delete this.parent;\n    delete this.scope;\n    return Path.prototype.replace.apply(this, arguments);\n  };\n\n  NPp.prune = function () {\n    var remainingNodePath = this.parent;\n    this.replace();\n    return cleanUpNodesAfterPrune(remainingNodePath);\n  }; // The value of the first ancestor Path whose value is a Node.\n\n\n  NPp._computeNode = function () {\n    var value = this.value;\n\n    if (n.Node.check(value)) {\n      return value;\n    }\n\n    var pp = this.parentPath;\n    return pp && pp.node || null;\n  }; // The first ancestor Path whose value is a Node distinct from this.node.\n\n\n  NPp._computeParent = function () {\n    var value = this.value;\n    var pp = this.parentPath;\n\n    if (!n.Node.check(value)) {\n      while (pp && !n.Node.check(pp.value)) {\n        pp = pp.parentPath;\n      }\n\n      if (pp) {\n        pp = pp.parentPath;\n      }\n    }\n\n    while (pp && !n.Node.check(pp.value)) {\n      pp = pp.parentPath;\n    }\n\n    return pp || null;\n  }; // The closest enclosing scope that governs this node.\n\n\n  NPp._computeScope = function () {\n    var value = this.value;\n    var pp = this.parentPath;\n    var scope = pp && pp.scope;\n\n    if (n.Node.check(value) && Scope.isEstablishedBy(value)) {\n      scope = new Scope(this, scope);\n    }\n\n    return scope || null;\n  };\n\n  NPp.getValueProperty = function (name) {\n    return types.getFieldValue(this.value, name);\n  };\n  /**\n   * Determine whether this.node needs to be wrapped in parentheses in order\n   * for a parser to reproduce the same local AST structure.\n   *\n   * For instance, in the expression `(1 + 2) * 3`, the BinaryExpression\n   * whose operator is \"+\" needs parentheses, because `1 + 2 * 3` would\n   * parse differently.\n   *\n   * If assumeExpressionContext === true, we don't worry about edge cases\n   * like an anonymous FunctionExpression appearing lexically first in its\n   * enclosing statement and thus needing parentheses to avoid being parsed\n   * as a FunctionDeclaration with a missing name.\n   */\n\n\n  NPp.needsParens = function (assumeExpressionContext) {\n    var pp = this.parentPath;\n\n    if (!pp) {\n      return false;\n    }\n\n    var node = this.value; // Only expressions need parentheses.\n\n    if (!n.Expression.check(node)) {\n      return false;\n    } // Identifiers never need parentheses.\n\n\n    if (node.type === \"Identifier\") {\n      return false;\n    }\n\n    while (!n.Node.check(pp.value)) {\n      pp = pp.parentPath;\n\n      if (!pp) {\n        return false;\n      }\n    }\n\n    var parent = pp.value;\n\n    switch (node.type) {\n      case \"UnaryExpression\":\n      case \"SpreadElement\":\n      case \"SpreadProperty\":\n        return parent.type === \"MemberExpression\" && this.name === \"object\" && parent.object === node;\n\n      case \"BinaryExpression\":\n      case \"LogicalExpression\":\n        switch (parent.type) {\n          case \"CallExpression\":\n            return this.name === \"callee\" && parent.callee === node;\n\n          case \"UnaryExpression\":\n          case \"SpreadElement\":\n          case \"SpreadProperty\":\n            return true;\n\n          case \"MemberExpression\":\n            return this.name === \"object\" && parent.object === node;\n\n          case \"BinaryExpression\":\n          case \"LogicalExpression\":\n            {\n              var n_1 = node;\n              var po = parent.operator;\n              var pp_1 = PRECEDENCE[po];\n              var no = n_1.operator;\n              var np = PRECEDENCE[no];\n\n              if (pp_1 > np) {\n                return true;\n              }\n\n              if (pp_1 === np && this.name === \"right\") {\n                if (parent.right !== n_1) {\n                  throw new Error(\"Nodes must be equal\");\n                }\n\n                return true;\n              }\n            }\n\n          default:\n            return false;\n        }\n\n      case \"SequenceExpression\":\n        switch (parent.type) {\n          case \"ForStatement\":\n            // Although parentheses wouldn't hurt around sequence\n            // expressions in the head of for loops, traditional style\n            // dictates that e.g. i++, j++ should not be wrapped with\n            // parentheses.\n            return false;\n\n          case \"ExpressionStatement\":\n            return this.name !== \"expression\";\n\n          default:\n            // Otherwise err on the side of overparenthesization, adding\n            // explicit exceptions above if this proves overzealous.\n            return true;\n        }\n\n      case \"YieldExpression\":\n        switch (parent.type) {\n          case \"BinaryExpression\":\n          case \"LogicalExpression\":\n          case \"UnaryExpression\":\n          case \"SpreadElement\":\n          case \"SpreadProperty\":\n          case \"CallExpression\":\n          case \"MemberExpression\":\n          case \"NewExpression\":\n          case \"ConditionalExpression\":\n          case \"YieldExpression\":\n            return true;\n\n          default:\n            return false;\n        }\n\n      case \"Literal\":\n        return parent.type === \"MemberExpression\" && isNumber.check(node.value) && this.name === \"object\" && parent.object === node;\n\n      case \"AssignmentExpression\":\n      case \"ConditionalExpression\":\n        switch (parent.type) {\n          case \"UnaryExpression\":\n          case \"SpreadElement\":\n          case \"SpreadProperty\":\n          case \"BinaryExpression\":\n          case \"LogicalExpression\":\n            return true;\n\n          case \"CallExpression\":\n            return this.name === \"callee\" && parent.callee === node;\n\n          case \"ConditionalExpression\":\n            return this.name === \"test\" && parent.test === node;\n\n          case \"MemberExpression\":\n            return this.name === \"object\" && parent.object === node;\n\n          default:\n            return false;\n        }\n\n      default:\n        if (parent.type === \"NewExpression\" && this.name === \"callee\" && parent.callee === node) {\n          return containsCallExpression(node);\n        }\n\n    }\n\n    if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement()) return true;\n    return false;\n  };\n\n  function isBinary(node) {\n    return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);\n  } // @ts-ignore 'isUnaryLike' is declared but its value is never read. [6133]\n\n\n  function isUnaryLike(node) {\n    return n.UnaryExpression.check(node) // I considered making SpreadElement and SpreadProperty subtypes\n    // of UnaryExpression, but they're not really Expression nodes.\n    || n.SpreadElement && n.SpreadElement.check(node) || n.SpreadProperty && n.SpreadProperty.check(node);\n  }\n\n  var PRECEDENCE = {};\n  [[\"||\"], [\"&&\"], [\"|\"], [\"^\"], [\"&\"], [\"==\", \"===\", \"!=\", \"!==\"], [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"], [\">>\", \"<<\", \">>>\"], [\"+\", \"-\"], [\"*\", \"/\", \"%\"]].forEach(function (tier, i) {\n    tier.forEach(function (op) {\n      PRECEDENCE[op] = i;\n    });\n  });\n\n  function containsCallExpression(node) {\n    if (n.CallExpression.check(node)) {\n      return true;\n    }\n\n    if (isArray.check(node)) {\n      return node.some(containsCallExpression);\n    }\n\n    if (n.Node.check(node)) {\n      return types.someField(node, function (_name, child) {\n        return containsCallExpression(child);\n      });\n    }\n\n    return false;\n  }\n\n  NPp.canBeFirstInStatement = function () {\n    var node = this.node;\n    return !n.FunctionExpression.check(node) && !n.ObjectExpression.check(node);\n  };\n\n  NPp.firstInStatement = function () {\n    return firstInStatement(this);\n  };\n\n  function firstInStatement(path) {\n    for (var node, parent; path.parent; path = path.parent) {\n      node = path.node;\n      parent = path.parent.node;\n\n      if (n.BlockStatement.check(parent) && path.parent.name === \"body\" && path.name === 0) {\n        if (parent.body[0] !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n\n        return true;\n      }\n\n      if (n.ExpressionStatement.check(parent) && path.name === \"expression\") {\n        if (parent.expression !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n\n        return true;\n      }\n\n      if (n.SequenceExpression.check(parent) && path.parent.name === \"expressions\" && path.name === 0) {\n        if (parent.expressions[0] !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n\n        continue;\n      }\n\n      if (n.CallExpression.check(parent) && path.name === \"callee\") {\n        if (parent.callee !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n\n        continue;\n      }\n\n      if (n.MemberExpression.check(parent) && path.name === \"object\") {\n        if (parent.object !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n\n        continue;\n      }\n\n      if (n.ConditionalExpression.check(parent) && path.name === \"test\") {\n        if (parent.test !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n\n        continue;\n      }\n\n      if (isBinary(parent) && path.name === \"left\") {\n        if (parent.left !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n\n        continue;\n      }\n\n      if (n.UnaryExpression.check(parent) && !parent.prefix && path.name === \"argument\") {\n        if (parent.argument !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n\n        continue;\n      }\n\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Pruning certain nodes will result in empty or incomplete nodes, here we clean those nodes up.\n   */\n\n\n  function cleanUpNodesAfterPrune(remainingNodePath) {\n    if (n.VariableDeclaration.check(remainingNodePath.node)) {\n      var declarations = remainingNodePath.get('declarations').value;\n\n      if (!declarations || declarations.length === 0) {\n        return remainingNodePath.prune();\n      }\n    } else if (n.ExpressionStatement.check(remainingNodePath.node)) {\n      if (!remainingNodePath.get('expression').value) {\n        return remainingNodePath.prune();\n      }\n    } else if (n.IfStatement.check(remainingNodePath.node)) {\n      cleanUpIfStatementAfterPrune(remainingNodePath);\n    }\n\n    return remainingNodePath;\n  }\n\n  function cleanUpIfStatementAfterPrune(ifStatement) {\n    var testExpression = ifStatement.get('test').value;\n    var alternate = ifStatement.get('alternate').value;\n    var consequent = ifStatement.get('consequent').value;\n\n    if (!consequent && !alternate) {\n      var testExpressionStatement = b.expressionStatement(testExpression);\n      ifStatement.replace(testExpressionStatement);\n    } else if (!consequent && alternate) {\n      var negatedTestExpression = b.unaryExpression('!', testExpression, true);\n\n      if (n.UnaryExpression.check(testExpression) && testExpression.operator === '!') {\n        negatedTestExpression = testExpression.argument;\n      }\n\n      ifStatement.get(\"test\").replace(negatedTestExpression);\n      ifStatement.get(\"consequent\").replace(alternate);\n      ifStatement.get(\"alternate\").replace();\n    }\n  }\n\n  return NodePath;\n}\n\nexports.default = nodePathPlugin;\nmodule.exports = exports[\"default\"];","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/jbook/node_modules/jscodeshift/node_modules/ast-types/lib/node-path.js"],"names":["Object","defineProperty","exports","value","tslib_1","require","types_1","__importDefault","path_1","scope_1","nodePathPlugin","fork","types","use","default","n","namedTypes","b","builders","isNumber","builtInTypes","number","isArray","array","Path","Scope","NodePath","parentPath","name","Error","call","NPp","prototype","create","constructor","enumerable","writable","configurable","defineProperties","node","get","_computeNode","parent","_computeParent","scope","_computeScope","replace","apply","arguments","prune","remainingNodePath","cleanUpNodesAfterPrune","Node","check","pp","isEstablishedBy","getValueProperty","getFieldValue","needsParens","assumeExpressionContext","Expression","type","object","callee","n_1","po","operator","pp_1","PRECEDENCE","no","np","right","test","containsCallExpression","canBeFirstInStatement","firstInStatement","isBinary","BinaryExpression","LogicalExpression","isUnaryLike","UnaryExpression","SpreadElement","SpreadProperty","forEach","tier","i","op","CallExpression","some","someField","_name","child","FunctionExpression","ObjectExpression","path","BlockStatement","body","ExpressionStatement","expression","SequenceExpression","expressions","MemberExpression","ConditionalExpression","left","prefix","argument","VariableDeclaration","declarations","length","IfStatement","cleanUpIfStatementAfterPrune","ifStatement","testExpression","alternate","consequent","testExpressionStatement","expressionStatement","negatedTestExpression","unaryExpression","module"],"mappings":"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","sourcesContent":["\"use strict\";;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\nvar path_1 = tslib_1.__importDefault(require(\"./path\"));\nvar scope_1 = tslib_1.__importDefault(require(\"./scope\"));\nfunction nodePathPlugin(fork) {\n    var types = fork.use(types_1.default);\n    var n = types.namedTypes;\n    var b = types.builders;\n    var isNumber = types.builtInTypes.number;\n    var isArray = types.builtInTypes.array;\n    var Path = fork.use(path_1.default);\n    var Scope = fork.use(scope_1.default);\n    var NodePath = function NodePath(value, parentPath, name) {\n        if (!(this instanceof NodePath)) {\n            throw new Error(\"NodePath constructor cannot be invoked without 'new'\");\n        }\n        Path.call(this, value, parentPath, name);\n    };\n    var NPp = NodePath.prototype = Object.create(Path.prototype, {\n        constructor: {\n            value: NodePath,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperties(NPp, {\n        node: {\n            get: function () {\n                Object.defineProperty(this, \"node\", {\n                    configurable: true,\n                    value: this._computeNode()\n                });\n                return this.node;\n            }\n        },\n        parent: {\n            get: function () {\n                Object.defineProperty(this, \"parent\", {\n                    configurable: true,\n                    value: this._computeParent()\n                });\n                return this.parent;\n            }\n        },\n        scope: {\n            get: function () {\n                Object.defineProperty(this, \"scope\", {\n                    configurable: true,\n                    value: this._computeScope()\n                });\n                return this.scope;\n            }\n        }\n    });\n    NPp.replace = function () {\n        delete this.node;\n        delete this.parent;\n        delete this.scope;\n        return Path.prototype.replace.apply(this, arguments);\n    };\n    NPp.prune = function () {\n        var remainingNodePath = this.parent;\n        this.replace();\n        return cleanUpNodesAfterPrune(remainingNodePath);\n    };\n    // The value of the first ancestor Path whose value is a Node.\n    NPp._computeNode = function () {\n        var value = this.value;\n        if (n.Node.check(value)) {\n            return value;\n        }\n        var pp = this.parentPath;\n        return pp && pp.node || null;\n    };\n    // The first ancestor Path whose value is a Node distinct from this.node.\n    NPp._computeParent = function () {\n        var value = this.value;\n        var pp = this.parentPath;\n        if (!n.Node.check(value)) {\n            while (pp && !n.Node.check(pp.value)) {\n                pp = pp.parentPath;\n            }\n            if (pp) {\n                pp = pp.parentPath;\n            }\n        }\n        while (pp && !n.Node.check(pp.value)) {\n            pp = pp.parentPath;\n        }\n        return pp || null;\n    };\n    // The closest enclosing scope that governs this node.\n    NPp._computeScope = function () {\n        var value = this.value;\n        var pp = this.parentPath;\n        var scope = pp && pp.scope;\n        if (n.Node.check(value) &&\n            Scope.isEstablishedBy(value)) {\n            scope = new Scope(this, scope);\n        }\n        return scope || null;\n    };\n    NPp.getValueProperty = function (name) {\n        return types.getFieldValue(this.value, name);\n    };\n    /**\n     * Determine whether this.node needs to be wrapped in parentheses in order\n     * for a parser to reproduce the same local AST structure.\n     *\n     * For instance, in the expression `(1 + 2) * 3`, the BinaryExpression\n     * whose operator is \"+\" needs parentheses, because `1 + 2 * 3` would\n     * parse differently.\n     *\n     * If assumeExpressionContext === true, we don't worry about edge cases\n     * like an anonymous FunctionExpression appearing lexically first in its\n     * enclosing statement and thus needing parentheses to avoid being parsed\n     * as a FunctionDeclaration with a missing name.\n     */\n    NPp.needsParens = function (assumeExpressionContext) {\n        var pp = this.parentPath;\n        if (!pp) {\n            return false;\n        }\n        var node = this.value;\n        // Only expressions need parentheses.\n        if (!n.Expression.check(node)) {\n            return false;\n        }\n        // Identifiers never need parentheses.\n        if (node.type === \"Identifier\") {\n            return false;\n        }\n        while (!n.Node.check(pp.value)) {\n            pp = pp.parentPath;\n            if (!pp) {\n                return false;\n            }\n        }\n        var parent = pp.value;\n        switch (node.type) {\n            case \"UnaryExpression\":\n            case \"SpreadElement\":\n            case \"SpreadProperty\":\n                return parent.type === \"MemberExpression\"\n                    && this.name === \"object\"\n                    && parent.object === node;\n            case \"BinaryExpression\":\n            case \"LogicalExpression\":\n                switch (parent.type) {\n                    case \"CallExpression\":\n                        return this.name === \"callee\"\n                            && parent.callee === node;\n                    case \"UnaryExpression\":\n                    case \"SpreadElement\":\n                    case \"SpreadProperty\":\n                        return true;\n                    case \"MemberExpression\":\n                        return this.name === \"object\"\n                            && parent.object === node;\n                    case \"BinaryExpression\":\n                    case \"LogicalExpression\": {\n                        var n_1 = node;\n                        var po = parent.operator;\n                        var pp_1 = PRECEDENCE[po];\n                        var no = n_1.operator;\n                        var np = PRECEDENCE[no];\n                        if (pp_1 > np) {\n                            return true;\n                        }\n                        if (pp_1 === np && this.name === \"right\") {\n                            if (parent.right !== n_1) {\n                                throw new Error(\"Nodes must be equal\");\n                            }\n                            return true;\n                        }\n                    }\n                    default:\n                        return false;\n                }\n            case \"SequenceExpression\":\n                switch (parent.type) {\n                    case \"ForStatement\":\n                        // Although parentheses wouldn't hurt around sequence\n                        // expressions in the head of for loops, traditional style\n                        // dictates that e.g. i++, j++ should not be wrapped with\n                        // parentheses.\n                        return false;\n                    case \"ExpressionStatement\":\n                        return this.name !== \"expression\";\n                    default:\n                        // Otherwise err on the side of overparenthesization, adding\n                        // explicit exceptions above if this proves overzealous.\n                        return true;\n                }\n            case \"YieldExpression\":\n                switch (parent.type) {\n                    case \"BinaryExpression\":\n                    case \"LogicalExpression\":\n                    case \"UnaryExpression\":\n                    case \"SpreadElement\":\n                    case \"SpreadProperty\":\n                    case \"CallExpression\":\n                    case \"MemberExpression\":\n                    case \"NewExpression\":\n                    case \"ConditionalExpression\":\n                    case \"YieldExpression\":\n                        return true;\n                    default:\n                        return false;\n                }\n            case \"Literal\":\n                return parent.type === \"MemberExpression\"\n                    && isNumber.check(node.value)\n                    && this.name === \"object\"\n                    && parent.object === node;\n            case \"AssignmentExpression\":\n            case \"ConditionalExpression\":\n                switch (parent.type) {\n                    case \"UnaryExpression\":\n                    case \"SpreadElement\":\n                    case \"SpreadProperty\":\n                    case \"BinaryExpression\":\n                    case \"LogicalExpression\":\n                        return true;\n                    case \"CallExpression\":\n                        return this.name === \"callee\"\n                            && parent.callee === node;\n                    case \"ConditionalExpression\":\n                        return this.name === \"test\"\n                            && parent.test === node;\n                    case \"MemberExpression\":\n                        return this.name === \"object\"\n                            && parent.object === node;\n                    default:\n                        return false;\n                }\n            default:\n                if (parent.type === \"NewExpression\" &&\n                    this.name === \"callee\" &&\n                    parent.callee === node) {\n                    return containsCallExpression(node);\n                }\n        }\n        if (assumeExpressionContext !== true &&\n            !this.canBeFirstInStatement() &&\n            this.firstInStatement())\n            return true;\n        return false;\n    };\n    function isBinary(node) {\n        return n.BinaryExpression.check(node)\n            || n.LogicalExpression.check(node);\n    }\n    // @ts-ignore 'isUnaryLike' is declared but its value is never read. [6133]\n    function isUnaryLike(node) {\n        return n.UnaryExpression.check(node)\n            // I considered making SpreadElement and SpreadProperty subtypes\n            // of UnaryExpression, but they're not really Expression nodes.\n            || (n.SpreadElement && n.SpreadElement.check(node))\n            || (n.SpreadProperty && n.SpreadProperty.check(node));\n    }\n    var PRECEDENCE = {};\n    [[\"||\"],\n        [\"&&\"],\n        [\"|\"],\n        [\"^\"],\n        [\"&\"],\n        [\"==\", \"===\", \"!=\", \"!==\"],\n        [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\n        [\">>\", \"<<\", \">>>\"],\n        [\"+\", \"-\"],\n        [\"*\", \"/\", \"%\"]\n    ].forEach(function (tier, i) {\n        tier.forEach(function (op) {\n            PRECEDENCE[op] = i;\n        });\n    });\n    function containsCallExpression(node) {\n        if (n.CallExpression.check(node)) {\n            return true;\n        }\n        if (isArray.check(node)) {\n            return node.some(containsCallExpression);\n        }\n        if (n.Node.check(node)) {\n            return types.someField(node, function (_name, child) {\n                return containsCallExpression(child);\n            });\n        }\n        return false;\n    }\n    NPp.canBeFirstInStatement = function () {\n        var node = this.node;\n        return !n.FunctionExpression.check(node)\n            && !n.ObjectExpression.check(node);\n    };\n    NPp.firstInStatement = function () {\n        return firstInStatement(this);\n    };\n    function firstInStatement(path) {\n        for (var node, parent; path.parent; path = path.parent) {\n            node = path.node;\n            parent = path.parent.node;\n            if (n.BlockStatement.check(parent) &&\n                path.parent.name === \"body\" &&\n                path.name === 0) {\n                if (parent.body[0] !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                return true;\n            }\n            if (n.ExpressionStatement.check(parent) &&\n                path.name === \"expression\") {\n                if (parent.expression !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                return true;\n            }\n            if (n.SequenceExpression.check(parent) &&\n                path.parent.name === \"expressions\" &&\n                path.name === 0) {\n                if (parent.expressions[0] !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n            if (n.CallExpression.check(parent) &&\n                path.name === \"callee\") {\n                if (parent.callee !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n            if (n.MemberExpression.check(parent) &&\n                path.name === \"object\") {\n                if (parent.object !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n            if (n.ConditionalExpression.check(parent) &&\n                path.name === \"test\") {\n                if (parent.test !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n            if (isBinary(parent) &&\n                path.name === \"left\") {\n                if (parent.left !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n            if (n.UnaryExpression.check(parent) &&\n                !parent.prefix &&\n                path.name === \"argument\") {\n                if (parent.argument !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Pruning certain nodes will result in empty or incomplete nodes, here we clean those nodes up.\n     */\n    function cleanUpNodesAfterPrune(remainingNodePath) {\n        if (n.VariableDeclaration.check(remainingNodePath.node)) {\n            var declarations = remainingNodePath.get('declarations').value;\n            if (!declarations || declarations.length === 0) {\n                return remainingNodePath.prune();\n            }\n        }\n        else if (n.ExpressionStatement.check(remainingNodePath.node)) {\n            if (!remainingNodePath.get('expression').value) {\n                return remainingNodePath.prune();\n            }\n        }\n        else if (n.IfStatement.check(remainingNodePath.node)) {\n            cleanUpIfStatementAfterPrune(remainingNodePath);\n        }\n        return remainingNodePath;\n    }\n    function cleanUpIfStatementAfterPrune(ifStatement) {\n        var testExpression = ifStatement.get('test').value;\n        var alternate = ifStatement.get('alternate').value;\n        var consequent = ifStatement.get('consequent').value;\n        if (!consequent && !alternate) {\n            var testExpressionStatement = b.expressionStatement(testExpression);\n            ifStatement.replace(testExpressionStatement);\n        }\n        else if (!consequent && alternate) {\n            var negatedTestExpression = b.unaryExpression('!', testExpression, true);\n            if (n.UnaryExpression.check(testExpression) && testExpression.operator === '!') {\n                negatedTestExpression = testExpression.argument;\n            }\n            ifStatement.get(\"test\").replace(negatedTestExpression);\n            ifStatement.get(\"consequent\").replace(alternate);\n            ifStatement.get(\"alternate\").replace();\n        }\n    }\n    return NodePath;\n}\nexports.default = nodePathPlugin;\nmodule.exports = exports[\"default\"];\n"]},"metadata":{},"sourceType":"script"}