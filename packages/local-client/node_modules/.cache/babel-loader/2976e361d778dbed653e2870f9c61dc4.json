{"ast":null,"code":"(function (Prism) {\n  Prism.languages.puppet = {\n    'heredoc': [// Matches the content of a quoted heredoc string (subject to interpolation)\n    {\n      pattern: /(@\\(\"([^\"\\r\\n\\/):]+)\"(?:\\/[nrts$uL]*)?\\).*(?:\\r?\\n|\\r))(?:.*(?:\\r?\\n|\\r(?!\\n)))*?[ \\t]*(?:\\|[ \\t]*)?(?:-[ \\t]*)?\\2/,\n      lookbehind: true,\n      alias: 'string',\n      inside: {\n        // Matches the end tag\n        'punctuation': /(?=\\S).*\\S(?= *$)/ // See interpolation below\n\n      }\n    }, // Matches the content of an unquoted heredoc string (no interpolation)\n    {\n      pattern: /(@\\(([^\"\\r\\n\\/):]+)(?:\\/[nrts$uL]*)?\\).*(?:\\r?\\n|\\r))(?:.*(?:\\r?\\n|\\r(?!\\n)))*?[ \\t]*(?:\\|[ \\t]*)?(?:-[ \\t]*)?\\2/,\n      lookbehind: true,\n      greedy: true,\n      alias: 'string',\n      inside: {\n        // Matches the end tag\n        'punctuation': /(?=\\S).*\\S(?= *$)/\n      }\n    }, // Matches the start tag of heredoc strings\n    {\n      pattern: /@\\(\"?(?:[^\"\\r\\n\\/):]+)\"?(?:\\/[nrts$uL]*)?\\)/,\n      alias: 'string',\n      inside: {\n        'punctuation': {\n          pattern: /(\\().+?(?=\\))/,\n          lookbehind: true\n        }\n      }\n    }],\n    'multiline-comment': {\n      pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?\\*\\//,\n      lookbehind: true,\n      greedy: true,\n      alias: 'comment'\n    },\n    'regex': {\n      // Must be prefixed with the keyword \"node\" or a non-word char\n      pattern: /((?:\\bnode\\s+|[~=\\(\\[\\{,]\\s*|[=+]>\\s*|^\\s*))\\/(?:[^\\/\\\\]|\\\\[\\s\\S])+\\/(?:[imx]+\\b|\\B)/,\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        // Extended regexes must have the x flag. They can contain single-line comments.\n        'extended-regex': {\n          pattern: /^\\/(?:[^\\/\\\\]|\\\\[\\s\\S])+\\/[im]*x[im]*$/,\n          inside: {\n            'comment': /#.*/\n          }\n        }\n      }\n    },\n    'comment': {\n      pattern: /(^|[^\\\\])#.*/,\n      lookbehind: true,\n      greedy: true\n    },\n    'string': {\n      // Allow for one nested level of double quotes inside interpolation\n      pattern: /([\"'])(?:\\$\\{(?:[^'\"}]|([\"'])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2)+\\}|\\$(?!\\{)|(?!\\1)[^\\\\$]|\\\\[\\s\\S])*\\1/,\n      greedy: true,\n      inside: {\n        'double-quoted': {\n          pattern: /^\"[\\s\\S]*\"$/,\n          inside: {// See interpolation below\n          }\n        }\n      }\n    },\n    'variable': {\n      pattern: /\\$(?:::)?\\w+(?:::\\w+)*/,\n      inside: {\n        'punctuation': /::/\n      }\n    },\n    'attr-name': /(?:\\b\\w+|\\*)(?=\\s*=>)/,\n    'function': [{\n      pattern: /(\\.)(?!\\d)\\w+/,\n      lookbehind: true\n    }, /\\b(?:contain|debug|err|fail|include|info|notice|realize|require|tag|warning)\\b|\\b(?!\\d)\\w+(?=\\()/],\n    'number': /\\b(?:0x[a-f\\d]+|\\d+(?:\\.\\d+)?(?:e-?\\d+)?)\\b/i,\n    'boolean': /\\b(?:true|false)\\b/,\n    // Includes words reserved for future use\n    'keyword': /\\b(?:application|attr|case|class|consumes|default|define|else|elsif|function|if|import|inherits|node|private|produces|type|undef|unless)\\b/,\n    'datatype': {\n      pattern: /\\b(?:Any|Array|Boolean|Callable|Catalogentry|Class|Collection|Data|Default|Enum|Float|Hash|Integer|NotUndef|Numeric|Optional|Pattern|Regexp|Resource|Runtime|Scalar|String|Struct|Tuple|Type|Undef|Variant)\\b/,\n      alias: 'symbol'\n    },\n    'operator': /=[=~>]?|![=~]?|<(?:<\\|?|[=~|-])?|>[>=]?|->?|~>|\\|>?>?|[*\\/%+?]|\\b(?:and|in|or)\\b/,\n    'punctuation': /[\\[\\]{}().,;]|:+/\n  };\n  var interpolation = [{\n    // Allow for one nested level of braces inside interpolation\n    pattern: /(^|[^\\\\])\\$\\{(?:[^'\"{}]|\\{[^}]*\\}|([\"'])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2)+\\}/,\n    lookbehind: true,\n    inside: {\n      'short-variable': {\n        // Negative look-ahead prevent wrong highlighting of functions\n        pattern: /(^\\$\\{)(?!\\w+\\()(?:::)?\\w+(?:::\\w+)*/,\n        lookbehind: true,\n        alias: 'variable',\n        inside: {\n          'punctuation': /::/\n        }\n      },\n      'delimiter': {\n        pattern: /^\\$/,\n        alias: 'variable'\n      },\n      rest: Prism.languages.puppet\n    }\n  }, {\n    pattern: /(^|[^\\\\])\\$(?:::)?\\w+(?:::\\w+)*/,\n    lookbehind: true,\n    alias: 'variable',\n    inside: {\n      'punctuation': /::/\n    }\n  }];\n  Prism.languages.puppet['heredoc'][0].inside.interpolation = interpolation;\n  Prism.languages.puppet['string'].inside['double-quoted'].inside.interpolation = interpolation;\n})(Prism);","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/jbook/node_modules/prismjs/components/prism-puppet.js"],"names":["Prism","languages","puppet","pattern","lookbehind","alias","inside","greedy","interpolation","rest"],"mappings":"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","sourcesContent":["(function (Prism) {\n\tPrism.languages.puppet = {\n\t\t'heredoc': [\n\t\t\t// Matches the content of a quoted heredoc string (subject to interpolation)\n\t\t\t{\n\t\t\t\tpattern: /(@\\(\"([^\"\\r\\n\\/):]+)\"(?:\\/[nrts$uL]*)?\\).*(?:\\r?\\n|\\r))(?:.*(?:\\r?\\n|\\r(?!\\n)))*?[ \\t]*(?:\\|[ \\t]*)?(?:-[ \\t]*)?\\2/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'string',\n\t\t\t\tinside: {\n\t\t\t\t\t// Matches the end tag\n\t\t\t\t\t'punctuation': /(?=\\S).*\\S(?= *$)/\n\t\t\t\t\t// See interpolation below\n\t\t\t\t}\n\t\t\t},\n\t\t\t// Matches the content of an unquoted heredoc string (no interpolation)\n\t\t\t{\n\t\t\t\tpattern: /(@\\(([^\"\\r\\n\\/):]+)(?:\\/[nrts$uL]*)?\\).*(?:\\r?\\n|\\r))(?:.*(?:\\r?\\n|\\r(?!\\n)))*?[ \\t]*(?:\\|[ \\t]*)?(?:-[ \\t]*)?\\2/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\talias: 'string',\n\t\t\t\tinside: {\n\t\t\t\t\t// Matches the end tag\n\t\t\t\t\t'punctuation': /(?=\\S).*\\S(?= *$)/\n\t\t\t\t}\n\t\t\t},\n\t\t\t// Matches the start tag of heredoc strings\n\t\t\t{\n\t\t\t\tpattern: /@\\(\"?(?:[^\"\\r\\n\\/):]+)\"?(?:\\/[nrts$uL]*)?\\)/,\n\t\t\t\talias: 'string',\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': {\n\t\t\t\t\t\tpattern: /(\\().+?(?=\\))/,\n\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'multiline-comment': {\n\t\t\tpattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?\\*\\//,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\talias: 'comment'\n\t\t},\n\t\t'regex': {\n\t\t\t// Must be prefixed with the keyword \"node\" or a non-word char\n\t\t\tpattern: /((?:\\bnode\\s+|[~=\\(\\[\\{,]\\s*|[=+]>\\s*|^\\s*))\\/(?:[^\\/\\\\]|\\\\[\\s\\S])+\\/(?:[imx]+\\b|\\B)/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t// Extended regexes must have the x flag. They can contain single-line comments.\n\t\t\t\t'extended-regex': {\n\t\t\t\t\tpattern: /^\\/(?:[^\\/\\\\]|\\\\[\\s\\S])+\\/[im]*x[im]*$/,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'comment': /#.*/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'comment': {\n\t\t\tpattern: /(^|[^\\\\])#.*/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t},\n\t\t'string': {\n\t\t\t// Allow for one nested level of double quotes inside interpolation\n\t\t\tpattern: /([\"'])(?:\\$\\{(?:[^'\"}]|([\"'])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2)+\\}|\\$(?!\\{)|(?!\\1)[^\\\\$]|\\\\[\\s\\S])*\\1/,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'double-quoted': {\n\t\t\t\t\tpattern: /^\"[\\s\\S]*\"$/,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t// See interpolation below\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'variable': {\n\t\t\tpattern: /\\$(?:::)?\\w+(?:::\\w+)*/,\n\t\t\tinside: {\n\t\t\t\t'punctuation': /::/\n\t\t\t}\n\t\t},\n\t\t'attr-name': /(?:\\b\\w+|\\*)(?=\\s*=>)/,\n\t\t'function': [\n\t\t\t{\n\t\t\t\tpattern: /(\\.)(?!\\d)\\w+/,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t/\\b(?:contain|debug|err|fail|include|info|notice|realize|require|tag|warning)\\b|\\b(?!\\d)\\w+(?=\\()/\n\t\t],\n\t\t'number': /\\b(?:0x[a-f\\d]+|\\d+(?:\\.\\d+)?(?:e-?\\d+)?)\\b/i,\n\t\t'boolean': /\\b(?:true|false)\\b/,\n\t\t// Includes words reserved for future use\n\t\t'keyword': /\\b(?:application|attr|case|class|consumes|default|define|else|elsif|function|if|import|inherits|node|private|produces|type|undef|unless)\\b/,\n\t\t'datatype': {\n\t\t\tpattern: /\\b(?:Any|Array|Boolean|Callable|Catalogentry|Class|Collection|Data|Default|Enum|Float|Hash|Integer|NotUndef|Numeric|Optional|Pattern|Regexp|Resource|Runtime|Scalar|String|Struct|Tuple|Type|Undef|Variant)\\b/,\n\t\t\talias: 'symbol'\n\t\t},\n\t\t'operator': /=[=~>]?|![=~]?|<(?:<\\|?|[=~|-])?|>[>=]?|->?|~>|\\|>?>?|[*\\/%+?]|\\b(?:and|in|or)\\b/,\n\t\t'punctuation': /[\\[\\]{}().,;]|:+/\n\t};\n\n\tvar interpolation = [\n\t\t{\n\t\t\t// Allow for one nested level of braces inside interpolation\n\t\t\tpattern: /(^|[^\\\\])\\$\\{(?:[^'\"{}]|\\{[^}]*\\}|([\"'])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2)+\\}/,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'short-variable': {\n\t\t\t\t\t// Negative look-ahead prevent wrong highlighting of functions\n\t\t\t\t\tpattern: /(^\\$\\{)(?!\\w+\\()(?:::)?\\w+(?:::\\w+)*/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'variable',\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'punctuation': /::/\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'delimiter': {\n\t\t\t\t\tpattern: /^\\$/,\n\t\t\t\t\talias: 'variable'\n\t\t\t\t},\n\t\t\t\trest: Prism.languages.puppet\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^\\\\])\\$(?:::)?\\w+(?:::\\w+)*/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'variable',\n\t\t\tinside: {\n\t\t\t\t'punctuation': /::/\n\t\t\t}\n\t\t}\n\t];\n\tPrism.languages.puppet['heredoc'][0].inside.interpolation = interpolation;\n\tPrism.languages.puppet['string'].inside['double-quoted'].inside.interpolation = interpolation;\n}(Prism));\n"]},"metadata":{},"sourceType":"script"}