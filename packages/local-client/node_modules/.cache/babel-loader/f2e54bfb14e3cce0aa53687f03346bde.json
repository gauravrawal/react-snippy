{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getReprinter = exports.Patcher = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\n\nvar linesModule = tslib_1.__importStar(require(\"./lines\"));\n\nvar types = tslib_1.__importStar(require(\"ast-types\"));\n\nvar Printable = types.namedTypes.Printable;\nvar Expression = types.namedTypes.Expression;\nvar ReturnStatement = types.namedTypes.ReturnStatement;\nvar SourceLocation = types.namedTypes.SourceLocation;\n\nvar util_1 = require(\"./util\");\n\nvar fast_path_1 = tslib_1.__importDefault(require(\"./fast-path\"));\n\nvar isObject = types.builtInTypes.object;\nvar isArray = types.builtInTypes.array;\nvar isString = types.builtInTypes.string;\nvar riskyAdjoiningCharExp = /[0-9a-z_$]/i;\n\nvar Patcher = function Patcher(lines) {\n  assert_1.default.ok(this instanceof Patcher);\n  assert_1.default.ok(lines instanceof linesModule.Lines);\n  var self = this,\n      replacements = [];\n\n  self.replace = function (loc, lines) {\n    if (isString.check(lines)) lines = linesModule.fromString(lines);\n    replacements.push({\n      lines: lines,\n      start: loc.start,\n      end: loc.end\n    });\n  };\n\n  self.get = function (loc) {\n    // If no location is provided, return the complete Lines object.\n    loc = loc || {\n      start: {\n        line: 1,\n        column: 0\n      },\n      end: {\n        line: lines.length,\n        column: lines.getLineLength(lines.length)\n      }\n    };\n    var sliceFrom = loc.start,\n        toConcat = [];\n\n    function pushSlice(from, to) {\n      assert_1.default.ok(util_1.comparePos(from, to) <= 0);\n      toConcat.push(lines.slice(from, to));\n    }\n\n    replacements.sort(function (a, b) {\n      return util_1.comparePos(a.start, b.start);\n    }).forEach(function (rep) {\n      if (util_1.comparePos(sliceFrom, rep.start) > 0) {// Ignore nested replacement ranges.\n      } else {\n        pushSlice(sliceFrom, rep.start);\n        toConcat.push(rep.lines);\n        sliceFrom = rep.end;\n      }\n    });\n    pushSlice(sliceFrom, loc.end);\n    return linesModule.concat(toConcat);\n  };\n};\n\nexports.Patcher = Patcher;\nvar Pp = Patcher.prototype;\n\nPp.tryToReprintComments = function (newNode, oldNode, print) {\n  var patcher = this;\n\n  if (!newNode.comments && !oldNode.comments) {\n    // We were (vacuously) able to reprint all the comments!\n    return true;\n  }\n\n  var newPath = fast_path_1.default.from(newNode);\n  var oldPath = fast_path_1.default.from(oldNode);\n  newPath.stack.push(\"comments\", getSurroundingComments(newNode));\n  oldPath.stack.push(\"comments\", getSurroundingComments(oldNode));\n  var reprints = [];\n  var ableToReprintComments = findArrayReprints(newPath, oldPath, reprints); // No need to pop anything from newPath.stack or oldPath.stack, since\n  // newPath and oldPath are fresh local variables.\n\n  if (ableToReprintComments && reprints.length > 0) {\n    reprints.forEach(function (reprint) {\n      var oldComment = reprint.oldPath.getValue();\n      assert_1.default.ok(oldComment.leading || oldComment.trailing);\n      patcher.replace(oldComment.loc, // Comments can't have .comments, so it doesn't matter whether we\n      // print with comments or without.\n      print(reprint.newPath).indentTail(oldComment.loc.indent));\n    });\n  }\n\n  return ableToReprintComments;\n}; // Get all comments that are either leading or trailing, ignoring any\n// comments that occur inside node.loc. Returns an empty array for nodes\n// with no leading or trailing comments.\n\n\nfunction getSurroundingComments(node) {\n  var result = [];\n\n  if (node.comments && node.comments.length > 0) {\n    node.comments.forEach(function (comment) {\n      if (comment.leading || comment.trailing) {\n        result.push(comment);\n      }\n    });\n  }\n\n  return result;\n}\n\nPp.deleteComments = function (node) {\n  if (!node.comments) {\n    return;\n  }\n\n  var patcher = this;\n  node.comments.forEach(function (comment) {\n    if (comment.leading) {\n      // Delete leading comments along with any trailing whitespace they\n      // might have.\n      patcher.replace({\n        start: comment.loc.start,\n        end: node.loc.lines.skipSpaces(comment.loc.end, false, false)\n      }, \"\");\n    } else if (comment.trailing) {\n      // Delete trailing comments along with any leading whitespace they\n      // might have.\n      patcher.replace({\n        start: node.loc.lines.skipSpaces(comment.loc.start, true, false),\n        end: comment.loc.end\n      }, \"\");\n    }\n  });\n};\n\nfunction getReprinter(path) {\n  assert_1.default.ok(path instanceof fast_path_1.default); // Make sure that this path refers specifically to a Node, rather than\n  // some non-Node subproperty of a Node.\n\n  var node = path.getValue();\n  if (!Printable.check(node)) return;\n  var orig = node.original;\n  var origLoc = orig && orig.loc;\n  var lines = origLoc && origLoc.lines;\n  var reprints = [];\n  if (!lines || !findReprints(path, reprints)) return;\n  return function (print) {\n    var patcher = new Patcher(lines);\n    reprints.forEach(function (reprint) {\n      var newNode = reprint.newPath.getValue();\n      var oldNode = reprint.oldPath.getValue();\n      SourceLocation.assert(oldNode.loc, true);\n      var needToPrintNewPathWithComments = !patcher.tryToReprintComments(newNode, oldNode, print);\n\n      if (needToPrintNewPathWithComments) {\n        // Since we were not able to preserve all leading/trailing\n        // comments, we delete oldNode's comments, print newPath with\n        // comments, and then patch the resulting lines where oldNode used\n        // to be.\n        patcher.deleteComments(oldNode);\n      }\n\n      var newLines = print(reprint.newPath, {\n        includeComments: needToPrintNewPathWithComments,\n        // If the oldNode we're replacing already had parentheses, we may\n        // not need to print the new node with any extra parentheses,\n        // because the existing parentheses will suffice. However, if the\n        // newNode has a different type than the oldNode, let the printer\n        // decide if reprint.newPath needs parentheses, as usual.\n        avoidRootParens: oldNode.type === newNode.type && reprint.oldPath.hasParens()\n      }).indentTail(oldNode.loc.indent);\n      var nls = needsLeadingSpace(lines, oldNode.loc, newLines);\n      var nts = needsTrailingSpace(lines, oldNode.loc, newLines); // If we try to replace the argument of a ReturnStatement like\n      // return\"asdf\" with e.g. a literal null expression, we run the risk\n      // of ending up with returnnull, so we need to add an extra leading\n      // space in situations where that might happen. Likewise for\n      // \"asdf\"in obj. See #170.\n\n      if (nls || nts) {\n        var newParts = [];\n        nls && newParts.push(\" \");\n        newParts.push(newLines);\n        nts && newParts.push(\" \");\n        newLines = linesModule.concat(newParts);\n      }\n\n      patcher.replace(oldNode.loc, newLines);\n    }); // Recall that origLoc is the .loc of an ancestor node that is\n    // guaranteed to contain all the reprinted nodes and comments.\n\n    var patchedLines = patcher.get(origLoc).indentTail(-orig.loc.indent);\n\n    if (path.needsParens()) {\n      return linesModule.concat([\"(\", patchedLines, \")\"]);\n    }\n\n    return patchedLines;\n  };\n}\n\nexports.getReprinter = getReprinter; // If the last character before oldLoc and the first character of newLines\n// are both identifier characters, they must be separated by a space,\n// otherwise they will most likely get fused together into a single token.\n\nfunction needsLeadingSpace(oldLines, oldLoc, newLines) {\n  var posBeforeOldLoc = util_1.copyPos(oldLoc.start); // The character just before the location occupied by oldNode.\n\n  var charBeforeOldLoc = oldLines.prevPos(posBeforeOldLoc) && oldLines.charAt(posBeforeOldLoc); // First character of the reprinted node.\n\n  var newFirstChar = newLines.charAt(newLines.firstPos());\n  return charBeforeOldLoc && riskyAdjoiningCharExp.test(charBeforeOldLoc) && newFirstChar && riskyAdjoiningCharExp.test(newFirstChar);\n} // If the last character of newLines and the first character after oldLoc\n// are both identifier characters, they must be separated by a space,\n// otherwise they will most likely get fused together into a single token.\n\n\nfunction needsTrailingSpace(oldLines, oldLoc, newLines) {\n  // The character just after the location occupied by oldNode.\n  var charAfterOldLoc = oldLines.charAt(oldLoc.end);\n  var newLastPos = newLines.lastPos(); // Last character of the reprinted node.\n\n  var newLastChar = newLines.prevPos(newLastPos) && newLines.charAt(newLastPos);\n  return newLastChar && riskyAdjoiningCharExp.test(newLastChar) && charAfterOldLoc && riskyAdjoiningCharExp.test(charAfterOldLoc);\n}\n\nfunction findReprints(newPath, reprints) {\n  var newNode = newPath.getValue();\n  Printable.assert(newNode);\n  var oldNode = newNode.original;\n  Printable.assert(oldNode);\n  assert_1.default.deepEqual(reprints, []);\n\n  if (newNode.type !== oldNode.type) {\n    return false;\n  }\n\n  var oldPath = new fast_path_1.default(oldNode);\n  var canReprint = findChildReprints(newPath, oldPath, reprints);\n\n  if (!canReprint) {\n    // Make absolutely sure the calling code does not attempt to reprint\n    // any nodes.\n    reprints.length = 0;\n  }\n\n  return canReprint;\n}\n\nfunction findAnyReprints(newPath, oldPath, reprints) {\n  var newNode = newPath.getValue();\n  var oldNode = oldPath.getValue();\n  if (newNode === oldNode) return true;\n  if (isArray.check(newNode)) return findArrayReprints(newPath, oldPath, reprints);\n  if (isObject.check(newNode)) return findObjectReprints(newPath, oldPath, reprints);\n  return false;\n}\n\nfunction findArrayReprints(newPath, oldPath, reprints) {\n  var newNode = newPath.getValue();\n  var oldNode = oldPath.getValue();\n\n  if (newNode === oldNode || newPath.valueIsDuplicate() || oldPath.valueIsDuplicate()) {\n    return true;\n  }\n\n  isArray.assert(newNode);\n  var len = newNode.length;\n  if (!(isArray.check(oldNode) && oldNode.length === len)) return false;\n\n  for (var i = 0; i < len; ++i) {\n    newPath.stack.push(i, newNode[i]);\n    oldPath.stack.push(i, oldNode[i]);\n    var canReprint = findAnyReprints(newPath, oldPath, reprints);\n    newPath.stack.length -= 2;\n    oldPath.stack.length -= 2;\n\n    if (!canReprint) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction findObjectReprints(newPath, oldPath, reprints) {\n  var newNode = newPath.getValue();\n  isObject.assert(newNode);\n\n  if (newNode.original === null) {\n    // If newNode.original node was set to null, reprint the node.\n    return false;\n  }\n\n  var oldNode = oldPath.getValue();\n  if (!isObject.check(oldNode)) return false;\n\n  if (newNode === oldNode || newPath.valueIsDuplicate() || oldPath.valueIsDuplicate()) {\n    return true;\n  }\n\n  if (Printable.check(newNode)) {\n    if (!Printable.check(oldNode)) {\n      return false;\n    }\n\n    var newParentNode = newPath.getParentNode();\n    var oldParentNode = oldPath.getParentNode();\n\n    if (oldParentNode !== null && oldParentNode.type === \"FunctionTypeAnnotation\" && newParentNode !== null && newParentNode.type === \"FunctionTypeAnnotation\") {\n      var oldNeedsParens = oldParentNode.params.length !== 1 || !!oldParentNode.params[0].name;\n      var newNeedParens = newParentNode.params.length !== 1 || !!newParentNode.params[0].name;\n\n      if (!oldNeedsParens && newNeedParens) {\n        return false;\n      }\n    } // Here we need to decide whether the reprinted code for newNode is\n    // appropriate for patching into the location of oldNode.\n\n\n    if (newNode.type === oldNode.type) {\n      var childReprints = [];\n\n      if (findChildReprints(newPath, oldPath, childReprints)) {\n        reprints.push.apply(reprints, childReprints);\n      } else if (oldNode.loc) {\n        // If we have no .loc information for oldNode, then we won't be\n        // able to reprint it.\n        reprints.push({\n          oldPath: oldPath.copy(),\n          newPath: newPath.copy()\n        });\n      } else {\n        return false;\n      }\n\n      return true;\n    }\n\n    if (Expression.check(newNode) && Expression.check(oldNode) && // If we have no .loc information for oldNode, then we won't be\n    // able to reprint it.\n    oldNode.loc) {\n      // If both nodes are subtypes of Expression, then we should be able\n      // to fill the location occupied by the old node with code printed\n      // for the new node with no ill consequences.\n      reprints.push({\n        oldPath: oldPath.copy(),\n        newPath: newPath.copy()\n      });\n      return true;\n    } // The nodes have different types, and at least one of the types is\n    // not a subtype of the Expression type, so we cannot safely assume\n    // the nodes are syntactically interchangeable.\n\n\n    return false;\n  }\n\n  return findChildReprints(newPath, oldPath, reprints);\n}\n\nfunction findChildReprints(newPath, oldPath, reprints) {\n  var newNode = newPath.getValue();\n  var oldNode = oldPath.getValue();\n  isObject.assert(newNode);\n  isObject.assert(oldNode);\n\n  if (newNode.original === null) {\n    // If newNode.original node was set to null, reprint the node.\n    return false;\n  } // If this node needs parentheses and will not be wrapped with\n  // parentheses when reprinted, then return false to skip reprinting and\n  // let it be printed generically.\n\n\n  if (newPath.needsParens() && !oldPath.hasParens()) {\n    return false;\n  }\n\n  var keys = util_1.getUnionOfKeys(oldNode, newNode);\n\n  if (oldNode.type === \"File\" || newNode.type === \"File\") {\n    // Don't bother traversing file.tokens, an often very large array\n    // returned by Babylon, and useless for our purposes.\n    delete keys.tokens;\n  } // Don't bother traversing .loc objects looking for reprintable nodes.\n\n\n  delete keys.loc;\n  var originalReprintCount = reprints.length;\n\n  for (var k in keys) {\n    if (k.charAt(0) === \"_\") {\n      // Ignore \"private\" AST properties added by e.g. Babel plugins and\n      // parsers like Babylon.\n      continue;\n    }\n\n    newPath.stack.push(k, types.getFieldValue(newNode, k));\n    oldPath.stack.push(k, types.getFieldValue(oldNode, k));\n    var canReprint = findAnyReprints(newPath, oldPath, reprints);\n    newPath.stack.length -= 2;\n    oldPath.stack.length -= 2;\n\n    if (!canReprint) {\n      return false;\n    }\n  } // Return statements might end up running into ASI issues due to\n  // comments inserted deep within the tree, so reprint them if anything\n  // changed within them.\n\n\n  if (ReturnStatement.check(newPath.getNode()) && reprints.length > originalReprintCount) {\n    return false;\n  }\n\n  return true;\n}","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/jbook/node_modules/jscodeshift/node_modules/recast/lib/patcher.js"],"names":["Object","defineProperty","exports","value","getReprinter","Patcher","tslib_1","require","assert_1","__importDefault","linesModule","__importStar","types","Printable","namedTypes","Expression","ReturnStatement","SourceLocation","util_1","fast_path_1","isObject","builtInTypes","object","isArray","array","isString","string","riskyAdjoiningCharExp","lines","default","ok","Lines","self","replacements","replace","loc","check","fromString","push","start","end","get","line","column","length","getLineLength","sliceFrom","toConcat","pushSlice","from","to","comparePos","slice","sort","a","b","forEach","rep","concat","Pp","prototype","tryToReprintComments","newNode","oldNode","print","patcher","comments","newPath","oldPath","stack","getSurroundingComments","reprints","ableToReprintComments","findArrayReprints","reprint","oldComment","getValue","leading","trailing","indentTail","indent","node","result","comment","deleteComments","skipSpaces","path","orig","original","origLoc","findReprints","assert","needToPrintNewPathWithComments","newLines","includeComments","avoidRootParens","type","hasParens","nls","needsLeadingSpace","nts","needsTrailingSpace","newParts","patchedLines","needsParens","oldLines","oldLoc","posBeforeOldLoc","copyPos","charBeforeOldLoc","prevPos","charAt","newFirstChar","firstPos","test","charAfterOldLoc","newLastPos","lastPos","newLastChar","deepEqual","canReprint","findChildReprints","findAnyReprints","findObjectReprints","valueIsDuplicate","len","i","newParentNode","getParentNode","oldParentNode","oldNeedsParens","params","name","newNeedParens","childReprints","apply","copy","keys","getUnionOfKeys","tokens","originalReprintCount","k","getFieldValue","getNode"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,YAAR,GAAuBF,OAAO,CAACG,OAAR,GAAkB,KAAK,CAA9C;;AACA,IAAIC,OAAO,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,IAAIC,QAAQ,GAAGF,OAAO,CAACG,eAAR,CAAwBF,OAAO,CAAC,QAAD,CAA/B,CAAf;;AACA,IAAIG,WAAW,GAAGJ,OAAO,CAACK,YAAR,CAAqBJ,OAAO,CAAC,SAAD,CAA5B,CAAlB;;AACA,IAAIK,KAAK,GAAGN,OAAO,CAACK,YAAR,CAAqBJ,OAAO,CAAC,WAAD,CAA5B,CAAZ;;AACA,IAAIM,SAAS,GAAGD,KAAK,CAACE,UAAN,CAAiBD,SAAjC;AACA,IAAIE,UAAU,GAAGH,KAAK,CAACE,UAAN,CAAiBC,UAAlC;AACA,IAAIC,eAAe,GAAGJ,KAAK,CAACE,UAAN,CAAiBE,eAAvC;AACA,IAAIC,cAAc,GAAGL,KAAK,CAACE,UAAN,CAAiBG,cAAtC;;AACA,IAAIC,MAAM,GAAGX,OAAO,CAAC,QAAD,CAApB;;AACA,IAAIY,WAAW,GAAGb,OAAO,CAACG,eAAR,CAAwBF,OAAO,CAAC,aAAD,CAA/B,CAAlB;;AACA,IAAIa,QAAQ,GAAGR,KAAK,CAACS,YAAN,CAAmBC,MAAlC;AACA,IAAIC,OAAO,GAAGX,KAAK,CAACS,YAAN,CAAmBG,KAAjC;AACA,IAAIC,QAAQ,GAAGb,KAAK,CAACS,YAAN,CAAmBK,MAAlC;AACA,IAAIC,qBAAqB,GAAG,aAA5B;;AACA,IAAItB,OAAO,GAAG,SAASA,OAAT,CAAiBuB,KAAjB,EAAwB;AAClCpB,EAAAA,QAAQ,CAACqB,OAAT,CAAiBC,EAAjB,CAAoB,gBAAgBzB,OAApC;AACAG,EAAAA,QAAQ,CAACqB,OAAT,CAAiBC,EAAjB,CAAoBF,KAAK,YAAYlB,WAAW,CAACqB,KAAjD;AACA,MAAIC,IAAI,GAAG,IAAX;AAAA,MAAiBC,YAAY,GAAG,EAAhC;;AACAD,EAAAA,IAAI,CAACE,OAAL,GAAe,UAAUC,GAAV,EAAeP,KAAf,EAAsB;AACjC,QAAIH,QAAQ,CAACW,KAAT,CAAeR,KAAf,CAAJ,EACIA,KAAK,GAAGlB,WAAW,CAAC2B,UAAZ,CAAuBT,KAAvB,CAAR;AACJK,IAAAA,YAAY,CAACK,IAAb,CAAkB;AACdV,MAAAA,KAAK,EAAEA,KADO;AAEdW,MAAAA,KAAK,EAAEJ,GAAG,CAACI,KAFG;AAGdC,MAAAA,GAAG,EAAEL,GAAG,CAACK;AAHK,KAAlB;AAKH,GARD;;AASAR,EAAAA,IAAI,CAACS,GAAL,GAAW,UAAUN,GAAV,EAAe;AACtB;AACAA,IAAAA,GAAG,GAAGA,GAAG,IAAI;AACTI,MAAAA,KAAK,EAAE;AAAEG,QAAAA,IAAI,EAAE,CAAR;AAAWC,QAAAA,MAAM,EAAE;AAAnB,OADE;AAETH,MAAAA,GAAG,EAAE;AAAEE,QAAAA,IAAI,EAAEd,KAAK,CAACgB,MAAd;AAAsBD,QAAAA,MAAM,EAAEf,KAAK,CAACiB,aAAN,CAAoBjB,KAAK,CAACgB,MAA1B;AAA9B;AAFI,KAAb;AAIA,QAAIE,SAAS,GAAGX,GAAG,CAACI,KAApB;AAAA,QAA2BQ,QAAQ,GAAG,EAAtC;;AACA,aAASC,SAAT,CAAmBC,IAAnB,EAAyBC,EAAzB,EAA6B;AACzB1C,MAAAA,QAAQ,CAACqB,OAAT,CAAiBC,EAAjB,CAAoBZ,MAAM,CAACiC,UAAP,CAAkBF,IAAlB,EAAwBC,EAAxB,KAA+B,CAAnD;AACAH,MAAAA,QAAQ,CAACT,IAAT,CAAcV,KAAK,CAACwB,KAAN,CAAYH,IAAZ,EAAkBC,EAAlB,CAAd;AACH;;AACDjB,IAAAA,YAAY,CACPoB,IADL,CACU,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAAE,aAAOrC,MAAM,CAACiC,UAAP,CAAkBG,CAAC,CAACf,KAApB,EAA2BgB,CAAC,CAAChB,KAA7B,CAAP;AAA6C,KADzE,EAEKiB,OAFL,CAEa,UAAUC,GAAV,EAAe;AACxB,UAAIvC,MAAM,CAACiC,UAAP,CAAkBL,SAAlB,EAA6BW,GAAG,CAAClB,KAAjC,IAA0C,CAA9C,EAAiD,CAC7C;AACH,OAFD,MAGK;AACDS,QAAAA,SAAS,CAACF,SAAD,EAAYW,GAAG,CAAClB,KAAhB,CAAT;AACAQ,QAAAA,QAAQ,CAACT,IAAT,CAAcmB,GAAG,CAAC7B,KAAlB;AACAkB,QAAAA,SAAS,GAAGW,GAAG,CAACjB,GAAhB;AACH;AACJ,KAXD;AAYAQ,IAAAA,SAAS,CAACF,SAAD,EAAYX,GAAG,CAACK,GAAhB,CAAT;AACA,WAAO9B,WAAW,CAACgD,MAAZ,CAAmBX,QAAnB,CAAP;AACH,GAzBD;AA0BH,CAvCD;;AAwCA7C,OAAO,CAACG,OAAR,GAAkBA,OAAlB;AACA,IAAIsD,EAAE,GAAGtD,OAAO,CAACuD,SAAjB;;AACAD,EAAE,CAACE,oBAAH,GAA0B,UAAUC,OAAV,EAAmBC,OAAnB,EAA4BC,KAA5B,EAAmC;AACzD,MAAIC,OAAO,GAAG,IAAd;;AACA,MAAI,CAACH,OAAO,CAACI,QAAT,IAAqB,CAACH,OAAO,CAACG,QAAlC,EAA4C;AACxC;AACA,WAAO,IAAP;AACH;;AACD,MAAIC,OAAO,GAAGhD,WAAW,CAACU,OAAZ,CAAoBoB,IAApB,CAAyBa,OAAzB,CAAd;AACA,MAAIM,OAAO,GAAGjD,WAAW,CAACU,OAAZ,CAAoBoB,IAApB,CAAyBc,OAAzB,CAAd;AACAI,EAAAA,OAAO,CAACE,KAAR,CAAc/B,IAAd,CAAmB,UAAnB,EAA+BgC,sBAAsB,CAACR,OAAD,CAArD;AACAM,EAAAA,OAAO,CAACC,KAAR,CAAc/B,IAAd,CAAmB,UAAnB,EAA+BgC,sBAAsB,CAACP,OAAD,CAArD;AACA,MAAIQ,QAAQ,GAAG,EAAf;AACA,MAAIC,qBAAqB,GAAGC,iBAAiB,CAACN,OAAD,EAAUC,OAAV,EAAmBG,QAAnB,CAA7C,CAXyD,CAYzD;AACA;;AACA,MAAIC,qBAAqB,IAAID,QAAQ,CAAC3B,MAAT,GAAkB,CAA/C,EAAkD;AAC9C2B,IAAAA,QAAQ,CAACf,OAAT,CAAiB,UAAUkB,OAAV,EAAmB;AAChC,UAAIC,UAAU,GAAGD,OAAO,CAACN,OAAR,CAAgBQ,QAAhB,EAAjB;AACApE,MAAAA,QAAQ,CAACqB,OAAT,CAAiBC,EAAjB,CAAoB6C,UAAU,CAACE,OAAX,IAAsBF,UAAU,CAACG,QAArD;AACAb,MAAAA,OAAO,CAAC/B,OAAR,CAAgByC,UAAU,CAACxC,GAA3B,EACA;AACA;AACA6B,MAAAA,KAAK,CAACU,OAAO,CAACP,OAAT,CAAL,CAAuBY,UAAvB,CAAkCJ,UAAU,CAACxC,GAAX,CAAe6C,MAAjD,CAHA;AAIH,KAPD;AAQH;;AACD,SAAOR,qBAAP;AACH,CAzBD,C,CA0BA;AACA;AACA;;;AACA,SAASF,sBAAT,CAAgCW,IAAhC,EAAsC;AAClC,MAAIC,MAAM,GAAG,EAAb;;AACA,MAAID,IAAI,CAACf,QAAL,IAAiBe,IAAI,CAACf,QAAL,CAActB,MAAd,GAAuB,CAA5C,EAA+C;AAC3CqC,IAAAA,IAAI,CAACf,QAAL,CAAcV,OAAd,CAAsB,UAAU2B,OAAV,EAAmB;AACrC,UAAIA,OAAO,CAACN,OAAR,IAAmBM,OAAO,CAACL,QAA/B,EAAyC;AACrCI,QAAAA,MAAM,CAAC5C,IAAP,CAAY6C,OAAZ;AACH;AACJ,KAJD;AAKH;;AACD,SAAOD,MAAP;AACH;;AACDvB,EAAE,CAACyB,cAAH,GAAoB,UAAUH,IAAV,EAAgB;AAChC,MAAI,CAACA,IAAI,CAACf,QAAV,EAAoB;AAChB;AACH;;AACD,MAAID,OAAO,GAAG,IAAd;AACAgB,EAAAA,IAAI,CAACf,QAAL,CAAcV,OAAd,CAAsB,UAAU2B,OAAV,EAAmB;AACrC,QAAIA,OAAO,CAACN,OAAZ,EAAqB;AACjB;AACA;AACAZ,MAAAA,OAAO,CAAC/B,OAAR,CAAgB;AACZK,QAAAA,KAAK,EAAE4C,OAAO,CAAChD,GAAR,CAAYI,KADP;AAEZC,QAAAA,GAAG,EAAEyC,IAAI,CAAC9C,GAAL,CAASP,KAAT,CAAeyD,UAAf,CAA0BF,OAAO,CAAChD,GAAR,CAAYK,GAAtC,EAA2C,KAA3C,EAAkD,KAAlD;AAFO,OAAhB,EAGG,EAHH;AAIH,KAPD,MAQK,IAAI2C,OAAO,CAACL,QAAZ,EAAsB;AACvB;AACA;AACAb,MAAAA,OAAO,CAAC/B,OAAR,CAAgB;AACZK,QAAAA,KAAK,EAAE0C,IAAI,CAAC9C,GAAL,CAASP,KAAT,CAAeyD,UAAf,CAA0BF,OAAO,CAAChD,GAAR,CAAYI,KAAtC,EAA6C,IAA7C,EAAmD,KAAnD,CADK;AAEZC,QAAAA,GAAG,EAAE2C,OAAO,CAAChD,GAAR,CAAYK;AAFL,OAAhB,EAGG,EAHH;AAIH;AACJ,GAjBD;AAkBH,CAvBD;;AAwBA,SAASpC,YAAT,CAAsBkF,IAAtB,EAA4B;AACxB9E,EAAAA,QAAQ,CAACqB,OAAT,CAAiBC,EAAjB,CAAoBwD,IAAI,YAAYnE,WAAW,CAACU,OAAhD,EADwB,CAExB;AACA;;AACA,MAAIoD,IAAI,GAAGK,IAAI,CAACV,QAAL,EAAX;AACA,MAAI,CAAC/D,SAAS,CAACuB,KAAV,CAAgB6C,IAAhB,CAAL,EACI;AACJ,MAAIM,IAAI,GAAGN,IAAI,CAACO,QAAhB;AACA,MAAIC,OAAO,GAAGF,IAAI,IAAIA,IAAI,CAACpD,GAA3B;AACA,MAAIP,KAAK,GAAG6D,OAAO,IAAIA,OAAO,CAAC7D,KAA/B;AACA,MAAI2C,QAAQ,GAAG,EAAf;AACA,MAAI,CAAC3C,KAAD,IAAU,CAAC8D,YAAY,CAACJ,IAAD,EAAOf,QAAP,CAA3B,EACI;AACJ,SAAO,UAAUP,KAAV,EAAiB;AACpB,QAAIC,OAAO,GAAG,IAAI5D,OAAJ,CAAYuB,KAAZ,CAAd;AACA2C,IAAAA,QAAQ,CAACf,OAAT,CAAiB,UAAUkB,OAAV,EAAmB;AAChC,UAAIZ,OAAO,GAAGY,OAAO,CAACP,OAAR,CAAgBS,QAAhB,EAAd;AACA,UAAIb,OAAO,GAAGW,OAAO,CAACN,OAAR,CAAgBQ,QAAhB,EAAd;AACA3D,MAAAA,cAAc,CAAC0E,MAAf,CAAsB5B,OAAO,CAAC5B,GAA9B,EAAmC,IAAnC;AACA,UAAIyD,8BAA8B,GAAG,CAAC3B,OAAO,CAACJ,oBAAR,CAA6BC,OAA7B,EAAsCC,OAAtC,EAA+CC,KAA/C,CAAtC;;AACA,UAAI4B,8BAAJ,EAAoC;AAChC;AACA;AACA;AACA;AACA3B,QAAAA,OAAO,CAACmB,cAAR,CAAuBrB,OAAvB;AACH;;AACD,UAAI8B,QAAQ,GAAG7B,KAAK,CAACU,OAAO,CAACP,OAAT,EAAkB;AAClC2B,QAAAA,eAAe,EAAEF,8BADiB;AAElC;AACA;AACA;AACA;AACA;AACAG,QAAAA,eAAe,EAAEhC,OAAO,CAACiC,IAAR,KAAiBlC,OAAO,CAACkC,IAAzB,IAAiCtB,OAAO,CAACN,OAAR,CAAgB6B,SAAhB;AAPhB,OAAlB,CAAL,CAQZlB,UARY,CAQDhB,OAAO,CAAC5B,GAAR,CAAY6C,MARX,CAAf;AASA,UAAIkB,GAAG,GAAGC,iBAAiB,CAACvE,KAAD,EAAQmC,OAAO,CAAC5B,GAAhB,EAAqB0D,QAArB,CAA3B;AACA,UAAIO,GAAG,GAAGC,kBAAkB,CAACzE,KAAD,EAAQmC,OAAO,CAAC5B,GAAhB,EAAqB0D,QAArB,CAA5B,CAtBgC,CAuBhC;AACA;AACA;AACA;AACA;;AACA,UAAIK,GAAG,IAAIE,GAAX,EAAgB;AACZ,YAAIE,QAAQ,GAAG,EAAf;AACAJ,QAAAA,GAAG,IAAII,QAAQ,CAAChE,IAAT,CAAc,GAAd,CAAP;AACAgE,QAAAA,QAAQ,CAAChE,IAAT,CAAcuD,QAAd;AACAO,QAAAA,GAAG,IAAIE,QAAQ,CAAChE,IAAT,CAAc,GAAd,CAAP;AACAuD,QAAAA,QAAQ,GAAGnF,WAAW,CAACgD,MAAZ,CAAmB4C,QAAnB,CAAX;AACH;;AACDrC,MAAAA,OAAO,CAAC/B,OAAR,CAAgB6B,OAAO,CAAC5B,GAAxB,EAA6B0D,QAA7B;AACH,KApCD,EAFoB,CAuCpB;AACA;;AACA,QAAIU,YAAY,GAAGtC,OAAO,CAACxB,GAAR,CAAYgD,OAAZ,EAAqBV,UAArB,CAAgC,CAACQ,IAAI,CAACpD,GAAL,CAAS6C,MAA1C,CAAnB;;AACA,QAAIM,IAAI,CAACkB,WAAL,EAAJ,EAAwB;AACpB,aAAO9F,WAAW,CAACgD,MAAZ,CAAmB,CAAC,GAAD,EAAM6C,YAAN,EAAoB,GAApB,CAAnB,CAAP;AACH;;AACD,WAAOA,YAAP;AACH,GA9CD;AA+CH;;AACDrG,OAAO,CAACE,YAAR,GAAuBA,YAAvB,C,CACA;AACA;AACA;;AACA,SAAS+F,iBAAT,CAA2BM,QAA3B,EAAqCC,MAArC,EAA6Cb,QAA7C,EAAuD;AACnD,MAAIc,eAAe,GAAGzF,MAAM,CAAC0F,OAAP,CAAeF,MAAM,CAACnE,KAAtB,CAAtB,CADmD,CAEnD;;AACA,MAAIsE,gBAAgB,GAAGJ,QAAQ,CAACK,OAAT,CAAiBH,eAAjB,KAAqCF,QAAQ,CAACM,MAAT,CAAgBJ,eAAhB,CAA5D,CAHmD,CAInD;;AACA,MAAIK,YAAY,GAAGnB,QAAQ,CAACkB,MAAT,CAAgBlB,QAAQ,CAACoB,QAAT,EAAhB,CAAnB;AACA,SAAQJ,gBAAgB,IACpBlF,qBAAqB,CAACuF,IAAtB,CAA2BL,gBAA3B,CADI,IAEJG,YAFI,IAGJrF,qBAAqB,CAACuF,IAAtB,CAA2BF,YAA3B,CAHJ;AAIH,C,CACD;AACA;AACA;;;AACA,SAASX,kBAAT,CAA4BI,QAA5B,EAAsCC,MAAtC,EAA8Cb,QAA9C,EAAwD;AACpD;AACA,MAAIsB,eAAe,GAAGV,QAAQ,CAACM,MAAT,CAAgBL,MAAM,CAAClE,GAAvB,CAAtB;AACA,MAAI4E,UAAU,GAAGvB,QAAQ,CAACwB,OAAT,EAAjB,CAHoD,CAIpD;;AACA,MAAIC,WAAW,GAAGzB,QAAQ,CAACiB,OAAT,CAAiBM,UAAjB,KAAgCvB,QAAQ,CAACkB,MAAT,CAAgBK,UAAhB,CAAlD;AACA,SAAQE,WAAW,IACf3F,qBAAqB,CAACuF,IAAtB,CAA2BI,WAA3B,CADI,IAEJH,eAFI,IAGJxF,qBAAqB,CAACuF,IAAtB,CAA2BC,eAA3B,CAHJ;AAIH;;AACD,SAASzB,YAAT,CAAsBvB,OAAtB,EAA+BI,QAA/B,EAAyC;AACrC,MAAIT,OAAO,GAAGK,OAAO,CAACS,QAAR,EAAd;AACA/D,EAAAA,SAAS,CAAC8E,MAAV,CAAiB7B,OAAjB;AACA,MAAIC,OAAO,GAAGD,OAAO,CAAC0B,QAAtB;AACA3E,EAAAA,SAAS,CAAC8E,MAAV,CAAiB5B,OAAjB;AACAvD,EAAAA,QAAQ,CAACqB,OAAT,CAAiB0F,SAAjB,CAA2BhD,QAA3B,EAAqC,EAArC;;AACA,MAAIT,OAAO,CAACkC,IAAR,KAAiBjC,OAAO,CAACiC,IAA7B,EAAmC;AAC/B,WAAO,KAAP;AACH;;AACD,MAAI5B,OAAO,GAAG,IAAIjD,WAAW,CAACU,OAAhB,CAAwBkC,OAAxB,CAAd;AACA,MAAIyD,UAAU,GAAGC,iBAAiB,CAACtD,OAAD,EAAUC,OAAV,EAAmBG,QAAnB,CAAlC;;AACA,MAAI,CAACiD,UAAL,EAAiB;AACb;AACA;AACAjD,IAAAA,QAAQ,CAAC3B,MAAT,GAAkB,CAAlB;AACH;;AACD,SAAO4E,UAAP;AACH;;AACD,SAASE,eAAT,CAAyBvD,OAAzB,EAAkCC,OAAlC,EAA2CG,QAA3C,EAAqD;AACjD,MAAIT,OAAO,GAAGK,OAAO,CAACS,QAAR,EAAd;AACA,MAAIb,OAAO,GAAGK,OAAO,CAACQ,QAAR,EAAd;AACA,MAAId,OAAO,KAAKC,OAAhB,EACI,OAAO,IAAP;AACJ,MAAIxC,OAAO,CAACa,KAAR,CAAc0B,OAAd,CAAJ,EACI,OAAOW,iBAAiB,CAACN,OAAD,EAAUC,OAAV,EAAmBG,QAAnB,CAAxB;AACJ,MAAInD,QAAQ,CAACgB,KAAT,CAAe0B,OAAf,CAAJ,EACI,OAAO6D,kBAAkB,CAACxD,OAAD,EAAUC,OAAV,EAAmBG,QAAnB,CAAzB;AACJ,SAAO,KAAP;AACH;;AACD,SAASE,iBAAT,CAA2BN,OAA3B,EAAoCC,OAApC,EAA6CG,QAA7C,EAAuD;AACnD,MAAIT,OAAO,GAAGK,OAAO,CAACS,QAAR,EAAd;AACA,MAAIb,OAAO,GAAGK,OAAO,CAACQ,QAAR,EAAd;;AACA,MAAId,OAAO,KAAKC,OAAZ,IACAI,OAAO,CAACyD,gBAAR,EADA,IAEAxD,OAAO,CAACwD,gBAAR,EAFJ,EAEgC;AAC5B,WAAO,IAAP;AACH;;AACDrG,EAAAA,OAAO,CAACoE,MAAR,CAAe7B,OAAf;AACA,MAAI+D,GAAG,GAAG/D,OAAO,CAAClB,MAAlB;AACA,MAAI,EAAErB,OAAO,CAACa,KAAR,CAAc2B,OAAd,KAA0BA,OAAO,CAACnB,MAAR,KAAmBiF,GAA/C,CAAJ,EACI,OAAO,KAAP;;AACJ,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,GAApB,EAAyB,EAAEC,CAA3B,EAA8B;AAC1B3D,IAAAA,OAAO,CAACE,KAAR,CAAc/B,IAAd,CAAmBwF,CAAnB,EAAsBhE,OAAO,CAACgE,CAAD,CAA7B;AACA1D,IAAAA,OAAO,CAACC,KAAR,CAAc/B,IAAd,CAAmBwF,CAAnB,EAAsB/D,OAAO,CAAC+D,CAAD,CAA7B;AACA,QAAIN,UAAU,GAAGE,eAAe,CAACvD,OAAD,EAAUC,OAAV,EAAmBG,QAAnB,CAAhC;AACAJ,IAAAA,OAAO,CAACE,KAAR,CAAczB,MAAd,IAAwB,CAAxB;AACAwB,IAAAA,OAAO,CAACC,KAAR,CAAczB,MAAd,IAAwB,CAAxB;;AACA,QAAI,CAAC4E,UAAL,EAAiB;AACb,aAAO,KAAP;AACH;AACJ;;AACD,SAAO,IAAP;AACH;;AACD,SAASG,kBAAT,CAA4BxD,OAA5B,EAAqCC,OAArC,EAA8CG,QAA9C,EAAwD;AACpD,MAAIT,OAAO,GAAGK,OAAO,CAACS,QAAR,EAAd;AACAxD,EAAAA,QAAQ,CAACuE,MAAT,CAAgB7B,OAAhB;;AACA,MAAIA,OAAO,CAAC0B,QAAR,KAAqB,IAAzB,EAA+B;AAC3B;AACA,WAAO,KAAP;AACH;;AACD,MAAIzB,OAAO,GAAGK,OAAO,CAACQ,QAAR,EAAd;AACA,MAAI,CAACxD,QAAQ,CAACgB,KAAT,CAAe2B,OAAf,CAAL,EACI,OAAO,KAAP;;AACJ,MAAID,OAAO,KAAKC,OAAZ,IACAI,OAAO,CAACyD,gBAAR,EADA,IAEAxD,OAAO,CAACwD,gBAAR,EAFJ,EAEgC;AAC5B,WAAO,IAAP;AACH;;AACD,MAAI/G,SAAS,CAACuB,KAAV,CAAgB0B,OAAhB,CAAJ,EAA8B;AAC1B,QAAI,CAACjD,SAAS,CAACuB,KAAV,CAAgB2B,OAAhB,CAAL,EAA+B;AAC3B,aAAO,KAAP;AACH;;AACD,QAAIgE,aAAa,GAAG5D,OAAO,CAAC6D,aAAR,EAApB;AACA,QAAIC,aAAa,GAAG7D,OAAO,CAAC4D,aAAR,EAApB;;AACA,QAAIC,aAAa,KAAK,IAAlB,IACAA,aAAa,CAACjC,IAAd,KAAuB,wBADvB,IAEA+B,aAAa,KAAK,IAFlB,IAGAA,aAAa,CAAC/B,IAAd,KAAuB,wBAH3B,EAGqD;AACjD,UAAIkC,cAAc,GAAGD,aAAa,CAACE,MAAd,CAAqBvF,MAArB,KAAgC,CAAhC,IAAqC,CAAC,CAACqF,aAAa,CAACE,MAAd,CAAqB,CAArB,EAAwBC,IAApF;AACA,UAAIC,aAAa,GAAGN,aAAa,CAACI,MAAd,CAAqBvF,MAArB,KAAgC,CAAhC,IAAqC,CAAC,CAACmF,aAAa,CAACI,MAAd,CAAqB,CAArB,EAAwBC,IAAnF;;AACA,UAAI,CAACF,cAAD,IAAmBG,aAAvB,EAAsC;AAClC,eAAO,KAAP;AACH;AACJ,KAfyB,CAgB1B;AACA;;;AACA,QAAIvE,OAAO,CAACkC,IAAR,KAAiBjC,OAAO,CAACiC,IAA7B,EAAmC;AAC/B,UAAIsC,aAAa,GAAG,EAApB;;AACA,UAAIb,iBAAiB,CAACtD,OAAD,EAAUC,OAAV,EAAmBkE,aAAnB,CAArB,EAAwD;AACpD/D,QAAAA,QAAQ,CAACjC,IAAT,CAAciG,KAAd,CAAoBhE,QAApB,EAA8B+D,aAA9B;AACH,OAFD,MAGK,IAAIvE,OAAO,CAAC5B,GAAZ,EAAiB;AAClB;AACA;AACAoC,QAAAA,QAAQ,CAACjC,IAAT,CAAc;AACV8B,UAAAA,OAAO,EAAEA,OAAO,CAACoE,IAAR,EADC;AAEVrE,UAAAA,OAAO,EAAEA,OAAO,CAACqE,IAAR;AAFC,SAAd;AAIH,OAPI,MAQA;AACD,eAAO,KAAP;AACH;;AACD,aAAO,IAAP;AACH;;AACD,QAAIzH,UAAU,CAACqB,KAAX,CAAiB0B,OAAjB,KACA/C,UAAU,CAACqB,KAAX,CAAiB2B,OAAjB,CADA,IAEA;AACA;AACAA,IAAAA,OAAO,CAAC5B,GAJZ,EAIiB;AACb;AACA;AACA;AACAoC,MAAAA,QAAQ,CAACjC,IAAT,CAAc;AACV8B,QAAAA,OAAO,EAAEA,OAAO,CAACoE,IAAR,EADC;AAEVrE,QAAAA,OAAO,EAAEA,OAAO,CAACqE,IAAR;AAFC,OAAd;AAIA,aAAO,IAAP;AACH,KAjDyB,CAkD1B;AACA;AACA;;;AACA,WAAO,KAAP;AACH;;AACD,SAAOf,iBAAiB,CAACtD,OAAD,EAAUC,OAAV,EAAmBG,QAAnB,CAAxB;AACH;;AACD,SAASkD,iBAAT,CAA2BtD,OAA3B,EAAoCC,OAApC,EAA6CG,QAA7C,EAAuD;AACnD,MAAIT,OAAO,GAAGK,OAAO,CAACS,QAAR,EAAd;AACA,MAAIb,OAAO,GAAGK,OAAO,CAACQ,QAAR,EAAd;AACAxD,EAAAA,QAAQ,CAACuE,MAAT,CAAgB7B,OAAhB;AACA1C,EAAAA,QAAQ,CAACuE,MAAT,CAAgB5B,OAAhB;;AACA,MAAID,OAAO,CAAC0B,QAAR,KAAqB,IAAzB,EAA+B;AAC3B;AACA,WAAO,KAAP;AACH,GARkD,CASnD;AACA;AACA;;;AACA,MAAIrB,OAAO,CAACqC,WAAR,MAAyB,CAACpC,OAAO,CAAC6B,SAAR,EAA9B,EAAmD;AAC/C,WAAO,KAAP;AACH;;AACD,MAAIwC,IAAI,GAAGvH,MAAM,CAACwH,cAAP,CAAsB3E,OAAtB,EAA+BD,OAA/B,CAAX;;AACA,MAAIC,OAAO,CAACiC,IAAR,KAAiB,MAAjB,IAA2BlC,OAAO,CAACkC,IAAR,KAAiB,MAAhD,EAAwD;AACpD;AACA;AACA,WAAOyC,IAAI,CAACE,MAAZ;AACH,GApBkD,CAqBnD;;;AACA,SAAOF,IAAI,CAACtG,GAAZ;AACA,MAAIyG,oBAAoB,GAAGrE,QAAQ,CAAC3B,MAApC;;AACA,OAAK,IAAIiG,CAAT,IAAcJ,IAAd,EAAoB;AAChB,QAAII,CAAC,CAAC9B,MAAF,CAAS,CAAT,MAAgB,GAApB,EAAyB;AACrB;AACA;AACA;AACH;;AACD5C,IAAAA,OAAO,CAACE,KAAR,CAAc/B,IAAd,CAAmBuG,CAAnB,EAAsBjI,KAAK,CAACkI,aAAN,CAAoBhF,OAApB,EAA6B+E,CAA7B,CAAtB;AACAzE,IAAAA,OAAO,CAACC,KAAR,CAAc/B,IAAd,CAAmBuG,CAAnB,EAAsBjI,KAAK,CAACkI,aAAN,CAAoB/E,OAApB,EAA6B8E,CAA7B,CAAtB;AACA,QAAIrB,UAAU,GAAGE,eAAe,CAACvD,OAAD,EAAUC,OAAV,EAAmBG,QAAnB,CAAhC;AACAJ,IAAAA,OAAO,CAACE,KAAR,CAAczB,MAAd,IAAwB,CAAxB;AACAwB,IAAAA,OAAO,CAACC,KAAR,CAAczB,MAAd,IAAwB,CAAxB;;AACA,QAAI,CAAC4E,UAAL,EAAiB;AACb,aAAO,KAAP;AACH;AACJ,GAtCkD,CAuCnD;AACA;AACA;;;AACA,MAAIxG,eAAe,CAACoB,KAAhB,CAAsB+B,OAAO,CAAC4E,OAAR,EAAtB,KACAxE,QAAQ,CAAC3B,MAAT,GAAkBgG,oBADtB,EAC4C;AACxC,WAAO,KAAP;AACH;;AACD,SAAO,IAAP;AACH","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getReprinter = exports.Patcher = void 0;\nvar tslib_1 = require(\"tslib\");\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\nvar linesModule = tslib_1.__importStar(require(\"./lines\"));\nvar types = tslib_1.__importStar(require(\"ast-types\"));\nvar Printable = types.namedTypes.Printable;\nvar Expression = types.namedTypes.Expression;\nvar ReturnStatement = types.namedTypes.ReturnStatement;\nvar SourceLocation = types.namedTypes.SourceLocation;\nvar util_1 = require(\"./util\");\nvar fast_path_1 = tslib_1.__importDefault(require(\"./fast-path\"));\nvar isObject = types.builtInTypes.object;\nvar isArray = types.builtInTypes.array;\nvar isString = types.builtInTypes.string;\nvar riskyAdjoiningCharExp = /[0-9a-z_$]/i;\nvar Patcher = function Patcher(lines) {\n    assert_1.default.ok(this instanceof Patcher);\n    assert_1.default.ok(lines instanceof linesModule.Lines);\n    var self = this, replacements = [];\n    self.replace = function (loc, lines) {\n        if (isString.check(lines))\n            lines = linesModule.fromString(lines);\n        replacements.push({\n            lines: lines,\n            start: loc.start,\n            end: loc.end,\n        });\n    };\n    self.get = function (loc) {\n        // If no location is provided, return the complete Lines object.\n        loc = loc || {\n            start: { line: 1, column: 0 },\n            end: { line: lines.length, column: lines.getLineLength(lines.length) },\n        };\n        var sliceFrom = loc.start, toConcat = [];\n        function pushSlice(from, to) {\n            assert_1.default.ok(util_1.comparePos(from, to) <= 0);\n            toConcat.push(lines.slice(from, to));\n        }\n        replacements\n            .sort(function (a, b) { return util_1.comparePos(a.start, b.start); })\n            .forEach(function (rep) {\n            if (util_1.comparePos(sliceFrom, rep.start) > 0) {\n                // Ignore nested replacement ranges.\n            }\n            else {\n                pushSlice(sliceFrom, rep.start);\n                toConcat.push(rep.lines);\n                sliceFrom = rep.end;\n            }\n        });\n        pushSlice(sliceFrom, loc.end);\n        return linesModule.concat(toConcat);\n    };\n};\nexports.Patcher = Patcher;\nvar Pp = Patcher.prototype;\nPp.tryToReprintComments = function (newNode, oldNode, print) {\n    var patcher = this;\n    if (!newNode.comments && !oldNode.comments) {\n        // We were (vacuously) able to reprint all the comments!\n        return true;\n    }\n    var newPath = fast_path_1.default.from(newNode);\n    var oldPath = fast_path_1.default.from(oldNode);\n    newPath.stack.push(\"comments\", getSurroundingComments(newNode));\n    oldPath.stack.push(\"comments\", getSurroundingComments(oldNode));\n    var reprints = [];\n    var ableToReprintComments = findArrayReprints(newPath, oldPath, reprints);\n    // No need to pop anything from newPath.stack or oldPath.stack, since\n    // newPath and oldPath are fresh local variables.\n    if (ableToReprintComments && reprints.length > 0) {\n        reprints.forEach(function (reprint) {\n            var oldComment = reprint.oldPath.getValue();\n            assert_1.default.ok(oldComment.leading || oldComment.trailing);\n            patcher.replace(oldComment.loc, \n            // Comments can't have .comments, so it doesn't matter whether we\n            // print with comments or without.\n            print(reprint.newPath).indentTail(oldComment.loc.indent));\n        });\n    }\n    return ableToReprintComments;\n};\n// Get all comments that are either leading or trailing, ignoring any\n// comments that occur inside node.loc. Returns an empty array for nodes\n// with no leading or trailing comments.\nfunction getSurroundingComments(node) {\n    var result = [];\n    if (node.comments && node.comments.length > 0) {\n        node.comments.forEach(function (comment) {\n            if (comment.leading || comment.trailing) {\n                result.push(comment);\n            }\n        });\n    }\n    return result;\n}\nPp.deleteComments = function (node) {\n    if (!node.comments) {\n        return;\n    }\n    var patcher = this;\n    node.comments.forEach(function (comment) {\n        if (comment.leading) {\n            // Delete leading comments along with any trailing whitespace they\n            // might have.\n            patcher.replace({\n                start: comment.loc.start,\n                end: node.loc.lines.skipSpaces(comment.loc.end, false, false),\n            }, \"\");\n        }\n        else if (comment.trailing) {\n            // Delete trailing comments along with any leading whitespace they\n            // might have.\n            patcher.replace({\n                start: node.loc.lines.skipSpaces(comment.loc.start, true, false),\n                end: comment.loc.end,\n            }, \"\");\n        }\n    });\n};\nfunction getReprinter(path) {\n    assert_1.default.ok(path instanceof fast_path_1.default);\n    // Make sure that this path refers specifically to a Node, rather than\n    // some non-Node subproperty of a Node.\n    var node = path.getValue();\n    if (!Printable.check(node))\n        return;\n    var orig = node.original;\n    var origLoc = orig && orig.loc;\n    var lines = origLoc && origLoc.lines;\n    var reprints = [];\n    if (!lines || !findReprints(path, reprints))\n        return;\n    return function (print) {\n        var patcher = new Patcher(lines);\n        reprints.forEach(function (reprint) {\n            var newNode = reprint.newPath.getValue();\n            var oldNode = reprint.oldPath.getValue();\n            SourceLocation.assert(oldNode.loc, true);\n            var needToPrintNewPathWithComments = !patcher.tryToReprintComments(newNode, oldNode, print);\n            if (needToPrintNewPathWithComments) {\n                // Since we were not able to preserve all leading/trailing\n                // comments, we delete oldNode's comments, print newPath with\n                // comments, and then patch the resulting lines where oldNode used\n                // to be.\n                patcher.deleteComments(oldNode);\n            }\n            var newLines = print(reprint.newPath, {\n                includeComments: needToPrintNewPathWithComments,\n                // If the oldNode we're replacing already had parentheses, we may\n                // not need to print the new node with any extra parentheses,\n                // because the existing parentheses will suffice. However, if the\n                // newNode has a different type than the oldNode, let the printer\n                // decide if reprint.newPath needs parentheses, as usual.\n                avoidRootParens: oldNode.type === newNode.type && reprint.oldPath.hasParens(),\n            }).indentTail(oldNode.loc.indent);\n            var nls = needsLeadingSpace(lines, oldNode.loc, newLines);\n            var nts = needsTrailingSpace(lines, oldNode.loc, newLines);\n            // If we try to replace the argument of a ReturnStatement like\n            // return\"asdf\" with e.g. a literal null expression, we run the risk\n            // of ending up with returnnull, so we need to add an extra leading\n            // space in situations where that might happen. Likewise for\n            // \"asdf\"in obj. See #170.\n            if (nls || nts) {\n                var newParts = [];\n                nls && newParts.push(\" \");\n                newParts.push(newLines);\n                nts && newParts.push(\" \");\n                newLines = linesModule.concat(newParts);\n            }\n            patcher.replace(oldNode.loc, newLines);\n        });\n        // Recall that origLoc is the .loc of an ancestor node that is\n        // guaranteed to contain all the reprinted nodes and comments.\n        var patchedLines = patcher.get(origLoc).indentTail(-orig.loc.indent);\n        if (path.needsParens()) {\n            return linesModule.concat([\"(\", patchedLines, \")\"]);\n        }\n        return patchedLines;\n    };\n}\nexports.getReprinter = getReprinter;\n// If the last character before oldLoc and the first character of newLines\n// are both identifier characters, they must be separated by a space,\n// otherwise they will most likely get fused together into a single token.\nfunction needsLeadingSpace(oldLines, oldLoc, newLines) {\n    var posBeforeOldLoc = util_1.copyPos(oldLoc.start);\n    // The character just before the location occupied by oldNode.\n    var charBeforeOldLoc = oldLines.prevPos(posBeforeOldLoc) && oldLines.charAt(posBeforeOldLoc);\n    // First character of the reprinted node.\n    var newFirstChar = newLines.charAt(newLines.firstPos());\n    return (charBeforeOldLoc &&\n        riskyAdjoiningCharExp.test(charBeforeOldLoc) &&\n        newFirstChar &&\n        riskyAdjoiningCharExp.test(newFirstChar));\n}\n// If the last character of newLines and the first character after oldLoc\n// are both identifier characters, they must be separated by a space,\n// otherwise they will most likely get fused together into a single token.\nfunction needsTrailingSpace(oldLines, oldLoc, newLines) {\n    // The character just after the location occupied by oldNode.\n    var charAfterOldLoc = oldLines.charAt(oldLoc.end);\n    var newLastPos = newLines.lastPos();\n    // Last character of the reprinted node.\n    var newLastChar = newLines.prevPos(newLastPos) && newLines.charAt(newLastPos);\n    return (newLastChar &&\n        riskyAdjoiningCharExp.test(newLastChar) &&\n        charAfterOldLoc &&\n        riskyAdjoiningCharExp.test(charAfterOldLoc));\n}\nfunction findReprints(newPath, reprints) {\n    var newNode = newPath.getValue();\n    Printable.assert(newNode);\n    var oldNode = newNode.original;\n    Printable.assert(oldNode);\n    assert_1.default.deepEqual(reprints, []);\n    if (newNode.type !== oldNode.type) {\n        return false;\n    }\n    var oldPath = new fast_path_1.default(oldNode);\n    var canReprint = findChildReprints(newPath, oldPath, reprints);\n    if (!canReprint) {\n        // Make absolutely sure the calling code does not attempt to reprint\n        // any nodes.\n        reprints.length = 0;\n    }\n    return canReprint;\n}\nfunction findAnyReprints(newPath, oldPath, reprints) {\n    var newNode = newPath.getValue();\n    var oldNode = oldPath.getValue();\n    if (newNode === oldNode)\n        return true;\n    if (isArray.check(newNode))\n        return findArrayReprints(newPath, oldPath, reprints);\n    if (isObject.check(newNode))\n        return findObjectReprints(newPath, oldPath, reprints);\n    return false;\n}\nfunction findArrayReprints(newPath, oldPath, reprints) {\n    var newNode = newPath.getValue();\n    var oldNode = oldPath.getValue();\n    if (newNode === oldNode ||\n        newPath.valueIsDuplicate() ||\n        oldPath.valueIsDuplicate()) {\n        return true;\n    }\n    isArray.assert(newNode);\n    var len = newNode.length;\n    if (!(isArray.check(oldNode) && oldNode.length === len))\n        return false;\n    for (var i = 0; i < len; ++i) {\n        newPath.stack.push(i, newNode[i]);\n        oldPath.stack.push(i, oldNode[i]);\n        var canReprint = findAnyReprints(newPath, oldPath, reprints);\n        newPath.stack.length -= 2;\n        oldPath.stack.length -= 2;\n        if (!canReprint) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction findObjectReprints(newPath, oldPath, reprints) {\n    var newNode = newPath.getValue();\n    isObject.assert(newNode);\n    if (newNode.original === null) {\n        // If newNode.original node was set to null, reprint the node.\n        return false;\n    }\n    var oldNode = oldPath.getValue();\n    if (!isObject.check(oldNode))\n        return false;\n    if (newNode === oldNode ||\n        newPath.valueIsDuplicate() ||\n        oldPath.valueIsDuplicate()) {\n        return true;\n    }\n    if (Printable.check(newNode)) {\n        if (!Printable.check(oldNode)) {\n            return false;\n        }\n        var newParentNode = newPath.getParentNode();\n        var oldParentNode = oldPath.getParentNode();\n        if (oldParentNode !== null &&\n            oldParentNode.type === \"FunctionTypeAnnotation\" &&\n            newParentNode !== null &&\n            newParentNode.type === \"FunctionTypeAnnotation\") {\n            var oldNeedsParens = oldParentNode.params.length !== 1 || !!oldParentNode.params[0].name;\n            var newNeedParens = newParentNode.params.length !== 1 || !!newParentNode.params[0].name;\n            if (!oldNeedsParens && newNeedParens) {\n                return false;\n            }\n        }\n        // Here we need to decide whether the reprinted code for newNode is\n        // appropriate for patching into the location of oldNode.\n        if (newNode.type === oldNode.type) {\n            var childReprints = [];\n            if (findChildReprints(newPath, oldPath, childReprints)) {\n                reprints.push.apply(reprints, childReprints);\n            }\n            else if (oldNode.loc) {\n                // If we have no .loc information for oldNode, then we won't be\n                // able to reprint it.\n                reprints.push({\n                    oldPath: oldPath.copy(),\n                    newPath: newPath.copy(),\n                });\n            }\n            else {\n                return false;\n            }\n            return true;\n        }\n        if (Expression.check(newNode) &&\n            Expression.check(oldNode) &&\n            // If we have no .loc information for oldNode, then we won't be\n            // able to reprint it.\n            oldNode.loc) {\n            // If both nodes are subtypes of Expression, then we should be able\n            // to fill the location occupied by the old node with code printed\n            // for the new node with no ill consequences.\n            reprints.push({\n                oldPath: oldPath.copy(),\n                newPath: newPath.copy(),\n            });\n            return true;\n        }\n        // The nodes have different types, and at least one of the types is\n        // not a subtype of the Expression type, so we cannot safely assume\n        // the nodes are syntactically interchangeable.\n        return false;\n    }\n    return findChildReprints(newPath, oldPath, reprints);\n}\nfunction findChildReprints(newPath, oldPath, reprints) {\n    var newNode = newPath.getValue();\n    var oldNode = oldPath.getValue();\n    isObject.assert(newNode);\n    isObject.assert(oldNode);\n    if (newNode.original === null) {\n        // If newNode.original node was set to null, reprint the node.\n        return false;\n    }\n    // If this node needs parentheses and will not be wrapped with\n    // parentheses when reprinted, then return false to skip reprinting and\n    // let it be printed generically.\n    if (newPath.needsParens() && !oldPath.hasParens()) {\n        return false;\n    }\n    var keys = util_1.getUnionOfKeys(oldNode, newNode);\n    if (oldNode.type === \"File\" || newNode.type === \"File\") {\n        // Don't bother traversing file.tokens, an often very large array\n        // returned by Babylon, and useless for our purposes.\n        delete keys.tokens;\n    }\n    // Don't bother traversing .loc objects looking for reprintable nodes.\n    delete keys.loc;\n    var originalReprintCount = reprints.length;\n    for (var k in keys) {\n        if (k.charAt(0) === \"_\") {\n            // Ignore \"private\" AST properties added by e.g. Babel plugins and\n            // parsers like Babylon.\n            continue;\n        }\n        newPath.stack.push(k, types.getFieldValue(newNode, k));\n        oldPath.stack.push(k, types.getFieldValue(oldNode, k));\n        var canReprint = findAnyReprints(newPath, oldPath, reprints);\n        newPath.stack.length -= 2;\n        oldPath.stack.length -= 2;\n        if (!canReprint) {\n            return false;\n        }\n    }\n    // Return statements might end up running into ASI issues due to\n    // comments inserted deep within the tree, so reprint them if anything\n    // changed within them.\n    if (ReturnStatement.check(newPath.getNode()) &&\n        reprints.length > originalReprintCount) {\n        return false;\n    }\n    return true;\n}\n"]},"metadata":{},"sourceType":"script"}