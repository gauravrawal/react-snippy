{"ast":null,"code":"module.exports = create;\n\nvar classifyCharacter = require('micromark/dist/util/classify-character');\n\nvar chunkedSplice = require('micromark/dist/util/chunked-splice');\n\nvar resolveAll = require('micromark/dist/util/resolve-all');\n\nvar shallow = require('micromark/dist/util/shallow');\n\nfunction create(options) {\n  var settings = options || {};\n  var single = settings.singleTilde;\n  var tokenizer = {\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  };\n\n  if (single === null || single === undefined) {\n    single = true;\n  }\n\n  return {\n    text: {\n      126: tokenizer\n    },\n    insideSpan: {\n      null: tokenizer\n    }\n  }; // Take events and resolve strikethrough.\n\n  function resolveAllStrikethrough(events, context) {\n    var index = -1;\n    var strikethrough;\n    var text;\n    var open;\n    var nextEvents; // Walk through all events.\n\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (events[index][0] === 'enter' && events[index][1].type === 'strikethroughSequenceTemporary' && events[index][1]._close) {\n        open = index; // Now walk back to find an opener.\n\n        while (open--) {\n          // Find a token that can open the closer.\n          if (events[open][0] === 'exit' && events[open][1].type === 'strikethroughSequenceTemporary' && events[open][1]._open && // If the sizes are the same:\n          events[index][1].end.offset - events[index][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {\n            events[index][1].type = 'strikethroughSequence';\n            events[open][1].type = 'strikethroughSequence';\n            strikethrough = {\n              type: 'strikethrough',\n              start: shallow(events[open][1].start),\n              end: shallow(events[index][1].end)\n            };\n            text = {\n              type: 'strikethroughText',\n              start: shallow(events[open][1].end),\n              end: shallow(events[index][1].start)\n            }; // Opening.\n\n            nextEvents = [['enter', strikethrough, context], ['enter', events[open][1], context], ['exit', events[open][1], context], ['enter', text, context]]; // Between.\n\n            chunkedSplice(nextEvents, nextEvents.length, 0, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index), context)); // Closing.\n\n            chunkedSplice(nextEvents, nextEvents.length, 0, [['exit', text, context], ['enter', events[index][1], context], ['exit', events[index][1], context], ['exit', strikethrough, context]]);\n            chunkedSplice(events, open - 1, index - open + 3, nextEvents);\n            index = open + nextEvents.length - 2;\n            break;\n          }\n        }\n      }\n    }\n\n    return removeRemainingSequences(events);\n  }\n\n  function removeRemainingSequences(events) {\n    var index = -1;\n    var length = events.length;\n\n    while (++index < length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = 'data';\n      }\n    }\n\n    return events;\n  }\n\n  function tokenizeStrikethrough(effects, ok, nok) {\n    var previous = this.previous;\n    var events = this.events;\n    var size = 0;\n    return start;\n\n    function start(code) {\n      if (code !== 126 || previous === 126 && events[events.length - 1][1].type !== 'characterEscape') {\n        return nok(code);\n      }\n\n      effects.enter('strikethroughSequenceTemporary');\n      return more(code);\n    }\n\n    function more(code) {\n      var before = classifyCharacter(previous);\n      var token;\n      var after;\n\n      if (code === 126) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code);\n        effects.consume(code);\n        size++;\n        return more;\n      }\n\n      if (size < 2 && !single) return nok(code);\n      token = effects.exit('strikethroughSequenceTemporary');\n      after = classifyCharacter(code);\n      token._open = !after || after === 2 && before;\n      token._close = !before || before === 2 && after;\n      return ok(code);\n    }\n  }\n}","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/jbook/node_modules/micromark-extension-gfm-strikethrough/index.js"],"names":["module","exports","create","classifyCharacter","require","chunkedSplice","resolveAll","shallow","options","settings","single","singleTilde","tokenizer","tokenize","tokenizeStrikethrough","resolveAllStrikethrough","undefined","text","insideSpan","null","events","context","index","strikethrough","open","nextEvents","length","type","_close","_open","end","offset","start","parser","constructs","slice","removeRemainingSequences","effects","ok","nok","previous","size","code","enter","more","before","token","after","consume","exit"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiBC,MAAjB;;AAEA,IAAIC,iBAAiB,GAAGC,OAAO,CAAC,wCAAD,CAA/B;;AACA,IAAIC,aAAa,GAAGD,OAAO,CAAC,oCAAD,CAA3B;;AACA,IAAIE,UAAU,GAAGF,OAAO,CAAC,iCAAD,CAAxB;;AACA,IAAIG,OAAO,GAAGH,OAAO,CAAC,6BAAD,CAArB;;AAEA,SAASF,MAAT,CAAgBM,OAAhB,EAAyB;AACvB,MAAIC,QAAQ,GAAGD,OAAO,IAAI,EAA1B;AACA,MAAIE,MAAM,GAAGD,QAAQ,CAACE,WAAtB;AACA,MAAIC,SAAS,GAAG;AACdC,IAAAA,QAAQ,EAAEC,qBADI;AAEdR,IAAAA,UAAU,EAAES;AAFE,GAAhB;;AAKA,MAAIL,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAKM,SAAlC,EAA6C;AAC3CN,IAAAA,MAAM,GAAG,IAAT;AACD;;AAED,SAAO;AAACO,IAAAA,IAAI,EAAE;AAAC,WAAKL;AAAN,KAAP;AAAyBM,IAAAA,UAAU,EAAE;AAACC,MAAAA,IAAI,EAAEP;AAAP;AAArC,GAAP,CAZuB,CAcvB;;AACA,WAASG,uBAAT,CAAiCK,MAAjC,EAAyCC,OAAzC,EAAkD;AAChD,QAAIC,KAAK,GAAG,CAAC,CAAb;AACA,QAAIC,aAAJ;AACA,QAAIN,IAAJ;AACA,QAAIO,IAAJ;AACA,QAAIC,UAAJ,CALgD,CAOhD;;AACA,WAAO,EAAEH,KAAF,GAAUF,MAAM,CAACM,MAAxB,EAAgC;AAC9B;AACA,UACEN,MAAM,CAACE,KAAD,CAAN,CAAc,CAAd,MAAqB,OAArB,IACAF,MAAM,CAACE,KAAD,CAAN,CAAc,CAAd,EAAiBK,IAAjB,KAA0B,gCAD1B,IAEAP,MAAM,CAACE,KAAD,CAAN,CAAc,CAAd,EAAiBM,MAHnB,EAIE;AACAJ,QAAAA,IAAI,GAAGF,KAAP,CADA,CAGA;;AACA,eAAOE,IAAI,EAAX,EAAe;AACb;AACA,cACEJ,MAAM,CAACI,IAAD,CAAN,CAAa,CAAb,MAAoB,MAApB,IACAJ,MAAM,CAACI,IAAD,CAAN,CAAa,CAAb,EAAgBG,IAAhB,KAAyB,gCADzB,IAEAP,MAAM,CAACI,IAAD,CAAN,CAAa,CAAb,EAAgBK,KAFhB,IAGA;AACAT,UAAAA,MAAM,CAACE,KAAD,CAAN,CAAc,CAAd,EAAiBQ,GAAjB,CAAqBC,MAArB,GAA8BX,MAAM,CAACE,KAAD,CAAN,CAAc,CAAd,EAAiBU,KAAjB,CAAuBD,MAArD,KACEX,MAAM,CAACI,IAAD,CAAN,CAAa,CAAb,EAAgBM,GAAhB,CAAoBC,MAApB,GAA6BX,MAAM,CAACI,IAAD,CAAN,CAAa,CAAb,EAAgBQ,KAAhB,CAAsBD,MANvD,EAOE;AACAX,YAAAA,MAAM,CAACE,KAAD,CAAN,CAAc,CAAd,EAAiBK,IAAjB,GAAwB,uBAAxB;AACAP,YAAAA,MAAM,CAACI,IAAD,CAAN,CAAa,CAAb,EAAgBG,IAAhB,GAAuB,uBAAvB;AAEAJ,YAAAA,aAAa,GAAG;AACdI,cAAAA,IAAI,EAAE,eADQ;AAEdK,cAAAA,KAAK,EAAEzB,OAAO,CAACa,MAAM,CAACI,IAAD,CAAN,CAAa,CAAb,EAAgBQ,KAAjB,CAFA;AAGdF,cAAAA,GAAG,EAAEvB,OAAO,CAACa,MAAM,CAACE,KAAD,CAAN,CAAc,CAAd,EAAiBQ,GAAlB;AAHE,aAAhB;AAMAb,YAAAA,IAAI,GAAG;AACLU,cAAAA,IAAI,EAAE,mBADD;AAELK,cAAAA,KAAK,EAAEzB,OAAO,CAACa,MAAM,CAACI,IAAD,CAAN,CAAa,CAAb,EAAgBM,GAAjB,CAFT;AAGLA,cAAAA,GAAG,EAAEvB,OAAO,CAACa,MAAM,CAACE,KAAD,CAAN,CAAc,CAAd,EAAiBU,KAAlB;AAHP,aAAP,CAVA,CAgBA;;AACAP,YAAAA,UAAU,GAAG,CACX,CAAC,OAAD,EAAUF,aAAV,EAAyBF,OAAzB,CADW,EAEX,CAAC,OAAD,EAAUD,MAAM,CAACI,IAAD,CAAN,CAAa,CAAb,CAAV,EAA2BH,OAA3B,CAFW,EAGX,CAAC,MAAD,EAASD,MAAM,CAACI,IAAD,CAAN,CAAa,CAAb,CAAT,EAA0BH,OAA1B,CAHW,EAIX,CAAC,OAAD,EAAUJ,IAAV,EAAgBI,OAAhB,CAJW,CAAb,CAjBA,CAwBA;;AACAhB,YAAAA,aAAa,CACXoB,UADW,EAEXA,UAAU,CAACC,MAFA,EAGX,CAHW,EAIXpB,UAAU,CACRe,OAAO,CAACY,MAAR,CAAeC,UAAf,CAA0BhB,UAA1B,CAAqCC,IAD7B,EAERC,MAAM,CAACe,KAAP,CAAaX,IAAI,GAAG,CAApB,EAAuBF,KAAvB,CAFQ,EAGRD,OAHQ,CAJC,CAAb,CAzBA,CAoCA;;AACAhB,YAAAA,aAAa,CAACoB,UAAD,EAAaA,UAAU,CAACC,MAAxB,EAAgC,CAAhC,EAAmC,CAC9C,CAAC,MAAD,EAAST,IAAT,EAAeI,OAAf,CAD8C,EAE9C,CAAC,OAAD,EAAUD,MAAM,CAACE,KAAD,CAAN,CAAc,CAAd,CAAV,EAA4BD,OAA5B,CAF8C,EAG9C,CAAC,MAAD,EAASD,MAAM,CAACE,KAAD,CAAN,CAAc,CAAd,CAAT,EAA2BD,OAA3B,CAH8C,EAI9C,CAAC,MAAD,EAASE,aAAT,EAAwBF,OAAxB,CAJ8C,CAAnC,CAAb;AAOAhB,YAAAA,aAAa,CAACe,MAAD,EAASI,IAAI,GAAG,CAAhB,EAAmBF,KAAK,GAAGE,IAAR,GAAe,CAAlC,EAAqCC,UAArC,CAAb;AAEAH,YAAAA,KAAK,GAAGE,IAAI,GAAGC,UAAU,CAACC,MAAlB,GAA2B,CAAnC;AACA;AACD;AACF;AACF;AACF;;AAED,WAAOU,wBAAwB,CAAChB,MAAD,CAA/B;AACD;;AAED,WAASgB,wBAAT,CAAkChB,MAAlC,EAA0C;AACxC,QAAIE,KAAK,GAAG,CAAC,CAAb;AACA,QAAII,MAAM,GAAGN,MAAM,CAACM,MAApB;;AAEA,WAAO,EAAEJ,KAAF,GAAUI,MAAjB,EAAyB;AACvB,UAAIN,MAAM,CAACE,KAAD,CAAN,CAAc,CAAd,EAAiBK,IAAjB,KAA0B,gCAA9B,EAAgE;AAC9DP,QAAAA,MAAM,CAACE,KAAD,CAAN,CAAc,CAAd,EAAiBK,IAAjB,GAAwB,MAAxB;AACD;AACF;;AAED,WAAOP,MAAP;AACD;;AAED,WAASN,qBAAT,CAA+BuB,OAA/B,EAAwCC,EAAxC,EAA4CC,GAA5C,EAAiD;AAC/C,QAAIC,QAAQ,GAAG,KAAKA,QAApB;AACA,QAAIpB,MAAM,GAAG,KAAKA,MAAlB;AACA,QAAIqB,IAAI,GAAG,CAAX;AAEA,WAAOT,KAAP;;AAEA,aAASA,KAAT,CAAeU,IAAf,EAAqB;AACnB,UACEA,IAAI,KAAK,GAAT,IACCF,QAAQ,KAAK,GAAb,IACCpB,MAAM,CAACA,MAAM,CAACM,MAAP,GAAgB,CAAjB,CAAN,CAA0B,CAA1B,EAA6BC,IAA7B,KAAsC,iBAH1C,EAIE;AACA,eAAOY,GAAG,CAACG,IAAD,CAAV;AACD;;AAEDL,MAAAA,OAAO,CAACM,KAAR,CAAc,gCAAd;AACA,aAAOC,IAAI,CAACF,IAAD,CAAX;AACD;;AAED,aAASE,IAAT,CAAcF,IAAd,EAAoB;AAClB,UAAIG,MAAM,GAAG1C,iBAAiB,CAACqC,QAAD,CAA9B;AACA,UAAIM,KAAJ;AACA,UAAIC,KAAJ;;AAEA,UAAIL,IAAI,KAAK,GAAb,EAAkB;AAChB;AACA,YAAID,IAAI,GAAG,CAAX,EAAc,OAAOF,GAAG,CAACG,IAAD,CAAV;AACdL,QAAAA,OAAO,CAACW,OAAR,CAAgBN,IAAhB;AACAD,QAAAA,IAAI;AACJ,eAAOG,IAAP;AACD;;AAED,UAAIH,IAAI,GAAG,CAAP,IAAY,CAAC/B,MAAjB,EAAyB,OAAO6B,GAAG,CAACG,IAAD,CAAV;AACzBI,MAAAA,KAAK,GAAGT,OAAO,CAACY,IAAR,CAAa,gCAAb,CAAR;AACAF,MAAAA,KAAK,GAAG5C,iBAAiB,CAACuC,IAAD,CAAzB;AACAI,MAAAA,KAAK,CAACjB,KAAN,GAAc,CAACkB,KAAD,IAAWA,KAAK,KAAK,CAAV,IAAeF,MAAxC;AACAC,MAAAA,KAAK,CAAClB,MAAN,GAAe,CAACiB,MAAD,IAAYA,MAAM,KAAK,CAAX,IAAgBE,KAA3C;AACA,aAAOT,EAAE,CAACI,IAAD,CAAT;AACD;AACF;AACF","sourcesContent":["module.exports = create\n\nvar classifyCharacter = require('micromark/dist/util/classify-character')\nvar chunkedSplice = require('micromark/dist/util/chunked-splice')\nvar resolveAll = require('micromark/dist/util/resolve-all')\nvar shallow = require('micromark/dist/util/shallow')\n\nfunction create(options) {\n  var settings = options || {}\n  var single = settings.singleTilde\n  var tokenizer = {\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  }\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  return {text: {126: tokenizer}, insideSpan: {null: tokenizer}}\n\n  // Take events and resolve strikethrough.\n  function resolveAllStrikethrough(events, context) {\n    var index = -1\n    var strikethrough\n    var text\n    var open\n    var nextEvents\n\n    // Walk through all events.\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (\n        events[index][0] === 'enter' &&\n        events[index][1].type === 'strikethroughSequenceTemporary' &&\n        events[index][1]._close\n      ) {\n        open = index\n\n        // Now walk back to find an opener.\n        while (open--) {\n          // Find a token that can open the closer.\n          if (\n            events[open][0] === 'exit' &&\n            events[open][1].type === 'strikethroughSequenceTemporary' &&\n            events[open][1]._open &&\n            // If the sizes are the same:\n            events[index][1].end.offset - events[index][1].start.offset ===\n              events[open][1].end.offset - events[open][1].start.offset\n          ) {\n            events[index][1].type = 'strikethroughSequence'\n            events[open][1].type = 'strikethroughSequence'\n\n            strikethrough = {\n              type: 'strikethrough',\n              start: shallow(events[open][1].start),\n              end: shallow(events[index][1].end)\n            }\n\n            text = {\n              type: 'strikethroughText',\n              start: shallow(events[open][1].end),\n              end: shallow(events[index][1].start)\n            }\n\n            // Opening.\n            nextEvents = [\n              ['enter', strikethrough, context],\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context],\n              ['enter', text, context]\n            ]\n\n            // Between.\n            chunkedSplice(\n              nextEvents,\n              nextEvents.length,\n              0,\n              resolveAll(\n                context.parser.constructs.insideSpan.null,\n                events.slice(open + 1, index),\n                context\n              )\n            )\n\n            // Closing.\n            chunkedSplice(nextEvents, nextEvents.length, 0, [\n              ['exit', text, context],\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context],\n              ['exit', strikethrough, context]\n            ])\n\n            chunkedSplice(events, open - 1, index - open + 3, nextEvents)\n\n            index = open + nextEvents.length - 2\n            break\n          }\n        }\n      }\n    }\n\n    return removeRemainingSequences(events)\n  }\n\n  function removeRemainingSequences(events) {\n    var index = -1\n    var length = events.length\n\n    while (++index < length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = 'data'\n      }\n    }\n\n    return events\n  }\n\n  function tokenizeStrikethrough(effects, ok, nok) {\n    var previous = this.previous\n    var events = this.events\n    var size = 0\n\n    return start\n\n    function start(code) {\n      if (\n        code !== 126 ||\n        (previous === 126 &&\n          events[events.length - 1][1].type !== 'characterEscape')\n      ) {\n        return nok(code)\n      }\n\n      effects.enter('strikethroughSequenceTemporary')\n      return more(code)\n    }\n\n    function more(code) {\n      var before = classifyCharacter(previous)\n      var token\n      var after\n\n      if (code === 126) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code)\n        effects.consume(code)\n        size++\n        return more\n      }\n\n      if (size < 2 && !single) return nok(code)\n      token = effects.exit('strikethroughSequenceTemporary')\n      after = classifyCharacter(code)\n      token._open = !after || (after === 2 && before)\n      token._close = !before || (before === 2 && after)\n      return ok(code)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}