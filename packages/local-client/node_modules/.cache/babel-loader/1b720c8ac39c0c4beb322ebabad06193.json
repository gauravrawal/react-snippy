{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Printer = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\n\nvar comments_1 = require(\"./comments\");\n\nvar lines_1 = require(\"./lines\");\n\nvar options_1 = require(\"./options\");\n\nvar patcher_1 = require(\"./patcher\");\n\nvar types = tslib_1.__importStar(require(\"ast-types\"));\n\nvar namedTypes = types.namedTypes;\nvar isString = types.builtInTypes.string;\nvar isObject = types.builtInTypes.object;\n\nvar fast_path_1 = tslib_1.__importDefault(require(\"./fast-path\"));\n\nvar util = tslib_1.__importStar(require(\"./util\"));\n\nvar PrintResult = function PrintResult(code, sourceMap) {\n  assert_1.default.ok(this instanceof PrintResult);\n  isString.assert(code);\n  this.code = code;\n\n  if (sourceMap) {\n    isObject.assert(sourceMap);\n    this.map = sourceMap;\n  }\n};\n\nvar PRp = PrintResult.prototype;\nvar warnedAboutToString = false;\n\nPRp.toString = function () {\n  if (!warnedAboutToString) {\n    console.warn(\"Deprecation warning: recast.print now returns an object with \" + \"a .code property. You appear to be treating the object as a \" + \"string, which might still work but is strongly discouraged.\");\n    warnedAboutToString = true;\n  }\n\n  return this.code;\n};\n\nvar emptyPrintResult = new PrintResult(\"\");\n\nvar Printer = function Printer(config) {\n  assert_1.default.ok(this instanceof Printer);\n  var explicitTabWidth = config && config.tabWidth;\n  config = options_1.normalize(config); // It's common for client code to pass the same options into both\n  // recast.parse and recast.print, but the Printer doesn't need (and\n  // can be confused by) config.sourceFileName, so we null it out.\n\n  config.sourceFileName = null; // Non-destructively modifies options with overrides, and returns a\n  // new print function that uses the modified options.\n\n  function makePrintFunctionWith(options, overrides) {\n    options = Object.assign({}, options, overrides);\n    return function (path) {\n      return print(path, options);\n    };\n  }\n\n  function print(path, options) {\n    assert_1.default.ok(path instanceof fast_path_1.default);\n    options = options || {};\n\n    if (options.includeComments) {\n      return comments_1.printComments(path, makePrintFunctionWith(options, {\n        includeComments: false\n      }));\n    }\n\n    var oldTabWidth = config.tabWidth;\n\n    if (!explicitTabWidth) {\n      var loc = path.getNode().loc;\n\n      if (loc && loc.lines && loc.lines.guessTabWidth) {\n        config.tabWidth = loc.lines.guessTabWidth();\n      }\n    }\n\n    var reprinter = patcher_1.getReprinter(path);\n    var lines = reprinter ? // Since the print function that we pass to the reprinter will\n    // be used to print \"new\" nodes, it's tempting to think we\n    // should pass printRootGenerically instead of print, to avoid\n    // calling maybeReprint again, but that would be a mistake\n    // because the new nodes might not be entirely new, but merely\n    // moved from elsewhere in the AST. The print function is the\n    // right choice because it gives us the opportunity to reprint\n    // such nodes using their original source.\n    reprinter(print) : genericPrint(path, config, options, makePrintFunctionWith(options, {\n      includeComments: true,\n      avoidRootParens: false\n    }));\n    config.tabWidth = oldTabWidth;\n    return lines;\n  }\n\n  this.print = function (ast) {\n    if (!ast) {\n      return emptyPrintResult;\n    }\n\n    var lines = print(fast_path_1.default.from(ast), {\n      includeComments: true,\n      avoidRootParens: false\n    });\n    return new PrintResult(lines.toString(config), util.composeSourceMaps(config.inputSourceMap, lines.getSourceMap(config.sourceMapName, config.sourceRoot)));\n  };\n\n  this.printGenerically = function (ast) {\n    if (!ast) {\n      return emptyPrintResult;\n    } // Print the entire AST generically.\n\n\n    function printGenerically(path) {\n      return comments_1.printComments(path, function (path) {\n        return genericPrint(path, config, {\n          includeComments: true,\n          avoidRootParens: false\n        }, printGenerically);\n      });\n    }\n\n    var path = fast_path_1.default.from(ast);\n    var oldReuseWhitespace = config.reuseWhitespace; // Do not reuse whitespace (or anything else, for that matter)\n    // when printing generically.\n\n    config.reuseWhitespace = false; // TODO Allow printing of comments?\n\n    var pr = new PrintResult(printGenerically(path).toString(config));\n    config.reuseWhitespace = oldReuseWhitespace;\n    return pr;\n  };\n};\n\nexports.Printer = Printer;\n\nfunction genericPrint(path, config, options, printPath) {\n  assert_1.default.ok(path instanceof fast_path_1.default);\n  var node = path.getValue();\n  var parts = [];\n  var linesWithoutParens = genericPrintNoParens(path, config, printPath);\n\n  if (!node || linesWithoutParens.isEmpty()) {\n    return linesWithoutParens;\n  }\n\n  var shouldAddParens = node.extra ? node.extra.parenthesized : false;\n  var decoratorsLines = printDecorators(path, printPath);\n\n  if (decoratorsLines.isEmpty()) {\n    // Nodes with decorators can't have parentheses, so we can avoid\n    // computing path.needsParens() except in this case.\n    if (!options.avoidRootParens) {\n      shouldAddParens = shouldAddParens || path.needsParens();\n    }\n  } else {\n    parts.push(decoratorsLines);\n  }\n\n  if (shouldAddParens) {\n    parts.unshift(\"(\");\n  }\n\n  parts.push(linesWithoutParens);\n\n  if (shouldAddParens) {\n    parts.push(\")\");\n  }\n\n  return lines_1.concat(parts);\n} // Note that the `options` parameter of this function is what other\n// functions in this file call the `config` object (that is, the\n// configuration object originally passed into the Printer constructor).\n// Its properties are documented in lib/options.js.\n\n\nfunction genericPrintNoParens(path, options, print) {\n  var n = path.getValue();\n\n  if (!n) {\n    return lines_1.fromString(\"\");\n  }\n\n  if (typeof n === \"string\") {\n    return lines_1.fromString(n, options);\n  }\n\n  namedTypes.Printable.assert(n);\n  var parts = [];\n\n  switch (n.type) {\n    case \"File\":\n      return path.call(print, \"program\");\n\n    case \"Program\":\n      // Babel 6\n      if (n.directives) {\n        path.each(function (childPath) {\n          parts.push(print(childPath), \";\\n\");\n        }, \"directives\");\n      }\n\n      if (n.interpreter) {\n        parts.push(path.call(print, \"interpreter\"));\n      }\n\n      parts.push(path.call(function (bodyPath) {\n        return printStatementSequence(bodyPath, options, print);\n      }, \"body\"));\n      return lines_1.concat(parts);\n\n    case \"Noop\": // Babel extension.\n\n    case \"EmptyStatement\":\n      return lines_1.fromString(\"\");\n\n    case \"ExpressionStatement\":\n      return lines_1.concat([path.call(print, \"expression\"), \";\"]);\n\n    case \"ParenthesizedExpression\":\n      // Babel extension.\n      return lines_1.concat([\"(\", path.call(print, \"expression\"), \")\"]);\n\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n    case \"AssignmentExpression\":\n      return lines_1.fromString(\" \").join([path.call(print, \"left\"), n.operator, path.call(print, \"right\")]);\n\n    case \"AssignmentPattern\":\n      return lines_1.concat([path.call(print, \"left\"), \" = \", path.call(print, \"right\")]);\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n      {\n        parts.push(path.call(print, \"object\"));\n        var property = path.call(print, \"property\"); // Like n.optional, except with defaults applied, so optional\n        // defaults to true for OptionalMemberExpression nodes.\n\n        var optional = types.getFieldValue(n, \"optional\");\n\n        if (n.computed) {\n          parts.push(optional ? \"?.[\" : \"[\", property, \"]\");\n        } else {\n          parts.push(optional ? \"?.\" : \".\", property);\n        }\n\n        return lines_1.concat(parts);\n      }\n\n    case \"ChainExpression\":\n      return path.call(print, \"expression\");\n\n    case \"MetaProperty\":\n      return lines_1.concat([path.call(print, \"meta\"), \".\", path.call(print, \"property\")]);\n\n    case \"BindExpression\":\n      if (n.object) {\n        parts.push(path.call(print, \"object\"));\n      }\n\n      parts.push(\"::\", path.call(print, \"callee\"));\n      return lines_1.concat(parts);\n\n    case \"Path\":\n      return lines_1.fromString(\".\").join(n.body);\n\n    case \"Identifier\":\n      return lines_1.concat([lines_1.fromString(n.name, options), n.optional ? \"?\" : \"\", path.call(print, \"typeAnnotation\")]);\n\n    case \"SpreadElement\":\n    case \"SpreadElementPattern\":\n    case \"RestProperty\": // Babel 6 for ObjectPattern\n\n    case \"SpreadProperty\":\n    case \"SpreadPropertyPattern\":\n    case \"ObjectTypeSpreadProperty\":\n    case \"RestElement\":\n      return lines_1.concat([\"...\", path.call(print, \"argument\"), path.call(print, \"typeAnnotation\")]);\n\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"TSDeclareFunction\":\n      if (n.declare) {\n        parts.push(\"declare \");\n      }\n\n      if (n.async) {\n        parts.push(\"async \");\n      }\n\n      parts.push(\"function\");\n      if (n.generator) parts.push(\"*\");\n\n      if (n.id) {\n        parts.push(\" \", path.call(print, \"id\"), path.call(print, \"typeParameters\"));\n      } else {\n        if (n.typeParameters) {\n          parts.push(path.call(print, \"typeParameters\"));\n        }\n      }\n\n      parts.push(\"(\", printFunctionParams(path, options, print), \")\", path.call(print, \"returnType\"));\n\n      if (n.body) {\n        parts.push(\" \", path.call(print, \"body\"));\n      }\n\n      return lines_1.concat(parts);\n\n    case \"ArrowFunctionExpression\":\n      if (n.async) {\n        parts.push(\"async \");\n      }\n\n      if (n.typeParameters) {\n        parts.push(path.call(print, \"typeParameters\"));\n      }\n\n      if (!options.arrowParensAlways && n.params.length === 1 && !n.rest && n.params[0].type === \"Identifier\" && !n.params[0].typeAnnotation && !n.returnType) {\n        parts.push(path.call(print, \"params\", 0));\n      } else {\n        parts.push(\"(\", printFunctionParams(path, options, print), \")\", path.call(print, \"returnType\"));\n      }\n\n      parts.push(\" => \", path.call(print, \"body\"));\n      return lines_1.concat(parts);\n\n    case \"MethodDefinition\":\n      return printMethod(path, options, print);\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      if (n.delegate) parts.push(\"*\");\n      if (n.argument) parts.push(\" \", path.call(print, \"argument\"));\n      return lines_1.concat(parts);\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      if (n.all) parts.push(\"*\");\n      if (n.argument) parts.push(\" \", path.call(print, \"argument\"));\n      return lines_1.concat(parts);\n\n    case \"ModuleDeclaration\":\n      parts.push(\"module\", path.call(print, \"id\"));\n\n      if (n.source) {\n        assert_1.default.ok(!n.body);\n        parts.push(\"from\", path.call(print, \"source\"));\n      } else {\n        parts.push(path.call(print, \"body\"));\n      }\n\n      return lines_1.fromString(\" \").join(parts);\n\n    case \"ImportSpecifier\":\n      if (n.importKind && n.importKind !== \"value\") {\n        parts.push(n.importKind + \" \");\n      }\n\n      if (n.imported) {\n        parts.push(path.call(print, \"imported\"));\n\n        if (n.local && n.local.name !== n.imported.name) {\n          parts.push(\" as \", path.call(print, \"local\"));\n        }\n      } else if (n.id) {\n        parts.push(path.call(print, \"id\"));\n\n        if (n.name) {\n          parts.push(\" as \", path.call(print, \"name\"));\n        }\n      }\n\n      return lines_1.concat(parts);\n\n    case \"ExportSpecifier\":\n      if (n.local) {\n        parts.push(path.call(print, \"local\"));\n\n        if (n.exported && n.exported.name !== n.local.name) {\n          parts.push(\" as \", path.call(print, \"exported\"));\n        }\n      } else if (n.id) {\n        parts.push(path.call(print, \"id\"));\n\n        if (n.name) {\n          parts.push(\" as \", path.call(print, \"name\"));\n        }\n      }\n\n      return lines_1.concat(parts);\n\n    case \"ExportBatchSpecifier\":\n      return lines_1.fromString(\"*\");\n\n    case \"ImportNamespaceSpecifier\":\n      parts.push(\"* as \");\n\n      if (n.local) {\n        parts.push(path.call(print, \"local\"));\n      } else if (n.id) {\n        parts.push(path.call(print, \"id\"));\n      }\n\n      return lines_1.concat(parts);\n\n    case \"ImportDefaultSpecifier\":\n      if (n.local) {\n        return path.call(print, \"local\");\n      }\n\n      return path.call(print, \"id\");\n\n    case \"TSExportAssignment\":\n      return lines_1.concat([\"export = \", path.call(print, \"expression\")]);\n\n    case \"ExportDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n      return printExportDeclaration(path, options, print);\n\n    case \"ExportAllDeclaration\":\n      parts.push(\"export *\");\n\n      if (n.exported) {\n        parts.push(\" as \", path.call(print, \"exported\"));\n      }\n\n      parts.push(\" from \", path.call(print, \"source\"), \";\");\n      return lines_1.concat(parts);\n\n    case \"TSNamespaceExportDeclaration\":\n      parts.push(\"export as namespace \", path.call(print, \"id\"));\n      return maybeAddSemicolon(lines_1.concat(parts));\n\n    case \"ExportNamespaceSpecifier\":\n      return lines_1.concat([\"* as \", path.call(print, \"exported\")]);\n\n    case \"ExportDefaultSpecifier\":\n      return path.call(print, \"exported\");\n\n    case \"Import\":\n      return lines_1.fromString(\"import\", options);\n    // Recast and ast-types currently support dynamic import(...) using\n    // either this dedicated ImportExpression type or a CallExpression\n    // whose callee has type Import.\n    // https://github.com/benjamn/ast-types/pull/365#issuecomment-605214486\n\n    case \"ImportExpression\":\n      return lines_1.concat([\"import(\", path.call(print, \"source\"), \")\"]);\n\n    case \"ImportDeclaration\":\n      {\n        parts.push(\"import \");\n\n        if (n.importKind && n.importKind !== \"value\") {\n          parts.push(n.importKind + \" \");\n        }\n\n        if (n.specifiers && n.specifiers.length > 0) {\n          var unbracedSpecifiers_1 = [];\n          var bracedSpecifiers_1 = [];\n          path.each(function (specifierPath) {\n            var spec = specifierPath.getValue();\n\n            if (spec.type === \"ImportSpecifier\") {\n              bracedSpecifiers_1.push(print(specifierPath));\n            } else if (spec.type === \"ImportDefaultSpecifier\" || spec.type === \"ImportNamespaceSpecifier\") {\n              unbracedSpecifiers_1.push(print(specifierPath));\n            }\n          }, \"specifiers\");\n          unbracedSpecifiers_1.forEach(function (lines, i) {\n            if (i > 0) {\n              parts.push(\", \");\n            }\n\n            parts.push(lines);\n          });\n\n          if (bracedSpecifiers_1.length > 0) {\n            var lines = lines_1.fromString(\", \").join(bracedSpecifiers_1);\n\n            if (lines.getLineLength(1) > options.wrapColumn) {\n              lines = lines_1.concat([lines_1.fromString(\",\\n\").join(bracedSpecifiers_1).indent(options.tabWidth), \",\"]);\n            }\n\n            if (unbracedSpecifiers_1.length > 0) {\n              parts.push(\", \");\n            }\n\n            if (lines.length > 1) {\n              parts.push(\"{\\n\", lines, \"\\n}\");\n            } else if (options.objectCurlySpacing) {\n              parts.push(\"{ \", lines, \" }\");\n            } else {\n              parts.push(\"{\", lines, \"}\");\n            }\n          }\n\n          parts.push(\" from \");\n        }\n\n        parts.push(path.call(print, \"source\"), \";\");\n        return lines_1.concat(parts);\n      }\n\n    case \"BlockStatement\":\n      {\n        var naked_1 = path.call(function (bodyPath) {\n          return printStatementSequence(bodyPath, options, print);\n        }, \"body\");\n\n        if (naked_1.isEmpty()) {\n          if (!n.directives || n.directives.length === 0) {\n            return lines_1.fromString(\"{}\");\n          }\n        }\n\n        parts.push(\"{\\n\"); // Babel 6\n\n        if (n.directives) {\n          path.each(function (childPath) {\n            parts.push(maybeAddSemicolon(print(childPath).indent(options.tabWidth)), n.directives.length > 1 || !naked_1.isEmpty() ? \"\\n\" : \"\");\n          }, \"directives\");\n        }\n\n        parts.push(naked_1.indent(options.tabWidth));\n        parts.push(\"\\n}\");\n        return lines_1.concat(parts);\n      }\n\n    case \"ReturnStatement\":\n      {\n        parts.push(\"return\");\n\n        if (n.argument) {\n          var argLines = path.call(print, \"argument\");\n\n          if (argLines.startsWithComment() || argLines.length > 1 && namedTypes.JSXElement && namedTypes.JSXElement.check(n.argument)) {\n            parts.push(\" (\\n\", argLines.indent(options.tabWidth), \"\\n)\");\n          } else {\n            parts.push(\" \", argLines);\n          }\n        }\n\n        parts.push(\";\");\n        return lines_1.concat(parts);\n      }\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n      parts.push(path.call(print, \"callee\"));\n\n      if (n.typeParameters) {\n        parts.push(path.call(print, \"typeParameters\"));\n      }\n\n      if (n.typeArguments) {\n        parts.push(path.call(print, \"typeArguments\"));\n      } // Like n.optional, but defaults to true for OptionalCallExpression\n      // nodes that are missing an n.optional property (unusual),\n      // according to the OptionalCallExpression definition in ast-types.\n\n\n      if (types.getFieldValue(n, \"optional\")) {\n        parts.push(\"?.\");\n      }\n\n      parts.push(printArgumentsList(path, options, print));\n      return lines_1.concat(parts);\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n    case \"ObjectTypeAnnotation\":\n      {\n        var isTypeAnnotation_1 = n.type === \"ObjectTypeAnnotation\";\n        var separator_1 = options.flowObjectCommas ? \",\" : isTypeAnnotation_1 ? \";\" : \",\";\n        var fields = [];\n        var allowBreak_1 = false;\n\n        if (isTypeAnnotation_1) {\n          fields.push(\"indexers\", \"callProperties\");\n\n          if (n.internalSlots != null) {\n            fields.push(\"internalSlots\");\n          }\n        }\n\n        fields.push(\"properties\");\n        var len_1 = 0;\n        fields.forEach(function (field) {\n          len_1 += n[field].length;\n        });\n        var oneLine_1 = isTypeAnnotation_1 && len_1 === 1 || len_1 === 0;\n        var leftBrace = n.exact ? \"{|\" : \"{\";\n        var rightBrace = n.exact ? \"|}\" : \"}\";\n        parts.push(oneLine_1 ? leftBrace : leftBrace + \"\\n\");\n        var leftBraceIndex = parts.length - 1;\n        var i_1 = 0;\n        fields.forEach(function (field) {\n          path.each(function (childPath) {\n            var lines = print(childPath);\n\n            if (!oneLine_1) {\n              lines = lines.indent(options.tabWidth);\n            }\n\n            var multiLine = !isTypeAnnotation_1 && lines.length > 1;\n\n            if (multiLine && allowBreak_1) {\n              // Similar to the logic for BlockStatement.\n              parts.push(\"\\n\");\n            }\n\n            parts.push(lines);\n\n            if (i_1 < len_1 - 1) {\n              // Add an extra line break if the previous object property\n              // had a multi-line value.\n              parts.push(separator_1 + (multiLine ? \"\\n\\n\" : \"\\n\"));\n              allowBreak_1 = !multiLine;\n            } else if (len_1 !== 1 && isTypeAnnotation_1) {\n              parts.push(separator_1);\n            } else if (!oneLine_1 && util.isTrailingCommaEnabled(options, \"objects\") && childPath.getValue().type !== \"RestElement\") {\n              parts.push(separator_1);\n            }\n\n            i_1++;\n          }, field);\n        });\n\n        if (n.inexact) {\n          var line = lines_1.fromString(\"...\", options);\n\n          if (oneLine_1) {\n            if (len_1 > 0) {\n              parts.push(separator_1, \" \");\n            }\n\n            parts.push(line);\n          } else {\n            // No trailing separator after ... to maintain parity with prettier.\n            parts.push(\"\\n\", line.indent(options.tabWidth));\n          }\n        }\n\n        parts.push(oneLine_1 ? rightBrace : \"\\n\" + rightBrace);\n\n        if (i_1 !== 0 && oneLine_1 && options.objectCurlySpacing) {\n          parts[leftBraceIndex] = leftBrace + \" \";\n          parts[parts.length - 1] = \" \" + rightBrace;\n        }\n\n        if (n.typeAnnotation) {\n          parts.push(path.call(print, \"typeAnnotation\"));\n        }\n\n        return lines_1.concat(parts);\n      }\n\n    case \"PropertyPattern\":\n      return lines_1.concat([path.call(print, \"key\"), \": \", path.call(print, \"pattern\")]);\n\n    case \"ObjectProperty\": // Babel 6\n\n    case \"Property\":\n      {\n        // Non-standard AST node type.\n        if (n.method || n.kind === \"get\" || n.kind === \"set\") {\n          return printMethod(path, options, print);\n        }\n\n        if (n.shorthand && n.value.type === \"AssignmentPattern\") {\n          return path.call(print, \"value\");\n        }\n\n        var key = path.call(print, \"key\");\n\n        if (n.computed) {\n          parts.push(\"[\", key, \"]\");\n        } else {\n          parts.push(key);\n        }\n\n        if (!n.shorthand || n.key.name !== n.value.name) {\n          parts.push(\": \", path.call(print, \"value\"));\n        }\n\n        return lines_1.concat(parts);\n      }\n\n    case \"ClassMethod\": // Babel 6\n\n    case \"ObjectMethod\": // Babel 6\n\n    case \"ClassPrivateMethod\":\n    case \"TSDeclareMethod\":\n      return printMethod(path, options, print);\n\n    case \"PrivateName\":\n      return lines_1.concat([\"#\", path.call(print, \"id\")]);\n\n    case \"Decorator\":\n      return lines_1.concat([\"@\", path.call(print, \"expression\")]);\n\n    case \"ArrayExpression\":\n    case \"ArrayPattern\":\n      {\n        var elems = n.elements;\n        var len_2 = elems.length;\n        var printed_1 = path.map(print, \"elements\");\n        var joined = lines_1.fromString(\", \").join(printed_1);\n        var oneLine_2 = joined.getLineLength(1) <= options.wrapColumn;\n\n        if (oneLine_2) {\n          if (options.arrayBracketSpacing) {\n            parts.push(\"[ \");\n          } else {\n            parts.push(\"[\");\n          }\n        } else {\n          parts.push(\"[\\n\");\n        }\n\n        path.each(function (elemPath) {\n          var i = elemPath.getName();\n          var elem = elemPath.getValue();\n\n          if (!elem) {\n            // If the array expression ends with a hole, that hole\n            // will be ignored by the interpreter, but if it ends with\n            // two (or more) holes, we need to write out two (or more)\n            // commas so that the resulting code is interpreted with\n            // both (all) of the holes.\n            parts.push(\",\");\n          } else {\n            var lines = printed_1[i];\n\n            if (oneLine_2) {\n              if (i > 0) parts.push(\" \");\n            } else {\n              lines = lines.indent(options.tabWidth);\n            }\n\n            parts.push(lines);\n            if (i < len_2 - 1 || !oneLine_2 && util.isTrailingCommaEnabled(options, \"arrays\")) parts.push(\",\");\n            if (!oneLine_2) parts.push(\"\\n\");\n          }\n        }, \"elements\");\n\n        if (oneLine_2 && options.arrayBracketSpacing) {\n          parts.push(\" ]\");\n        } else {\n          parts.push(\"]\");\n        }\n\n        if (n.typeAnnotation) {\n          parts.push(path.call(print, \"typeAnnotation\"));\n        }\n\n        return lines_1.concat(parts);\n      }\n\n    case \"SequenceExpression\":\n      return lines_1.fromString(\", \").join(path.map(print, \"expressions\"));\n\n    case \"ThisExpression\":\n      return lines_1.fromString(\"this\");\n\n    case \"Super\":\n      return lines_1.fromString(\"super\");\n\n    case \"NullLiteral\":\n      // Babel 6 Literal split\n      return lines_1.fromString(\"null\");\n\n    case \"RegExpLiteral\":\n      // Babel 6 Literal split\n      return lines_1.fromString(n.extra.raw);\n\n    case \"BigIntLiteral\":\n      // Babel 7 Literal split\n      return lines_1.fromString(n.value + \"n\");\n\n    case \"NumericLiteral\":\n      // Babel 6 Literal Split\n      // Keep original representation for numeric values not in base 10.\n      if (n.extra && typeof n.extra.raw === \"string\" && Number(n.extra.raw) === n.value) {\n        return lines_1.fromString(n.extra.raw, options);\n      }\n\n      return lines_1.fromString(n.value, options);\n\n    case \"BooleanLiteral\": // Babel 6 Literal split\n\n    case \"StringLiteral\": // Babel 6 Literal split\n\n    case \"Literal\":\n      // Numeric values may be in bases other than 10. Use their raw\n      // representation if equivalent.\n      if (typeof n.value === \"number\" && typeof n.raw === \"string\" && Number(n.raw) === n.value) {\n        return lines_1.fromString(n.raw, options);\n      }\n\n      if (typeof n.value !== \"string\") {\n        return lines_1.fromString(n.value, options);\n      }\n\n      return lines_1.fromString(nodeStr(n.value, options), options);\n\n    case \"Directive\":\n      // Babel 6\n      return path.call(print, \"value\");\n\n    case \"DirectiveLiteral\":\n      // Babel 6\n      return lines_1.fromString(nodeStr(n.value, options));\n\n    case \"InterpreterDirective\":\n      return lines_1.fromString(\"#!\" + n.value + \"\\n\", options);\n\n    case \"ModuleSpecifier\":\n      if (n.local) {\n        throw new Error(\"The ESTree ModuleSpecifier type should be abstract\");\n      } // The Esprima ModuleSpecifier type is just a string-valued\n      // Literal identifying the imported-from module.\n\n\n      return lines_1.fromString(nodeStr(n.value, options), options);\n\n    case \"UnaryExpression\":\n      parts.push(n.operator);\n      if (/[a-z]$/.test(n.operator)) parts.push(\" \");\n      parts.push(path.call(print, \"argument\"));\n      return lines_1.concat(parts);\n\n    case \"UpdateExpression\":\n      parts.push(path.call(print, \"argument\"), n.operator);\n      if (n.prefix) parts.reverse();\n      return lines_1.concat(parts);\n\n    case \"ConditionalExpression\":\n      return lines_1.concat([path.call(print, \"test\"), \" ? \", path.call(print, \"consequent\"), \" : \", path.call(print, \"alternate\")]);\n\n    case \"NewExpression\":\n      {\n        parts.push(\"new \", path.call(print, \"callee\"));\n\n        if (n.typeParameters) {\n          parts.push(path.call(print, \"typeParameters\"));\n        }\n\n        if (n.typeArguments) {\n          parts.push(path.call(print, \"typeArguments\"));\n        }\n\n        var args = n.arguments;\n\n        if (args) {\n          parts.push(printArgumentsList(path, options, print));\n        }\n\n        return lines_1.concat(parts);\n      }\n\n    case \"VariableDeclaration\":\n      {\n        if (n.declare) {\n          parts.push(\"declare \");\n        }\n\n        parts.push(n.kind, \" \");\n        var maxLen_1 = 0;\n        var printed = path.map(function (childPath) {\n          var lines = print(childPath);\n          maxLen_1 = Math.max(lines.length, maxLen_1);\n          return lines;\n        }, \"declarations\");\n\n        if (maxLen_1 === 1) {\n          parts.push(lines_1.fromString(\", \").join(printed));\n        } else if (printed.length > 1) {\n          parts.push(lines_1.fromString(\",\\n\").join(printed).indentTail(n.kind.length + 1));\n        } else {\n          parts.push(printed[0]);\n        } // We generally want to terminate all variable declarations with a\n        // semicolon, except when they are children of for loops.\n\n\n        var parentNode = path.getParentNode();\n\n        if (!namedTypes.ForStatement.check(parentNode) && !namedTypes.ForInStatement.check(parentNode) && !(namedTypes.ForOfStatement && namedTypes.ForOfStatement.check(parentNode)) && !(namedTypes.ForAwaitStatement && namedTypes.ForAwaitStatement.check(parentNode))) {\n          parts.push(\";\");\n        }\n\n        return lines_1.concat(parts);\n      }\n\n    case \"VariableDeclarator\":\n      return n.init ? lines_1.fromString(\" = \").join([path.call(print, \"id\"), path.call(print, \"init\")]) : path.call(print, \"id\");\n\n    case \"WithStatement\":\n      return lines_1.concat([\"with (\", path.call(print, \"object\"), \") \", path.call(print, \"body\")]);\n\n    case \"IfStatement\":\n      {\n        var con = adjustClause(path.call(print, \"consequent\"), options);\n        parts.push(\"if (\", path.call(print, \"test\"), \")\", con);\n        if (n.alternate) parts.push(endsWithBrace(con) ? \" else\" : \"\\nelse\", adjustClause(path.call(print, \"alternate\"), options));\n        return lines_1.concat(parts);\n      }\n\n    case \"ForStatement\":\n      {\n        // TODO Get the for (;;) case right.\n        var init = path.call(print, \"init\");\n        var sep = init.length > 1 ? \";\\n\" : \"; \";\n        var forParen = \"for (\";\n        var indented = lines_1.fromString(sep).join([init, path.call(print, \"test\"), path.call(print, \"update\")]).indentTail(forParen.length);\n        var head = lines_1.concat([forParen, indented, \")\"]);\n        var clause = adjustClause(path.call(print, \"body\"), options);\n        parts.push(head);\n\n        if (head.length > 1) {\n          parts.push(\"\\n\");\n          clause = clause.trimLeft();\n        }\n\n        parts.push(clause);\n        return lines_1.concat(parts);\n      }\n\n    case \"WhileStatement\":\n      return lines_1.concat([\"while (\", path.call(print, \"test\"), \")\", adjustClause(path.call(print, \"body\"), options)]);\n\n    case \"ForInStatement\":\n      // Note: esprima can't actually parse \"for each (\".\n      return lines_1.concat([n.each ? \"for each (\" : \"for (\", path.call(print, \"left\"), \" in \", path.call(print, \"right\"), \")\", adjustClause(path.call(print, \"body\"), options)]);\n\n    case \"ForOfStatement\":\n    case \"ForAwaitStatement\":\n      parts.push(\"for \");\n\n      if (n.await || n.type === \"ForAwaitStatement\") {\n        parts.push(\"await \");\n      }\n\n      parts.push(\"(\", path.call(print, \"left\"), \" of \", path.call(print, \"right\"), \")\", adjustClause(path.call(print, \"body\"), options));\n      return lines_1.concat(parts);\n\n    case \"DoWhileStatement\":\n      {\n        var doBody = lines_1.concat([\"do\", adjustClause(path.call(print, \"body\"), options)]);\n        parts.push(doBody);\n        if (endsWithBrace(doBody)) parts.push(\" while\");else parts.push(\"\\nwhile\");\n        parts.push(\" (\", path.call(print, \"test\"), \");\");\n        return lines_1.concat(parts);\n      }\n\n    case \"DoExpression\":\n      {\n        var statements = path.call(function (bodyPath) {\n          return printStatementSequence(bodyPath, options, print);\n        }, \"body\");\n        return lines_1.concat([\"do {\\n\", statements.indent(options.tabWidth), \"\\n}\"]);\n      }\n\n    case \"BreakStatement\":\n      parts.push(\"break\");\n      if (n.label) parts.push(\" \", path.call(print, \"label\"));\n      parts.push(\";\");\n      return lines_1.concat(parts);\n\n    case \"ContinueStatement\":\n      parts.push(\"continue\");\n      if (n.label) parts.push(\" \", path.call(print, \"label\"));\n      parts.push(\";\");\n      return lines_1.concat(parts);\n\n    case \"LabeledStatement\":\n      return lines_1.concat([path.call(print, \"label\"), \":\\n\", path.call(print, \"body\")]);\n\n    case \"TryStatement\":\n      parts.push(\"try \", path.call(print, \"block\"));\n\n      if (n.handler) {\n        parts.push(\" \", path.call(print, \"handler\"));\n      } else if (n.handlers) {\n        path.each(function (handlerPath) {\n          parts.push(\" \", print(handlerPath));\n        }, \"handlers\");\n      }\n\n      if (n.finalizer) {\n        parts.push(\" finally \", path.call(print, \"finalizer\"));\n      }\n\n      return lines_1.concat(parts);\n\n    case \"CatchClause\":\n      parts.push(\"catch \");\n\n      if (n.param) {\n        parts.push(\"(\", path.call(print, \"param\"));\n      }\n\n      if (n.guard) {\n        // Note: esprima does not recognize conditional catch clauses.\n        parts.push(\" if \", path.call(print, \"guard\"));\n      }\n\n      if (n.param) {\n        parts.push(\") \");\n      }\n\n      parts.push(path.call(print, \"body\"));\n      return lines_1.concat(parts);\n\n    case \"ThrowStatement\":\n      return lines_1.concat([\"throw \", path.call(print, \"argument\"), \";\"]);\n\n    case \"SwitchStatement\":\n      return lines_1.concat([\"switch (\", path.call(print, \"discriminant\"), \") {\\n\", lines_1.fromString(\"\\n\").join(path.map(print, \"cases\")), \"\\n}\"]);\n    // Note: ignoring n.lexical because it has no printing consequences.\n\n    case \"SwitchCase\":\n      if (n.test) parts.push(\"case \", path.call(print, \"test\"), \":\");else parts.push(\"default:\");\n\n      if (n.consequent.length > 0) {\n        parts.push(\"\\n\", path.call(function (consequentPath) {\n          return printStatementSequence(consequentPath, options, print);\n        }, \"consequent\").indent(options.tabWidth));\n      }\n\n      return lines_1.concat(parts);\n\n    case \"DebuggerStatement\":\n      return lines_1.fromString(\"debugger;\");\n    // JSX extensions below.\n\n    case \"JSXAttribute\":\n      parts.push(path.call(print, \"name\"));\n      if (n.value) parts.push(\"=\", path.call(print, \"value\"));\n      return lines_1.concat(parts);\n\n    case \"JSXIdentifier\":\n      return lines_1.fromString(n.name, options);\n\n    case \"JSXNamespacedName\":\n      return lines_1.fromString(\":\").join([path.call(print, \"namespace\"), path.call(print, \"name\")]);\n\n    case \"JSXMemberExpression\":\n      return lines_1.fromString(\".\").join([path.call(print, \"object\"), path.call(print, \"property\")]);\n\n    case \"JSXSpreadAttribute\":\n      return lines_1.concat([\"{...\", path.call(print, \"argument\"), \"}\"]);\n\n    case \"JSXSpreadChild\":\n      return lines_1.concat([\"{...\", path.call(print, \"expression\"), \"}\"]);\n\n    case \"JSXExpressionContainer\":\n      return lines_1.concat([\"{\", path.call(print, \"expression\"), \"}\"]);\n\n    case \"JSXElement\":\n    case \"JSXFragment\":\n      {\n        var openingPropName = \"opening\" + (n.type === \"JSXElement\" ? \"Element\" : \"Fragment\");\n        var closingPropName = \"closing\" + (n.type === \"JSXElement\" ? \"Element\" : \"Fragment\");\n        var openingLines = path.call(print, openingPropName);\n\n        if (n[openingPropName].selfClosing) {\n          assert_1.default.ok(!n[closingPropName], \"unexpected \" + closingPropName + \" element in self-closing \" + n.type);\n          return openingLines;\n        }\n\n        var childLines = lines_1.concat(path.map(function (childPath) {\n          var child = childPath.getValue();\n\n          if (namedTypes.Literal.check(child) && typeof child.value === \"string\") {\n            if (/\\S/.test(child.value)) {\n              return child.value.replace(/^\\s+|\\s+$/g, \"\");\n            } else if (/\\n/.test(child.value)) {\n              return \"\\n\";\n            }\n          }\n\n          return print(childPath);\n        }, \"children\")).indentTail(options.tabWidth);\n        var closingLines = path.call(print, closingPropName);\n        return lines_1.concat([openingLines, childLines, closingLines]);\n      }\n\n    case \"JSXOpeningElement\":\n      {\n        parts.push(\"<\", path.call(print, \"name\"));\n        var attrParts_1 = [];\n        path.each(function (attrPath) {\n          attrParts_1.push(\" \", print(attrPath));\n        }, \"attributes\");\n        var attrLines = lines_1.concat(attrParts_1);\n        var needLineWrap = attrLines.length > 1 || attrLines.getLineLength(1) > options.wrapColumn;\n\n        if (needLineWrap) {\n          attrParts_1.forEach(function (part, i) {\n            if (part === \" \") {\n              assert_1.default.strictEqual(i % 2, 0);\n              attrParts_1[i] = \"\\n\";\n            }\n          });\n          attrLines = lines_1.concat(attrParts_1).indentTail(options.tabWidth);\n        }\n\n        parts.push(attrLines, n.selfClosing ? \" />\" : \">\");\n        return lines_1.concat(parts);\n      }\n\n    case \"JSXClosingElement\":\n      return lines_1.concat([\"</\", path.call(print, \"name\"), \">\"]);\n\n    case \"JSXOpeningFragment\":\n      return lines_1.fromString(\"<>\");\n\n    case \"JSXClosingFragment\":\n      return lines_1.fromString(\"</>\");\n\n    case \"JSXText\":\n      return lines_1.fromString(n.value, options);\n\n    case \"JSXEmptyExpression\":\n      return lines_1.fromString(\"\");\n\n    case \"TypeAnnotatedIdentifier\":\n      return lines_1.concat([path.call(print, \"annotation\"), \" \", path.call(print, \"identifier\")]);\n\n    case \"ClassBody\":\n      if (n.body.length === 0) {\n        return lines_1.fromString(\"{}\");\n      }\n\n      return lines_1.concat([\"{\\n\", path.call(function (bodyPath) {\n        return printStatementSequence(bodyPath, options, print);\n      }, \"body\").indent(options.tabWidth), \"\\n}\"]);\n\n    case \"ClassPropertyDefinition\":\n      parts.push(\"static \", path.call(print, \"definition\"));\n      if (!namedTypes.MethodDefinition.check(n.definition)) parts.push(\";\");\n      return lines_1.concat(parts);\n\n    case \"ClassProperty\":\n      {\n        if (n.declare) {\n          parts.push(\"declare \");\n        }\n\n        var access = n.accessibility || n.access;\n\n        if (typeof access === \"string\") {\n          parts.push(access, \" \");\n        }\n\n        if (n.static) {\n          parts.push(\"static \");\n        }\n\n        if (n.abstract) {\n          parts.push(\"abstract \");\n        }\n\n        if (n.readonly) {\n          parts.push(\"readonly \");\n        }\n\n        var key = path.call(print, \"key\");\n\n        if (n.computed) {\n          key = lines_1.concat([\"[\", key, \"]\"]);\n        }\n\n        if (n.variance) {\n          key = lines_1.concat([printVariance(path, print), key]);\n        }\n\n        parts.push(key);\n\n        if (n.optional) {\n          parts.push(\"?\");\n        }\n\n        if (n.typeAnnotation) {\n          parts.push(path.call(print, \"typeAnnotation\"));\n        }\n\n        if (n.value) {\n          parts.push(\" = \", path.call(print, \"value\"));\n        }\n\n        parts.push(\";\");\n        return lines_1.concat(parts);\n      }\n\n    case \"ClassPrivateProperty\":\n      if (n.static) {\n        parts.push(\"static \");\n      }\n\n      parts.push(path.call(print, \"key\"));\n\n      if (n.typeAnnotation) {\n        parts.push(path.call(print, \"typeAnnotation\"));\n      }\n\n      if (n.value) {\n        parts.push(\" = \", path.call(print, \"value\"));\n      }\n\n      parts.push(\";\");\n      return lines_1.concat(parts);\n\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n      if (n.declare) {\n        parts.push(\"declare \");\n      }\n\n      if (n.abstract) {\n        parts.push(\"abstract \");\n      }\n\n      parts.push(\"class\");\n\n      if (n.id) {\n        parts.push(\" \", path.call(print, \"id\"));\n      }\n\n      if (n.typeParameters) {\n        parts.push(path.call(print, \"typeParameters\"));\n      }\n\n      if (n.superClass) {\n        parts.push(\" extends \", path.call(print, \"superClass\"), path.call(print, \"superTypeParameters\"));\n      }\n\n      if (n[\"implements\"] && n[\"implements\"].length > 0) {\n        parts.push(\" implements \", lines_1.fromString(\", \").join(path.map(print, \"implements\")));\n      }\n\n      parts.push(\" \", path.call(print, \"body\"));\n      return lines_1.concat(parts);\n\n    case \"TemplateElement\":\n      return lines_1.fromString(n.value.raw, options).lockIndentTail();\n\n    case \"TemplateLiteral\":\n      {\n        var expressions_1 = path.map(print, \"expressions\");\n        parts.push(\"`\");\n        path.each(function (childPath) {\n          var i = childPath.getName();\n          parts.push(print(childPath));\n\n          if (i < expressions_1.length) {\n            parts.push(\"${\", expressions_1[i], \"}\");\n          }\n        }, \"quasis\");\n        parts.push(\"`\");\n        return lines_1.concat(parts).lockIndentTail();\n      }\n\n    case \"TaggedTemplateExpression\":\n      return lines_1.concat([path.call(print, \"tag\"), path.call(print, \"quasi\")]);\n    // These types are unprintable because they serve as abstract\n    // supertypes for other (printable) types.\n\n    case \"Node\":\n    case \"Printable\":\n    case \"SourceLocation\":\n    case \"Position\":\n    case \"Statement\":\n    case \"Function\":\n    case \"Pattern\":\n    case \"Expression\":\n    case \"Declaration\":\n    case \"Specifier\":\n    case \"NamedSpecifier\":\n    case \"Comment\": // Supertype of Block and Line\n\n    case \"Flow\": // Supertype of all Flow AST node types\n\n    case \"FlowType\": // Supertype of all Flow types\n\n    case \"FlowPredicate\": // Supertype of InferredPredicate and DeclaredPredicate\n\n    case \"MemberTypeAnnotation\": // Flow\n\n    case \"Type\": // Flow\n\n    case \"TSHasOptionalTypeParameterInstantiation\":\n    case \"TSHasOptionalTypeParameters\":\n    case \"TSHasOptionalTypeAnnotation\":\n    case \"ChainElement\":\n      // Supertype of MemberExpression and CallExpression\n      throw new Error(\"unprintable type: \" + JSON.stringify(n.type));\n\n    case \"CommentBlock\": // Babel block comment.\n\n    case \"Block\":\n      // Esprima block comment.\n      return lines_1.concat([\"/*\", lines_1.fromString(n.value, options), \"*/\"]);\n\n    case \"CommentLine\": // Babel line comment.\n\n    case \"Line\":\n      // Esprima line comment.\n      return lines_1.concat([\"//\", lines_1.fromString(n.value, options)]);\n    // Type Annotations for Facebook Flow, typically stripped out or\n    // transformed away before printing.\n\n    case \"TypeAnnotation\":\n      if (n.typeAnnotation) {\n        if (n.typeAnnotation.type !== \"FunctionTypeAnnotation\") {\n          parts.push(\": \");\n        }\n\n        parts.push(path.call(print, \"typeAnnotation\"));\n        return lines_1.concat(parts);\n      }\n\n      return lines_1.fromString(\"\");\n\n    case \"ExistentialTypeParam\":\n    case \"ExistsTypeAnnotation\":\n      return lines_1.fromString(\"*\", options);\n\n    case \"EmptyTypeAnnotation\":\n      return lines_1.fromString(\"empty\", options);\n\n    case \"AnyTypeAnnotation\":\n      return lines_1.fromString(\"any\", options);\n\n    case \"MixedTypeAnnotation\":\n      return lines_1.fromString(\"mixed\", options);\n\n    case \"ArrayTypeAnnotation\":\n      return lines_1.concat([path.call(print, \"elementType\"), \"[]\"]);\n\n    case \"TupleTypeAnnotation\":\n      {\n        var printed_2 = path.map(print, \"types\");\n        var joined = lines_1.fromString(\", \").join(printed_2);\n        var oneLine_3 = joined.getLineLength(1) <= options.wrapColumn;\n\n        if (oneLine_3) {\n          if (options.arrayBracketSpacing) {\n            parts.push(\"[ \");\n          } else {\n            parts.push(\"[\");\n          }\n        } else {\n          parts.push(\"[\\n\");\n        }\n\n        path.each(function (elemPath) {\n          var i = elemPath.getName();\n          var elem = elemPath.getValue();\n\n          if (!elem) {\n            // If the array expression ends with a hole, that hole\n            // will be ignored by the interpreter, but if it ends with\n            // two (or more) holes, we need to write out two (or more)\n            // commas so that the resulting code is interpreted with\n            // both (all) of the holes.\n            parts.push(\",\");\n          } else {\n            var lines = printed_2[i];\n\n            if (oneLine_3) {\n              if (i > 0) parts.push(\" \");\n            } else {\n              lines = lines.indent(options.tabWidth);\n            }\n\n            parts.push(lines);\n            if (i < n.types.length - 1 || !oneLine_3 && util.isTrailingCommaEnabled(options, \"arrays\")) parts.push(\",\");\n            if (!oneLine_3) parts.push(\"\\n\");\n          }\n        }, \"types\");\n\n        if (oneLine_3 && options.arrayBracketSpacing) {\n          parts.push(\" ]\");\n        } else {\n          parts.push(\"]\");\n        }\n\n        return lines_1.concat(parts);\n      }\n\n    case \"BooleanTypeAnnotation\":\n      return lines_1.fromString(\"boolean\", options);\n\n    case \"BooleanLiteralTypeAnnotation\":\n      assert_1.default.strictEqual(typeof n.value, \"boolean\");\n      return lines_1.fromString(\"\" + n.value, options);\n\n    case \"InterfaceTypeAnnotation\":\n      parts.push(\"interface\");\n\n      if (n.extends && n.extends.length > 0) {\n        parts.push(\" extends \", lines_1.fromString(\", \").join(path.map(print, \"extends\")));\n      }\n\n      parts.push(\" \", path.call(print, \"body\"));\n      return lines_1.concat(parts);\n\n    case \"DeclareClass\":\n      return printFlowDeclaration(path, [\"class \", path.call(print, \"id\"), \" \", path.call(print, \"body\")]);\n\n    case \"DeclareFunction\":\n      return printFlowDeclaration(path, [\"function \", path.call(print, \"id\"), \";\"]);\n\n    case \"DeclareModule\":\n      return printFlowDeclaration(path, [\"module \", path.call(print, \"id\"), \" \", path.call(print, \"body\")]);\n\n    case \"DeclareModuleExports\":\n      return printFlowDeclaration(path, [\"module.exports\", path.call(print, \"typeAnnotation\")]);\n\n    case \"DeclareVariable\":\n      return printFlowDeclaration(path, [\"var \", path.call(print, \"id\"), \";\"]);\n\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n      return lines_1.concat([\"declare \", printExportDeclaration(path, options, print)]);\n\n    case \"EnumDeclaration\":\n      return lines_1.concat([\"enum \", path.call(print, \"id\"), path.call(print, \"body\")]);\n\n    case \"EnumBooleanBody\":\n    case \"EnumNumberBody\":\n    case \"EnumStringBody\":\n    case \"EnumSymbolBody\":\n      {\n        if (n.type === \"EnumSymbolBody\" || n.explicitType) {\n          parts.push(\" of \", // EnumBooleanBody => boolean, etc.\n          n.type.slice(4, -4).toLowerCase());\n        }\n\n        parts.push(\" {\\n\", lines_1.fromString(\"\\n\").join(path.map(print, \"members\")).indent(options.tabWidth), \"\\n}\");\n        return lines_1.concat(parts);\n      }\n\n    case \"EnumDefaultedMember\":\n      return lines_1.concat([path.call(print, \"id\"), \",\"]);\n\n    case \"EnumBooleanMember\":\n    case \"EnumNumberMember\":\n    case \"EnumStringMember\":\n      return lines_1.concat([path.call(print, \"id\"), \" = \", path.call(print, \"init\"), \",\"]);\n\n    case \"InferredPredicate\":\n      return lines_1.fromString(\"%checks\", options);\n\n    case \"DeclaredPredicate\":\n      return lines_1.concat([\"%checks(\", path.call(print, \"value\"), \")\"]);\n\n    case \"FunctionTypeAnnotation\":\n      {\n        // FunctionTypeAnnotation is ambiguous:\n        // declare function(a: B): void; OR\n        // const A: (a: B) => void;\n        var parent = path.getParentNode(0);\n        var isArrowFunctionTypeAnnotation = !(namedTypes.ObjectTypeCallProperty.check(parent) || namedTypes.ObjectTypeInternalSlot.check(parent) && parent.method || namedTypes.DeclareFunction.check(path.getParentNode(2)));\n        var needsColon = isArrowFunctionTypeAnnotation && !namedTypes.FunctionTypeParam.check(parent) && !namedTypes.TypeAlias.check(parent);\n\n        if (needsColon) {\n          parts.push(\": \");\n        }\n\n        var needsParens = n.params.length !== 1 || n.params[0].name;\n        parts.push(needsParens ? \"(\" : \"\", printFunctionParams(path, options, print), needsParens ? \")\" : \"\"); // The returnType is not wrapped in a TypeAnnotation, so the colon\n        // needs to be added separately.\n\n        if (n.returnType) {\n          parts.push(isArrowFunctionTypeAnnotation ? \" => \" : \": \", path.call(print, \"returnType\"));\n        }\n\n        return lines_1.concat(parts);\n      }\n\n    case \"FunctionTypeParam\":\n      {\n        var name = path.call(print, \"name\");\n        parts.push(name);\n\n        if (n.optional) {\n          parts.push(\"?\");\n        }\n\n        if (name.infos[0].line) {\n          parts.push(\": \");\n        }\n\n        parts.push(path.call(print, \"typeAnnotation\"));\n        return lines_1.concat(parts);\n      }\n\n    case \"GenericTypeAnnotation\":\n      return lines_1.concat([path.call(print, \"id\"), path.call(print, \"typeParameters\")]);\n\n    case \"DeclareInterface\":\n      parts.push(\"declare \");\n    // Fall through to InterfaceDeclaration...\n\n    case \"InterfaceDeclaration\":\n    case \"TSInterfaceDeclaration\":\n      if (n.declare) {\n        parts.push(\"declare \");\n      }\n\n      parts.push(\"interface \", path.call(print, \"id\"), path.call(print, \"typeParameters\"), \" \");\n\n      if (n[\"extends\"] && n[\"extends\"].length > 0) {\n        parts.push(\"extends \", lines_1.fromString(\", \").join(path.map(print, \"extends\")), \" \");\n      }\n\n      if (n.body) {\n        parts.push(path.call(print, \"body\"));\n      }\n\n      return lines_1.concat(parts);\n\n    case \"ClassImplements\":\n    case \"InterfaceExtends\":\n      return lines_1.concat([path.call(print, \"id\"), path.call(print, \"typeParameters\")]);\n\n    case \"IntersectionTypeAnnotation\":\n      return lines_1.fromString(\" & \").join(path.map(print, \"types\"));\n\n    case \"NullableTypeAnnotation\":\n      return lines_1.concat([\"?\", path.call(print, \"typeAnnotation\")]);\n\n    case \"NullLiteralTypeAnnotation\":\n      return lines_1.fromString(\"null\", options);\n\n    case \"ThisTypeAnnotation\":\n      return lines_1.fromString(\"this\", options);\n\n    case \"NumberTypeAnnotation\":\n      return lines_1.fromString(\"number\", options);\n\n    case \"ObjectTypeCallProperty\":\n      return path.call(print, \"value\");\n\n    case \"ObjectTypeIndexer\":\n      if (n.static) {\n        parts.push(\"static \");\n      }\n\n      parts.push(printVariance(path, print), \"[\");\n\n      if (n.id) {\n        parts.push(path.call(print, \"id\"), \": \");\n      }\n\n      parts.push(path.call(print, \"key\"), \"]: \", path.call(print, \"value\"));\n      return lines_1.concat(parts);\n\n    case \"ObjectTypeProperty\":\n      return lines_1.concat([printVariance(path, print), path.call(print, \"key\"), n.optional ? \"?\" : \"\", \": \", path.call(print, \"value\")]);\n\n    case \"ObjectTypeInternalSlot\":\n      return lines_1.concat([n.static ? \"static \" : \"\", \"[[\", path.call(print, \"id\"), \"]]\", n.optional ? \"?\" : \"\", n.value.type !== \"FunctionTypeAnnotation\" ? \": \" : \"\", path.call(print, \"value\")]);\n\n    case \"QualifiedTypeIdentifier\":\n      return lines_1.concat([path.call(print, \"qualification\"), \".\", path.call(print, \"id\")]);\n\n    case \"StringLiteralTypeAnnotation\":\n      return lines_1.fromString(nodeStr(n.value, options), options);\n\n    case \"NumberLiteralTypeAnnotation\":\n    case \"NumericLiteralTypeAnnotation\":\n      assert_1.default.strictEqual(typeof n.value, \"number\");\n      return lines_1.fromString(JSON.stringify(n.value), options);\n\n    case \"BigIntLiteralTypeAnnotation\":\n      return lines_1.fromString(n.raw, options);\n\n    case \"StringTypeAnnotation\":\n      return lines_1.fromString(\"string\", options);\n\n    case \"DeclareTypeAlias\":\n      parts.push(\"declare \");\n    // Fall through to TypeAlias...\n\n    case \"TypeAlias\":\n      return lines_1.concat([\"type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"), \" = \", path.call(print, \"right\"), \";\"]);\n\n    case \"DeclareOpaqueType\":\n      parts.push(\"declare \");\n    // Fall through to OpaqueType...\n\n    case \"OpaqueType\":\n      parts.push(\"opaque type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"));\n\n      if (n[\"supertype\"]) {\n        parts.push(\": \", path.call(print, \"supertype\"));\n      }\n\n      if (n[\"impltype\"]) {\n        parts.push(\" = \", path.call(print, \"impltype\"));\n      }\n\n      parts.push(\";\");\n      return lines_1.concat(parts);\n\n    case \"TypeCastExpression\":\n      return lines_1.concat([\"(\", path.call(print, \"expression\"), path.call(print, \"typeAnnotation\"), \")\"]);\n\n    case \"TypeParameterDeclaration\":\n    case \"TypeParameterInstantiation\":\n      return lines_1.concat([\"<\", lines_1.fromString(\", \").join(path.map(print, \"params\")), \">\"]);\n\n    case \"Variance\":\n      if (n.kind === \"plus\") {\n        return lines_1.fromString(\"+\");\n      }\n\n      if (n.kind === \"minus\") {\n        return lines_1.fromString(\"-\");\n      }\n\n      return lines_1.fromString(\"\");\n\n    case \"TypeParameter\":\n      if (n.variance) {\n        parts.push(printVariance(path, print));\n      }\n\n      parts.push(path.call(print, \"name\"));\n\n      if (n.bound) {\n        parts.push(path.call(print, \"bound\"));\n      }\n\n      if (n[\"default\"]) {\n        parts.push(\"=\", path.call(print, \"default\"));\n      }\n\n      return lines_1.concat(parts);\n\n    case \"TypeofTypeAnnotation\":\n      return lines_1.concat([lines_1.fromString(\"typeof \", options), path.call(print, \"argument\")]);\n\n    case \"UnionTypeAnnotation\":\n      return lines_1.fromString(\" | \").join(path.map(print, \"types\"));\n\n    case \"VoidTypeAnnotation\":\n      return lines_1.fromString(\"void\", options);\n\n    case \"NullTypeAnnotation\":\n      return lines_1.fromString(\"null\", options);\n\n    case \"SymbolTypeAnnotation\":\n      return lines_1.fromString(\"symbol\", options);\n\n    case \"BigIntTypeAnnotation\":\n      return lines_1.fromString(\"bigint\", options);\n    // Type Annotations for TypeScript (when using Babylon as parser)\n\n    case \"TSType\":\n      throw new Error(\"unprintable type: \" + JSON.stringify(n.type));\n\n    case \"TSNumberKeyword\":\n      return lines_1.fromString(\"number\", options);\n\n    case \"TSBigIntKeyword\":\n      return lines_1.fromString(\"bigint\", options);\n\n    case \"TSObjectKeyword\":\n      return lines_1.fromString(\"object\", options);\n\n    case \"TSBooleanKeyword\":\n      return lines_1.fromString(\"boolean\", options);\n\n    case \"TSStringKeyword\":\n      return lines_1.fromString(\"string\", options);\n\n    case \"TSSymbolKeyword\":\n      return lines_1.fromString(\"symbol\", options);\n\n    case \"TSAnyKeyword\":\n      return lines_1.fromString(\"any\", options);\n\n    case \"TSVoidKeyword\":\n      return lines_1.fromString(\"void\", options);\n\n    case \"TSThisType\":\n      return lines_1.fromString(\"this\", options);\n\n    case \"TSNullKeyword\":\n      return lines_1.fromString(\"null\", options);\n\n    case \"TSUndefinedKeyword\":\n      return lines_1.fromString(\"undefined\", options);\n\n    case \"TSUnknownKeyword\":\n      return lines_1.fromString(\"unknown\", options);\n\n    case \"TSNeverKeyword\":\n      return lines_1.fromString(\"never\", options);\n\n    case \"TSArrayType\":\n      return lines_1.concat([path.call(print, \"elementType\"), \"[]\"]);\n\n    case \"TSLiteralType\":\n      return path.call(print, \"literal\");\n\n    case \"TSUnionType\":\n      return lines_1.fromString(\" | \").join(path.map(print, \"types\"));\n\n    case \"TSIntersectionType\":\n      return lines_1.fromString(\" & \").join(path.map(print, \"types\"));\n\n    case \"TSConditionalType\":\n      parts.push(path.call(print, \"checkType\"), \" extends \", path.call(print, \"extendsType\"), \" ? \", path.call(print, \"trueType\"), \" : \", path.call(print, \"falseType\"));\n      return lines_1.concat(parts);\n\n    case \"TSInferType\":\n      parts.push(\"infer \", path.call(print, \"typeParameter\"));\n      return lines_1.concat(parts);\n\n    case \"TSParenthesizedType\":\n      return lines_1.concat([\"(\", path.call(print, \"typeAnnotation\"), \")\"]);\n\n    case \"TSFunctionType\":\n      return lines_1.concat([path.call(print, \"typeParameters\"), \"(\", printFunctionParams(path, options, print), \") => \", path.call(print, \"typeAnnotation\", \"typeAnnotation\")]);\n\n    case \"TSConstructorType\":\n      return lines_1.concat([\"new \", path.call(print, \"typeParameters\"), \"(\", printFunctionParams(path, options, print), \") => \", path.call(print, \"typeAnnotation\", \"typeAnnotation\")]);\n\n    case \"TSMappedType\":\n      {\n        parts.push(n.readonly ? \"readonly \" : \"\", \"[\", path.call(print, \"typeParameter\"), \"]\", n.optional ? \"?\" : \"\");\n\n        if (n.typeAnnotation) {\n          parts.push(\": \", path.call(print, \"typeAnnotation\"), \";\");\n        }\n\n        return lines_1.concat([\"{\\n\", lines_1.concat(parts).indent(options.tabWidth), \"\\n}\"]);\n      }\n\n    case \"TSTupleType\":\n      return lines_1.concat([\"[\", lines_1.fromString(\", \").join(path.map(print, \"elementTypes\")), \"]\"]);\n\n    case \"TSNamedTupleMember\":\n      parts.push(path.call(print, \"label\"));\n\n      if (n.optional) {\n        parts.push(\"?\");\n      }\n\n      parts.push(\": \", path.call(print, \"elementType\"));\n      return lines_1.concat(parts);\n\n    case \"TSRestType\":\n      return lines_1.concat([\"...\", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSOptionalType\":\n      return lines_1.concat([path.call(print, \"typeAnnotation\"), \"?\"]);\n\n    case \"TSIndexedAccessType\":\n      return lines_1.concat([path.call(print, \"objectType\"), \"[\", path.call(print, \"indexType\"), \"]\"]);\n\n    case \"TSTypeOperator\":\n      return lines_1.concat([path.call(print, \"operator\"), \" \", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSTypeLiteral\":\n      {\n        var memberLines = lines_1.fromString(\",\\n\").join(path.map(print, \"members\"));\n\n        if (memberLines.isEmpty()) {\n          return lines_1.fromString(\"{}\", options);\n        }\n\n        parts.push(\"{\\n\", memberLines.indent(options.tabWidth), \"\\n}\");\n        return lines_1.concat(parts);\n      }\n\n    case \"TSEnumMember\":\n      parts.push(path.call(print, \"id\"));\n\n      if (n.initializer) {\n        parts.push(\" = \", path.call(print, \"initializer\"));\n      }\n\n      return lines_1.concat(parts);\n\n    case \"TSTypeQuery\":\n      return lines_1.concat([\"typeof \", path.call(print, \"exprName\")]);\n\n    case \"TSParameterProperty\":\n      if (n.accessibility) {\n        parts.push(n.accessibility, \" \");\n      }\n\n      if (n.export) {\n        parts.push(\"export \");\n      }\n\n      if (n.static) {\n        parts.push(\"static \");\n      }\n\n      if (n.readonly) {\n        parts.push(\"readonly \");\n      }\n\n      parts.push(path.call(print, \"parameter\"));\n      return lines_1.concat(parts);\n\n    case \"TSTypeReference\":\n      return lines_1.concat([path.call(print, \"typeName\"), path.call(print, \"typeParameters\")]);\n\n    case \"TSQualifiedName\":\n      return lines_1.concat([path.call(print, \"left\"), \".\", path.call(print, \"right\")]);\n\n    case \"TSAsExpression\":\n      {\n        var expression = path.call(print, \"expression\");\n        parts.push(expression, lines_1.fromString(\" as \"), path.call(print, \"typeAnnotation\"));\n        return lines_1.concat(parts);\n      }\n\n    case \"TSNonNullExpression\":\n      return lines_1.concat([path.call(print, \"expression\"), \"!\"]);\n\n    case \"TSTypeAnnotation\":\n      return lines_1.concat([\": \", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSIndexSignature\":\n      return lines_1.concat([n.readonly ? \"readonly \" : \"\", \"[\", path.map(print, \"parameters\"), \"]\", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSPropertySignature\":\n      parts.push(printVariance(path, print), n.readonly ? \"readonly \" : \"\");\n\n      if (n.computed) {\n        parts.push(\"[\", path.call(print, \"key\"), \"]\");\n      } else {\n        parts.push(path.call(print, \"key\"));\n      }\n\n      parts.push(n.optional ? \"?\" : \"\", path.call(print, \"typeAnnotation\"));\n      return lines_1.concat(parts);\n\n    case \"TSMethodSignature\":\n      if (n.computed) {\n        parts.push(\"[\", path.call(print, \"key\"), \"]\");\n      } else {\n        parts.push(path.call(print, \"key\"));\n      }\n\n      if (n.optional) {\n        parts.push(\"?\");\n      }\n\n      parts.push(path.call(print, \"typeParameters\"), \"(\", printFunctionParams(path, options, print), \")\", path.call(print, \"typeAnnotation\"));\n      return lines_1.concat(parts);\n\n    case \"TSTypePredicate\":\n      if (n.asserts) {\n        parts.push(\"asserts \");\n      }\n\n      parts.push(path.call(print, \"parameterName\"));\n\n      if (n.typeAnnotation) {\n        parts.push(\" is \", path.call(print, \"typeAnnotation\", \"typeAnnotation\"));\n      }\n\n      return lines_1.concat(parts);\n\n    case \"TSCallSignatureDeclaration\":\n      return lines_1.concat([path.call(print, \"typeParameters\"), \"(\", printFunctionParams(path, options, print), \")\", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSConstructSignatureDeclaration\":\n      if (n.typeParameters) {\n        parts.push(\"new\", path.call(print, \"typeParameters\"));\n      } else {\n        parts.push(\"new \");\n      }\n\n      parts.push(\"(\", printFunctionParams(path, options, print), \")\", path.call(print, \"typeAnnotation\"));\n      return lines_1.concat(parts);\n\n    case \"TSTypeAliasDeclaration\":\n      return lines_1.concat([n.declare ? \"declare \" : \"\", \"type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"), \" = \", path.call(print, \"typeAnnotation\"), \";\"]);\n\n    case \"TSTypeParameter\":\n      {\n        parts.push(path.call(print, \"name\")); // ambiguous because of TSMappedType\n\n        var parent = path.getParentNode(0);\n        var isInMappedType = namedTypes.TSMappedType.check(parent);\n\n        if (n.constraint) {\n          parts.push(isInMappedType ? \" in \" : \" extends \", path.call(print, \"constraint\"));\n        }\n\n        if (n[\"default\"]) {\n          parts.push(\" = \", path.call(print, \"default\"));\n        }\n\n        return lines_1.concat(parts);\n      }\n\n    case \"TSTypeAssertion\":\n      {\n        parts.push(\"<\", path.call(print, \"typeAnnotation\"), \"> \", path.call(print, \"expression\"));\n        return lines_1.concat(parts);\n      }\n\n    case \"TSTypeParameterDeclaration\":\n    case \"TSTypeParameterInstantiation\":\n      return lines_1.concat([\"<\", lines_1.fromString(\", \").join(path.map(print, \"params\")), \">\"]);\n\n    case \"TSEnumDeclaration\":\n      {\n        parts.push(n.declare ? \"declare \" : \"\", n.const ? \"const \" : \"\", \"enum \", path.call(print, \"id\"));\n        var memberLines = lines_1.fromString(\",\\n\").join(path.map(print, \"members\"));\n\n        if (memberLines.isEmpty()) {\n          parts.push(\" {}\");\n        } else {\n          parts.push(\" {\\n\", memberLines.indent(options.tabWidth), \"\\n}\");\n        }\n\n        return lines_1.concat(parts);\n      }\n\n    case \"TSExpressionWithTypeArguments\":\n      return lines_1.concat([path.call(print, \"expression\"), path.call(print, \"typeParameters\")]);\n\n    case \"TSInterfaceBody\":\n      {\n        var lines = lines_1.fromString(\";\\n\").join(path.map(print, \"body\"));\n\n        if (lines.isEmpty()) {\n          return lines_1.fromString(\"{}\", options);\n        }\n\n        return lines_1.concat([\"{\\n\", lines.indent(options.tabWidth), \";\", \"\\n}\"]);\n      }\n\n    case \"TSImportType\":\n      parts.push(\"import(\", path.call(print, \"argument\"), \")\");\n\n      if (n.qualifier) {\n        parts.push(\".\", path.call(print, \"qualifier\"));\n      }\n\n      if (n.typeParameters) {\n        parts.push(path.call(print, \"typeParameters\"));\n      }\n\n      return lines_1.concat(parts);\n\n    case \"TSImportEqualsDeclaration\":\n      if (n.isExport) {\n        parts.push(\"export \");\n      }\n\n      parts.push(\"import \", path.call(print, \"id\"), \" = \", path.call(print, \"moduleReference\"));\n      return maybeAddSemicolon(lines_1.concat(parts));\n\n    case \"TSExternalModuleReference\":\n      return lines_1.concat([\"require(\", path.call(print, \"expression\"), \")\"]);\n\n    case \"TSModuleDeclaration\":\n      {\n        var parent = path.getParentNode();\n\n        if (parent.type === \"TSModuleDeclaration\") {\n          parts.push(\".\");\n        } else {\n          if (n.declare) {\n            parts.push(\"declare \");\n          }\n\n          if (!n.global) {\n            var isExternal = n.id.type === \"StringLiteral\" || n.id.type === \"Literal\" && typeof n.id.value === \"string\";\n\n            if (isExternal) {\n              parts.push(\"module \");\n            } else if (n.loc && n.loc.lines && n.id.loc) {\n              var prefix = n.loc.lines.sliceString(n.loc.start, n.id.loc.start); // These keywords are fundamentally ambiguous in the\n              // Babylon parser, and not reflected in the AST, so\n              // the best we can do is to match the original code,\n              // when possible.\n\n              if (prefix.indexOf(\"module\") >= 0) {\n                parts.push(\"module \");\n              } else {\n                parts.push(\"namespace \");\n              }\n            } else {\n              parts.push(\"namespace \");\n            }\n          }\n        }\n\n        parts.push(path.call(print, \"id\"));\n\n        if (n.body && n.body.type === \"TSModuleDeclaration\") {\n          parts.push(path.call(print, \"body\"));\n        } else if (n.body) {\n          var bodyLines = path.call(print, \"body\");\n\n          if (bodyLines.isEmpty()) {\n            parts.push(\" {}\");\n          } else {\n            parts.push(\" {\\n\", bodyLines.indent(options.tabWidth), \"\\n}\");\n          }\n        }\n\n        return lines_1.concat(parts);\n      }\n\n    case \"TSModuleBlock\":\n      return path.call(function (bodyPath) {\n        return printStatementSequence(bodyPath, options, print);\n      }, \"body\");\n    // Unhandled types below. If encountered, nodes of these types should\n    // be either left alone or desugared into AST types that are fully\n    // supported by the pretty-printer.\n\n    case \"ClassHeritage\": // TODO\n\n    case \"ComprehensionBlock\": // TODO\n\n    case \"ComprehensionExpression\": // TODO\n\n    case \"Glob\": // TODO\n\n    case \"GeneratorExpression\": // TODO\n\n    case \"LetStatement\": // TODO\n\n    case \"LetExpression\": // TODO\n\n    case \"GraphExpression\": // TODO\n\n    case \"GraphIndexExpression\": // TODO\n\n    case \"XMLDefaultDeclaration\":\n    case \"XMLAnyName\":\n    case \"XMLQualifiedIdentifier\":\n    case \"XMLFunctionQualifiedIdentifier\":\n    case \"XMLAttributeSelector\":\n    case \"XMLFilterExpression\":\n    case \"XML\":\n    case \"XMLElement\":\n    case \"XMLList\":\n    case \"XMLEscape\":\n    case \"XMLText\":\n    case \"XMLStartTag\":\n    case \"XMLEndTag\":\n    case \"XMLPointTag\":\n    case \"XMLName\":\n    case \"XMLAttribute\":\n    case \"XMLCdata\":\n    case \"XMLComment\":\n    case \"XMLProcessingInstruction\":\n    default:\n      debugger;\n      throw new Error(\"unknown type: \" + JSON.stringify(n.type));\n  }\n}\n\nfunction printDecorators(path, printPath) {\n  var parts = [];\n  var node = path.getValue();\n\n  if (node.decorators && node.decorators.length > 0 && // If the parent node is an export declaration, it will be\n  // responsible for printing node.decorators.\n  !util.getParentExportDeclaration(path)) {\n    path.each(function (decoratorPath) {\n      parts.push(printPath(decoratorPath), \"\\n\");\n    }, \"decorators\");\n  } else if (util.isExportDeclaration(node) && node.declaration && node.declaration.decorators) {\n    // Export declarations are responsible for printing any decorators\n    // that logically apply to node.declaration.\n    path.each(function (decoratorPath) {\n      parts.push(printPath(decoratorPath), \"\\n\");\n    }, \"declaration\", \"decorators\");\n  }\n\n  return lines_1.concat(parts);\n}\n\nfunction printStatementSequence(path, options, print) {\n  var filtered = [];\n  var sawComment = false;\n  var sawStatement = false;\n  path.each(function (stmtPath) {\n    var stmt = stmtPath.getValue(); // Just in case the AST has been modified to contain falsy\n    // \"statements,\" it's safer simply to skip them.\n\n    if (!stmt) {\n      return;\n    } // Skip printing EmptyStatement nodes to avoid leaving stray\n    // semicolons lying around.\n\n\n    if (stmt.type === \"EmptyStatement\" && !(stmt.comments && stmt.comments.length > 0)) {\n      return;\n    }\n\n    if (namedTypes.Comment.check(stmt)) {\n      // The pretty printer allows a dangling Comment node to act as\n      // a Statement when the Comment can't be attached to any other\n      // non-Comment node in the tree.\n      sawComment = true;\n    } else if (namedTypes.Statement.check(stmt)) {\n      sawStatement = true;\n    } else {\n      // When the pretty printer encounters a string instead of an\n      // AST node, it just prints the string. This behavior can be\n      // useful for fine-grained formatting decisions like inserting\n      // blank lines.\n      isString.assert(stmt);\n    } // We can't hang onto stmtPath outside of this function, because\n    // it's just a reference to a mutable FastPath object, so we have\n    // to go ahead and print it here.\n\n\n    filtered.push({\n      node: stmt,\n      printed: print(stmtPath)\n    });\n  });\n\n  if (sawComment) {\n    assert_1.default.strictEqual(sawStatement, false, \"Comments may appear as statements in otherwise empty statement \" + \"lists, but may not coexist with non-Comment nodes.\");\n  }\n\n  var prevTrailingSpace = null;\n  var len = filtered.length;\n  var parts = [];\n  filtered.forEach(function (info, i) {\n    var printed = info.printed;\n    var stmt = info.node;\n    var multiLine = printed.length > 1;\n    var notFirst = i > 0;\n    var notLast = i < len - 1;\n    var leadingSpace;\n    var trailingSpace;\n    var lines = stmt && stmt.loc && stmt.loc.lines;\n    var trueLoc = lines && options.reuseWhitespace && util.getTrueLoc(stmt, lines);\n\n    if (notFirst) {\n      if (trueLoc) {\n        var beforeStart = lines.skipSpaces(trueLoc.start, true);\n        var beforeStartLine = beforeStart ? beforeStart.line : 1;\n        var leadingGap = trueLoc.start.line - beforeStartLine;\n        leadingSpace = Array(leadingGap + 1).join(\"\\n\");\n      } else {\n        leadingSpace = multiLine ? \"\\n\\n\" : \"\\n\";\n      }\n    } else {\n      leadingSpace = \"\";\n    }\n\n    if (notLast) {\n      if (trueLoc) {\n        var afterEnd = lines.skipSpaces(trueLoc.end);\n        var afterEndLine = afterEnd ? afterEnd.line : lines.length;\n        var trailingGap = afterEndLine - trueLoc.end.line;\n        trailingSpace = Array(trailingGap + 1).join(\"\\n\");\n      } else {\n        trailingSpace = multiLine ? \"\\n\\n\" : \"\\n\";\n      }\n    } else {\n      trailingSpace = \"\";\n    }\n\n    parts.push(maxSpace(prevTrailingSpace, leadingSpace), printed);\n\n    if (notLast) {\n      prevTrailingSpace = trailingSpace;\n    } else if (trailingSpace) {\n      parts.push(trailingSpace);\n    }\n  });\n  return lines_1.concat(parts);\n}\n\nfunction maxSpace(s1, s2) {\n  if (!s1 && !s2) {\n    return lines_1.fromString(\"\");\n  }\n\n  if (!s1) {\n    return lines_1.fromString(s2);\n  }\n\n  if (!s2) {\n    return lines_1.fromString(s1);\n  }\n\n  var spaceLines1 = lines_1.fromString(s1);\n  var spaceLines2 = lines_1.fromString(s2);\n\n  if (spaceLines2.length > spaceLines1.length) {\n    return spaceLines2;\n  }\n\n  return spaceLines1;\n}\n\nfunction printMethod(path, options, print) {\n  var node = path.getNode();\n  var kind = node.kind;\n  var parts = [];\n  var nodeValue = node.value;\n\n  if (!namedTypes.FunctionExpression.check(nodeValue)) {\n    nodeValue = node;\n  }\n\n  var access = node.accessibility || node.access;\n\n  if (typeof access === \"string\") {\n    parts.push(access, \" \");\n  }\n\n  if (node.static) {\n    parts.push(\"static \");\n  }\n\n  if (node.abstract) {\n    parts.push(\"abstract \");\n  }\n\n  if (node.readonly) {\n    parts.push(\"readonly \");\n  }\n\n  if (nodeValue.async) {\n    parts.push(\"async \");\n  }\n\n  if (nodeValue.generator) {\n    parts.push(\"*\");\n  }\n\n  if (kind === \"get\" || kind === \"set\") {\n    parts.push(kind, \" \");\n  }\n\n  var key = path.call(print, \"key\");\n\n  if (node.computed) {\n    key = lines_1.concat([\"[\", key, \"]\"]);\n  }\n\n  parts.push(key);\n\n  if (node.optional) {\n    parts.push(\"?\");\n  }\n\n  if (node === nodeValue) {\n    parts.push(path.call(print, \"typeParameters\"), \"(\", printFunctionParams(path, options, print), \")\", path.call(print, \"returnType\"));\n\n    if (node.body) {\n      parts.push(\" \", path.call(print, \"body\"));\n    } else {\n      parts.push(\";\");\n    }\n  } else {\n    parts.push(path.call(print, \"value\", \"typeParameters\"), \"(\", path.call(function (valuePath) {\n      return printFunctionParams(valuePath, options, print);\n    }, \"value\"), \")\", path.call(print, \"value\", \"returnType\"));\n\n    if (nodeValue.body) {\n      parts.push(\" \", path.call(print, \"value\", \"body\"));\n    } else {\n      parts.push(\";\");\n    }\n  }\n\n  return lines_1.concat(parts);\n}\n\nfunction printArgumentsList(path, options, print) {\n  var printed = path.map(print, \"arguments\");\n  var trailingComma = util.isTrailingCommaEnabled(options, \"parameters\");\n  var joined = lines_1.fromString(\", \").join(printed);\n\n  if (joined.getLineLength(1) > options.wrapColumn) {\n    joined = lines_1.fromString(\",\\n\").join(printed);\n    return lines_1.concat([\"(\\n\", joined.indent(options.tabWidth), trailingComma ? \",\\n)\" : \"\\n)\"]);\n  }\n\n  return lines_1.concat([\"(\", joined, \")\"]);\n}\n\nfunction printFunctionParams(path, options, print) {\n  var fun = path.getValue();\n  var params;\n  var printed = [];\n\n  if (fun.params) {\n    params = fun.params;\n    printed = path.map(print, \"params\");\n  } else if (fun.parameters) {\n    params = fun.parameters;\n    printed = path.map(print, \"parameters\");\n  }\n\n  if (fun.defaults) {\n    path.each(function (defExprPath) {\n      var i = defExprPath.getName();\n      var p = printed[i];\n\n      if (p && defExprPath.getValue()) {\n        printed[i] = lines_1.concat([p, \" = \", print(defExprPath)]);\n      }\n    }, \"defaults\");\n  }\n\n  if (fun.rest) {\n    printed.push(lines_1.concat([\"...\", path.call(print, \"rest\")]));\n  }\n\n  var joined = lines_1.fromString(\", \").join(printed);\n\n  if (joined.length > 1 || joined.getLineLength(1) > options.wrapColumn) {\n    joined = lines_1.fromString(\",\\n\").join(printed);\n\n    if (util.isTrailingCommaEnabled(options, \"parameters\") && !fun.rest && params[params.length - 1].type !== \"RestElement\") {\n      joined = lines_1.concat([joined, \",\\n\"]);\n    } else {\n      joined = lines_1.concat([joined, \"\\n\"]);\n    }\n\n    return lines_1.concat([\"\\n\", joined.indent(options.tabWidth)]);\n  }\n\n  return joined;\n}\n\nfunction printExportDeclaration(path, options, print) {\n  var decl = path.getValue();\n  var parts = [\"export \"];\n\n  if (decl.exportKind && decl.exportKind === \"type\") {\n    if (!decl.declaration) {\n      parts.push(\"type \");\n    }\n  }\n\n  var shouldPrintSpaces = options.objectCurlySpacing;\n  namedTypes.Declaration.assert(decl);\n\n  if (decl[\"default\"] || decl.type === \"ExportDefaultDeclaration\") {\n    parts.push(\"default \");\n  }\n\n  if (decl.declaration) {\n    parts.push(path.call(print, \"declaration\"));\n  } else if (decl.specifiers) {\n    if (decl.specifiers.length === 1 && decl.specifiers[0].type === \"ExportBatchSpecifier\") {\n      parts.push(\"*\");\n    } else if (decl.specifiers.length === 0) {\n      parts.push(\"{}\");\n    } else if (decl.specifiers[0].type === \"ExportDefaultSpecifier\") {\n      var unbracedSpecifiers_2 = [];\n      var bracedSpecifiers_2 = [];\n      path.each(function (specifierPath) {\n        var spec = specifierPath.getValue();\n\n        if (spec.type === \"ExportDefaultSpecifier\") {\n          unbracedSpecifiers_2.push(print(specifierPath));\n        } else {\n          bracedSpecifiers_2.push(print(specifierPath));\n        }\n      }, \"specifiers\");\n      unbracedSpecifiers_2.forEach(function (lines, i) {\n        if (i > 0) {\n          parts.push(\", \");\n        }\n\n        parts.push(lines);\n      });\n\n      if (bracedSpecifiers_2.length > 0) {\n        var lines_2 = lines_1.fromString(\", \").join(bracedSpecifiers_2);\n\n        if (lines_2.getLineLength(1) > options.wrapColumn) {\n          lines_2 = lines_1.concat([lines_1.fromString(\",\\n\").join(bracedSpecifiers_2).indent(options.tabWidth), \",\"]);\n        }\n\n        if (unbracedSpecifiers_2.length > 0) {\n          parts.push(\", \");\n        }\n\n        if (lines_2.length > 1) {\n          parts.push(\"{\\n\", lines_2, \"\\n}\");\n        } else if (options.objectCurlySpacing) {\n          parts.push(\"{ \", lines_2, \" }\");\n        } else {\n          parts.push(\"{\", lines_2, \"}\");\n        }\n      }\n    } else {\n      parts.push(shouldPrintSpaces ? \"{ \" : \"{\", lines_1.fromString(\", \").join(path.map(print, \"specifiers\")), shouldPrintSpaces ? \" }\" : \"}\");\n    }\n\n    if (decl.source) {\n      parts.push(\" from \", path.call(print, \"source\"));\n    }\n  }\n\n  var lines = lines_1.concat(parts);\n\n  if (lastNonSpaceCharacter(lines) !== \";\" && !(decl.declaration && (decl.declaration.type === \"FunctionDeclaration\" || decl.declaration.type === \"ClassDeclaration\" || decl.declaration.type === \"TSModuleDeclaration\" || decl.declaration.type === \"TSInterfaceDeclaration\" || decl.declaration.type === \"TSEnumDeclaration\"))) {\n    lines = lines_1.concat([lines, \";\"]);\n  }\n\n  return lines;\n}\n\nfunction printFlowDeclaration(path, parts) {\n  var parentExportDecl = util.getParentExportDeclaration(path);\n\n  if (parentExportDecl) {\n    assert_1.default.strictEqual(parentExportDecl.type, \"DeclareExportDeclaration\");\n  } else {\n    // If the parent node has type DeclareExportDeclaration, then it\n    // will be responsible for printing the \"declare\" token. Otherwise\n    // it needs to be printed with this non-exported declaration node.\n    parts.unshift(\"declare \");\n  }\n\n  return lines_1.concat(parts);\n}\n\nfunction printVariance(path, print) {\n  return path.call(function (variancePath) {\n    var value = variancePath.getValue();\n\n    if (value) {\n      if (value === \"plus\") {\n        return lines_1.fromString(\"+\");\n      }\n\n      if (value === \"minus\") {\n        return lines_1.fromString(\"-\");\n      }\n\n      return print(variancePath);\n    }\n\n    return lines_1.fromString(\"\");\n  }, \"variance\");\n}\n\nfunction adjustClause(clause, options) {\n  if (clause.length > 1) return lines_1.concat([\" \", clause]);\n  return lines_1.concat([\"\\n\", maybeAddSemicolon(clause).indent(options.tabWidth)]);\n}\n\nfunction lastNonSpaceCharacter(lines) {\n  var pos = lines.lastPos();\n\n  do {\n    var ch = lines.charAt(pos);\n    if (/\\S/.test(ch)) return ch;\n  } while (lines.prevPos(pos));\n}\n\nfunction endsWithBrace(lines) {\n  return lastNonSpaceCharacter(lines) === \"}\";\n}\n\nfunction swapQuotes(str) {\n  return str.replace(/['\"]/g, function (m) {\n    return m === '\"' ? \"'\" : '\"';\n  });\n}\n\nfunction nodeStr(str, options) {\n  isString.assert(str);\n\n  switch (options.quote) {\n    case \"auto\":\n      {\n        var double = JSON.stringify(str);\n        var single = swapQuotes(JSON.stringify(swapQuotes(str)));\n        return double.length > single.length ? single : double;\n      }\n\n    case \"single\":\n      return swapQuotes(JSON.stringify(swapQuotes(str)));\n\n    case \"double\":\n    default:\n      return JSON.stringify(str);\n  }\n}\n\nfunction maybeAddSemicolon(lines) {\n  var eoc = lastNonSpaceCharacter(lines);\n  if (!eoc || \"\\n};\".indexOf(eoc) < 0) return lines_1.concat([lines, \";\"]);\n  return lines;\n}","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/github/react-snippy/node_modules/jscodeshift/node_modules/recast/lib/printer.js"],"names":["Object","defineProperty","exports","value","Printer","tslib_1","require","assert_1","__importDefault","comments_1","lines_1","options_1","patcher_1","types","__importStar","namedTypes","isString","builtInTypes","string","isObject","object","fast_path_1","util","PrintResult","code","sourceMap","default","ok","assert","map","PRp","prototype","warnedAboutToString","toString","console","warn","emptyPrintResult","config","explicitTabWidth","tabWidth","normalize","sourceFileName","makePrintFunctionWith","options","overrides","assign","path","print","includeComments","printComments","oldTabWidth","loc","getNode","lines","guessTabWidth","reprinter","getReprinter","genericPrint","avoidRootParens","ast","from","composeSourceMaps","inputSourceMap","getSourceMap","sourceMapName","sourceRoot","printGenerically","oldReuseWhitespace","reuseWhitespace","pr","printPath","node","getValue","parts","linesWithoutParens","genericPrintNoParens","isEmpty","shouldAddParens","extra","parenthesized","decoratorsLines","printDecorators","needsParens","push","unshift","concat","n","fromString","Printable","type","call","directives","each","childPath","interpreter","bodyPath","printStatementSequence","join","operator","property","optional","getFieldValue","computed","body","name","declare","async","generator","id","typeParameters","printFunctionParams","arrowParensAlways","params","length","rest","typeAnnotation","returnType","printMethod","delegate","argument","all","source","importKind","imported","local","exported","printExportDeclaration","maybeAddSemicolon","specifiers","unbracedSpecifiers_1","bracedSpecifiers_1","specifierPath","spec","forEach","i","getLineLength","wrapColumn","indent","objectCurlySpacing","naked_1","argLines","startsWithComment","JSXElement","check","typeArguments","printArgumentsList","isTypeAnnotation_1","separator_1","flowObjectCommas","fields","allowBreak_1","internalSlots","len_1","field","oneLine_1","leftBrace","exact","rightBrace","leftBraceIndex","i_1","multiLine","isTrailingCommaEnabled","inexact","line","method","kind","shorthand","key","elems","elements","len_2","printed_1","joined","oneLine_2","arrayBracketSpacing","elemPath","getName","elem","raw","Number","nodeStr","Error","test","prefix","reverse","args","arguments","maxLen_1","printed","Math","max","indentTail","parentNode","getParentNode","ForStatement","ForInStatement","ForOfStatement","ForAwaitStatement","init","con","adjustClause","alternate","endsWithBrace","sep","forParen","indented","head","clause","trimLeft","await","doBody","statements","label","handler","handlers","handlerPath","finalizer","param","guard","consequent","consequentPath","openingPropName","closingPropName","openingLines","selfClosing","childLines","child","Literal","replace","closingLines","attrParts_1","attrPath","attrLines","needLineWrap","part","strictEqual","MethodDefinition","definition","access","accessibility","static","abstract","readonly","variance","printVariance","superClass","lockIndentTail","expressions_1","JSON","stringify","printed_2","oneLine_3","extends","printFlowDeclaration","explicitType","slice","toLowerCase","parent","isArrowFunctionTypeAnnotation","ObjectTypeCallProperty","ObjectTypeInternalSlot","DeclareFunction","needsColon","FunctionTypeParam","TypeAlias","infos","bound","memberLines","initializer","export","expression","asserts","isInMappedType","TSMappedType","constraint","const","qualifier","isExport","global","isExternal","sliceString","start","indexOf","bodyLines","decorators","getParentExportDeclaration","decoratorPath","isExportDeclaration","declaration","filtered","sawComment","sawStatement","stmtPath","stmt","comments","Comment","Statement","prevTrailingSpace","len","info","notFirst","notLast","leadingSpace","trailingSpace","trueLoc","getTrueLoc","beforeStart","skipSpaces","beforeStartLine","leadingGap","Array","afterEnd","end","afterEndLine","trailingGap","maxSpace","s1","s2","spaceLines1","spaceLines2","nodeValue","FunctionExpression","valuePath","trailingComma","fun","parameters","defaults","defExprPath","p","decl","exportKind","shouldPrintSpaces","Declaration","unbracedSpecifiers_2","bracedSpecifiers_2","lines_2","lastNonSpaceCharacter","parentExportDecl","variancePath","pos","lastPos","ch","charAt","prevPos","swapQuotes","str","m","quote","double","single","eoc"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Printer = void 0;\nvar tslib_1 = require(\"tslib\");\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\nvar comments_1 = require(\"./comments\");\nvar lines_1 = require(\"./lines\");\nvar options_1 = require(\"./options\");\nvar patcher_1 = require(\"./patcher\");\nvar types = tslib_1.__importStar(require(\"ast-types\"));\nvar namedTypes = types.namedTypes;\nvar isString = types.builtInTypes.string;\nvar isObject = types.builtInTypes.object;\nvar fast_path_1 = tslib_1.__importDefault(require(\"./fast-path\"));\nvar util = tslib_1.__importStar(require(\"./util\"));\nvar PrintResult = function PrintResult(code, sourceMap) {\n    assert_1.default.ok(this instanceof PrintResult);\n    isString.assert(code);\n    this.code = code;\n    if (sourceMap) {\n        isObject.assert(sourceMap);\n        this.map = sourceMap;\n    }\n};\nvar PRp = PrintResult.prototype;\nvar warnedAboutToString = false;\nPRp.toString = function () {\n    if (!warnedAboutToString) {\n        console.warn(\"Deprecation warning: recast.print now returns an object with \" +\n            \"a .code property. You appear to be treating the object as a \" +\n            \"string, which might still work but is strongly discouraged.\");\n        warnedAboutToString = true;\n    }\n    return this.code;\n};\nvar emptyPrintResult = new PrintResult(\"\");\nvar Printer = function Printer(config) {\n    assert_1.default.ok(this instanceof Printer);\n    var explicitTabWidth = config && config.tabWidth;\n    config = options_1.normalize(config);\n    // It's common for client code to pass the same options into both\n    // recast.parse and recast.print, but the Printer doesn't need (and\n    // can be confused by) config.sourceFileName, so we null it out.\n    config.sourceFileName = null;\n    // Non-destructively modifies options with overrides, and returns a\n    // new print function that uses the modified options.\n    function makePrintFunctionWith(options, overrides) {\n        options = Object.assign({}, options, overrides);\n        return function (path) { return print(path, options); };\n    }\n    function print(path, options) {\n        assert_1.default.ok(path instanceof fast_path_1.default);\n        options = options || {};\n        if (options.includeComments) {\n            return comments_1.printComments(path, makePrintFunctionWith(options, {\n                includeComments: false,\n            }));\n        }\n        var oldTabWidth = config.tabWidth;\n        if (!explicitTabWidth) {\n            var loc = path.getNode().loc;\n            if (loc && loc.lines && loc.lines.guessTabWidth) {\n                config.tabWidth = loc.lines.guessTabWidth();\n            }\n        }\n        var reprinter = patcher_1.getReprinter(path);\n        var lines = reprinter\n            ? // Since the print function that we pass to the reprinter will\n                // be used to print \"new\" nodes, it's tempting to think we\n                // should pass printRootGenerically instead of print, to avoid\n                // calling maybeReprint again, but that would be a mistake\n                // because the new nodes might not be entirely new, but merely\n                // moved from elsewhere in the AST. The print function is the\n                // right choice because it gives us the opportunity to reprint\n                // such nodes using their original source.\n                reprinter(print)\n            : genericPrint(path, config, options, makePrintFunctionWith(options, {\n                includeComments: true,\n                avoidRootParens: false,\n            }));\n        config.tabWidth = oldTabWidth;\n        return lines;\n    }\n    this.print = function (ast) {\n        if (!ast) {\n            return emptyPrintResult;\n        }\n        var lines = print(fast_path_1.default.from(ast), {\n            includeComments: true,\n            avoidRootParens: false,\n        });\n        return new PrintResult(lines.toString(config), util.composeSourceMaps(config.inputSourceMap, lines.getSourceMap(config.sourceMapName, config.sourceRoot)));\n    };\n    this.printGenerically = function (ast) {\n        if (!ast) {\n            return emptyPrintResult;\n        }\n        // Print the entire AST generically.\n        function printGenerically(path) {\n            return comments_1.printComments(path, function (path) {\n                return genericPrint(path, config, {\n                    includeComments: true,\n                    avoidRootParens: false,\n                }, printGenerically);\n            });\n        }\n        var path = fast_path_1.default.from(ast);\n        var oldReuseWhitespace = config.reuseWhitespace;\n        // Do not reuse whitespace (or anything else, for that matter)\n        // when printing generically.\n        config.reuseWhitespace = false;\n        // TODO Allow printing of comments?\n        var pr = new PrintResult(printGenerically(path).toString(config));\n        config.reuseWhitespace = oldReuseWhitespace;\n        return pr;\n    };\n};\nexports.Printer = Printer;\nfunction genericPrint(path, config, options, printPath) {\n    assert_1.default.ok(path instanceof fast_path_1.default);\n    var node = path.getValue();\n    var parts = [];\n    var linesWithoutParens = genericPrintNoParens(path, config, printPath);\n    if (!node || linesWithoutParens.isEmpty()) {\n        return linesWithoutParens;\n    }\n    var shouldAddParens = node.extra ? node.extra.parenthesized : false;\n    var decoratorsLines = printDecorators(path, printPath);\n    if (decoratorsLines.isEmpty()) {\n        // Nodes with decorators can't have parentheses, so we can avoid\n        // computing path.needsParens() except in this case.\n        if (!options.avoidRootParens) {\n            shouldAddParens = shouldAddParens || path.needsParens();\n        }\n    }\n    else {\n        parts.push(decoratorsLines);\n    }\n    if (shouldAddParens) {\n        parts.unshift(\"(\");\n    }\n    parts.push(linesWithoutParens);\n    if (shouldAddParens) {\n        parts.push(\")\");\n    }\n    return lines_1.concat(parts);\n}\n// Note that the `options` parameter of this function is what other\n// functions in this file call the `config` object (that is, the\n// configuration object originally passed into the Printer constructor).\n// Its properties are documented in lib/options.js.\nfunction genericPrintNoParens(path, options, print) {\n    var n = path.getValue();\n    if (!n) {\n        return lines_1.fromString(\"\");\n    }\n    if (typeof n === \"string\") {\n        return lines_1.fromString(n, options);\n    }\n    namedTypes.Printable.assert(n);\n    var parts = [];\n    switch (n.type) {\n        case \"File\":\n            return path.call(print, \"program\");\n        case \"Program\":\n            // Babel 6\n            if (n.directives) {\n                path.each(function (childPath) {\n                    parts.push(print(childPath), \";\\n\");\n                }, \"directives\");\n            }\n            if (n.interpreter) {\n                parts.push(path.call(print, \"interpreter\"));\n            }\n            parts.push(path.call(function (bodyPath) { return printStatementSequence(bodyPath, options, print); }, \"body\"));\n            return lines_1.concat(parts);\n        case \"Noop\": // Babel extension.\n        case \"EmptyStatement\":\n            return lines_1.fromString(\"\");\n        case \"ExpressionStatement\":\n            return lines_1.concat([path.call(print, \"expression\"), \";\"]);\n        case \"ParenthesizedExpression\": // Babel extension.\n            return lines_1.concat([\"(\", path.call(print, \"expression\"), \")\"]);\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n        case \"AssignmentExpression\":\n            return lines_1.fromString(\" \").join([\n                path.call(print, \"left\"),\n                n.operator,\n                path.call(print, \"right\"),\n            ]);\n        case \"AssignmentPattern\":\n            return lines_1.concat([\n                path.call(print, \"left\"),\n                \" = \",\n                path.call(print, \"right\"),\n            ]);\n        case \"MemberExpression\":\n        case \"OptionalMemberExpression\": {\n            parts.push(path.call(print, \"object\"));\n            var property = path.call(print, \"property\");\n            // Like n.optional, except with defaults applied, so optional\n            // defaults to true for OptionalMemberExpression nodes.\n            var optional = types.getFieldValue(n, \"optional\");\n            if (n.computed) {\n                parts.push(optional ? \"?.[\" : \"[\", property, \"]\");\n            }\n            else {\n                parts.push(optional ? \"?.\" : \".\", property);\n            }\n            return lines_1.concat(parts);\n        }\n        case \"ChainExpression\":\n            return path.call(print, \"expression\");\n        case \"MetaProperty\":\n            return lines_1.concat([\n                path.call(print, \"meta\"),\n                \".\",\n                path.call(print, \"property\"),\n            ]);\n        case \"BindExpression\":\n            if (n.object) {\n                parts.push(path.call(print, \"object\"));\n            }\n            parts.push(\"::\", path.call(print, \"callee\"));\n            return lines_1.concat(parts);\n        case \"Path\":\n            return lines_1.fromString(\".\").join(n.body);\n        case \"Identifier\":\n            return lines_1.concat([\n                lines_1.fromString(n.name, options),\n                n.optional ? \"?\" : \"\",\n                path.call(print, \"typeAnnotation\"),\n            ]);\n        case \"SpreadElement\":\n        case \"SpreadElementPattern\":\n        case \"RestProperty\": // Babel 6 for ObjectPattern\n        case \"SpreadProperty\":\n        case \"SpreadPropertyPattern\":\n        case \"ObjectTypeSpreadProperty\":\n        case \"RestElement\":\n            return lines_1.concat([\n                \"...\",\n                path.call(print, \"argument\"),\n                path.call(print, \"typeAnnotation\"),\n            ]);\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"TSDeclareFunction\":\n            if (n.declare) {\n                parts.push(\"declare \");\n            }\n            if (n.async) {\n                parts.push(\"async \");\n            }\n            parts.push(\"function\");\n            if (n.generator)\n                parts.push(\"*\");\n            if (n.id) {\n                parts.push(\" \", path.call(print, \"id\"), path.call(print, \"typeParameters\"));\n            }\n            else {\n                if (n.typeParameters) {\n                    parts.push(path.call(print, \"typeParameters\"));\n                }\n            }\n            parts.push(\"(\", printFunctionParams(path, options, print), \")\", path.call(print, \"returnType\"));\n            if (n.body) {\n                parts.push(\" \", path.call(print, \"body\"));\n            }\n            return lines_1.concat(parts);\n        case \"ArrowFunctionExpression\":\n            if (n.async) {\n                parts.push(\"async \");\n            }\n            if (n.typeParameters) {\n                parts.push(path.call(print, \"typeParameters\"));\n            }\n            if (!options.arrowParensAlways &&\n                n.params.length === 1 &&\n                !n.rest &&\n                n.params[0].type === \"Identifier\" &&\n                !n.params[0].typeAnnotation &&\n                !n.returnType) {\n                parts.push(path.call(print, \"params\", 0));\n            }\n            else {\n                parts.push(\"(\", printFunctionParams(path, options, print), \")\", path.call(print, \"returnType\"));\n            }\n            parts.push(\" => \", path.call(print, \"body\"));\n            return lines_1.concat(parts);\n        case \"MethodDefinition\":\n            return printMethod(path, options, print);\n        case \"YieldExpression\":\n            parts.push(\"yield\");\n            if (n.delegate)\n                parts.push(\"*\");\n            if (n.argument)\n                parts.push(\" \", path.call(print, \"argument\"));\n            return lines_1.concat(parts);\n        case \"AwaitExpression\":\n            parts.push(\"await\");\n            if (n.all)\n                parts.push(\"*\");\n            if (n.argument)\n                parts.push(\" \", path.call(print, \"argument\"));\n            return lines_1.concat(parts);\n        case \"ModuleDeclaration\":\n            parts.push(\"module\", path.call(print, \"id\"));\n            if (n.source) {\n                assert_1.default.ok(!n.body);\n                parts.push(\"from\", path.call(print, \"source\"));\n            }\n            else {\n                parts.push(path.call(print, \"body\"));\n            }\n            return lines_1.fromString(\" \").join(parts);\n        case \"ImportSpecifier\":\n            if (n.importKind && n.importKind !== \"value\") {\n                parts.push(n.importKind + \" \");\n            }\n            if (n.imported) {\n                parts.push(path.call(print, \"imported\"));\n                if (n.local && n.local.name !== n.imported.name) {\n                    parts.push(\" as \", path.call(print, \"local\"));\n                }\n            }\n            else if (n.id) {\n                parts.push(path.call(print, \"id\"));\n                if (n.name) {\n                    parts.push(\" as \", path.call(print, \"name\"));\n                }\n            }\n            return lines_1.concat(parts);\n        case \"ExportSpecifier\":\n            if (n.local) {\n                parts.push(path.call(print, \"local\"));\n                if (n.exported && n.exported.name !== n.local.name) {\n                    parts.push(\" as \", path.call(print, \"exported\"));\n                }\n            }\n            else if (n.id) {\n                parts.push(path.call(print, \"id\"));\n                if (n.name) {\n                    parts.push(\" as \", path.call(print, \"name\"));\n                }\n            }\n            return lines_1.concat(parts);\n        case \"ExportBatchSpecifier\":\n            return lines_1.fromString(\"*\");\n        case \"ImportNamespaceSpecifier\":\n            parts.push(\"* as \");\n            if (n.local) {\n                parts.push(path.call(print, \"local\"));\n            }\n            else if (n.id) {\n                parts.push(path.call(print, \"id\"));\n            }\n            return lines_1.concat(parts);\n        case \"ImportDefaultSpecifier\":\n            if (n.local) {\n                return path.call(print, \"local\");\n            }\n            return path.call(print, \"id\");\n        case \"TSExportAssignment\":\n            return lines_1.concat([\"export = \", path.call(print, \"expression\")]);\n        case \"ExportDeclaration\":\n        case \"ExportDefaultDeclaration\":\n        case \"ExportNamedDeclaration\":\n            return printExportDeclaration(path, options, print);\n        case \"ExportAllDeclaration\":\n            parts.push(\"export *\");\n            if (n.exported) {\n                parts.push(\" as \", path.call(print, \"exported\"));\n            }\n            parts.push(\" from \", path.call(print, \"source\"), \";\");\n            return lines_1.concat(parts);\n        case \"TSNamespaceExportDeclaration\":\n            parts.push(\"export as namespace \", path.call(print, \"id\"));\n            return maybeAddSemicolon(lines_1.concat(parts));\n        case \"ExportNamespaceSpecifier\":\n            return lines_1.concat([\"* as \", path.call(print, \"exported\")]);\n        case \"ExportDefaultSpecifier\":\n            return path.call(print, \"exported\");\n        case \"Import\":\n            return lines_1.fromString(\"import\", options);\n        // Recast and ast-types currently support dynamic import(...) using\n        // either this dedicated ImportExpression type or a CallExpression\n        // whose callee has type Import.\n        // https://github.com/benjamn/ast-types/pull/365#issuecomment-605214486\n        case \"ImportExpression\":\n            return lines_1.concat([\"import(\", path.call(print, \"source\"), \")\"]);\n        case \"ImportDeclaration\": {\n            parts.push(\"import \");\n            if (n.importKind && n.importKind !== \"value\") {\n                parts.push(n.importKind + \" \");\n            }\n            if (n.specifiers && n.specifiers.length > 0) {\n                var unbracedSpecifiers_1 = [];\n                var bracedSpecifiers_1 = [];\n                path.each(function (specifierPath) {\n                    var spec = specifierPath.getValue();\n                    if (spec.type === \"ImportSpecifier\") {\n                        bracedSpecifiers_1.push(print(specifierPath));\n                    }\n                    else if (spec.type === \"ImportDefaultSpecifier\" ||\n                        spec.type === \"ImportNamespaceSpecifier\") {\n                        unbracedSpecifiers_1.push(print(specifierPath));\n                    }\n                }, \"specifiers\");\n                unbracedSpecifiers_1.forEach(function (lines, i) {\n                    if (i > 0) {\n                        parts.push(\", \");\n                    }\n                    parts.push(lines);\n                });\n                if (bracedSpecifiers_1.length > 0) {\n                    var lines = lines_1.fromString(\", \").join(bracedSpecifiers_1);\n                    if (lines.getLineLength(1) > options.wrapColumn) {\n                        lines = lines_1.concat([\n                            lines_1.fromString(\",\\n\").join(bracedSpecifiers_1).indent(options.tabWidth),\n                            \",\",\n                        ]);\n                    }\n                    if (unbracedSpecifiers_1.length > 0) {\n                        parts.push(\", \");\n                    }\n                    if (lines.length > 1) {\n                        parts.push(\"{\\n\", lines, \"\\n}\");\n                    }\n                    else if (options.objectCurlySpacing) {\n                        parts.push(\"{ \", lines, \" }\");\n                    }\n                    else {\n                        parts.push(\"{\", lines, \"}\");\n                    }\n                }\n                parts.push(\" from \");\n            }\n            parts.push(path.call(print, \"source\"), \";\");\n            return lines_1.concat(parts);\n        }\n        case \"BlockStatement\": {\n            var naked_1 = path.call(function (bodyPath) { return printStatementSequence(bodyPath, options, print); }, \"body\");\n            if (naked_1.isEmpty()) {\n                if (!n.directives || n.directives.length === 0) {\n                    return lines_1.fromString(\"{}\");\n                }\n            }\n            parts.push(\"{\\n\");\n            // Babel 6\n            if (n.directives) {\n                path.each(function (childPath) {\n                    parts.push(maybeAddSemicolon(print(childPath).indent(options.tabWidth)), n.directives.length > 1 || !naked_1.isEmpty() ? \"\\n\" : \"\");\n                }, \"directives\");\n            }\n            parts.push(naked_1.indent(options.tabWidth));\n            parts.push(\"\\n}\");\n            return lines_1.concat(parts);\n        }\n        case \"ReturnStatement\": {\n            parts.push(\"return\");\n            if (n.argument) {\n                var argLines = path.call(print, \"argument\");\n                if (argLines.startsWithComment() ||\n                    (argLines.length > 1 &&\n                        namedTypes.JSXElement &&\n                        namedTypes.JSXElement.check(n.argument))) {\n                    parts.push(\" (\\n\", argLines.indent(options.tabWidth), \"\\n)\");\n                }\n                else {\n                    parts.push(\" \", argLines);\n                }\n            }\n            parts.push(\";\");\n            return lines_1.concat(parts);\n        }\n        case \"CallExpression\":\n        case \"OptionalCallExpression\":\n            parts.push(path.call(print, \"callee\"));\n            if (n.typeParameters) {\n                parts.push(path.call(print, \"typeParameters\"));\n            }\n            if (n.typeArguments) {\n                parts.push(path.call(print, \"typeArguments\"));\n            }\n            // Like n.optional, but defaults to true for OptionalCallExpression\n            // nodes that are missing an n.optional property (unusual),\n            // according to the OptionalCallExpression definition in ast-types.\n            if (types.getFieldValue(n, \"optional\")) {\n                parts.push(\"?.\");\n            }\n            parts.push(printArgumentsList(path, options, print));\n            return lines_1.concat(parts);\n        case \"ObjectExpression\":\n        case \"ObjectPattern\":\n        case \"ObjectTypeAnnotation\": {\n            var isTypeAnnotation_1 = n.type === \"ObjectTypeAnnotation\";\n            var separator_1 = options.flowObjectCommas\n                ? \",\"\n                : isTypeAnnotation_1\n                    ? \";\"\n                    : \",\";\n            var fields = [];\n            var allowBreak_1 = false;\n            if (isTypeAnnotation_1) {\n                fields.push(\"indexers\", \"callProperties\");\n                if (n.internalSlots != null) {\n                    fields.push(\"internalSlots\");\n                }\n            }\n            fields.push(\"properties\");\n            var len_1 = 0;\n            fields.forEach(function (field) {\n                len_1 += n[field].length;\n            });\n            var oneLine_1 = (isTypeAnnotation_1 && len_1 === 1) || len_1 === 0;\n            var leftBrace = n.exact ? \"{|\" : \"{\";\n            var rightBrace = n.exact ? \"|}\" : \"}\";\n            parts.push(oneLine_1 ? leftBrace : leftBrace + \"\\n\");\n            var leftBraceIndex = parts.length - 1;\n            var i_1 = 0;\n            fields.forEach(function (field) {\n                path.each(function (childPath) {\n                    var lines = print(childPath);\n                    if (!oneLine_1) {\n                        lines = lines.indent(options.tabWidth);\n                    }\n                    var multiLine = !isTypeAnnotation_1 && lines.length > 1;\n                    if (multiLine && allowBreak_1) {\n                        // Similar to the logic for BlockStatement.\n                        parts.push(\"\\n\");\n                    }\n                    parts.push(lines);\n                    if (i_1 < len_1 - 1) {\n                        // Add an extra line break if the previous object property\n                        // had a multi-line value.\n                        parts.push(separator_1 + (multiLine ? \"\\n\\n\" : \"\\n\"));\n                        allowBreak_1 = !multiLine;\n                    }\n                    else if (len_1 !== 1 && isTypeAnnotation_1) {\n                        parts.push(separator_1);\n                    }\n                    else if (!oneLine_1 &&\n                        util.isTrailingCommaEnabled(options, \"objects\") &&\n                        childPath.getValue().type !== \"RestElement\") {\n                        parts.push(separator_1);\n                    }\n                    i_1++;\n                }, field);\n            });\n            if (n.inexact) {\n                var line = lines_1.fromString(\"...\", options);\n                if (oneLine_1) {\n                    if (len_1 > 0) {\n                        parts.push(separator_1, \" \");\n                    }\n                    parts.push(line);\n                }\n                else {\n                    // No trailing separator after ... to maintain parity with prettier.\n                    parts.push(\"\\n\", line.indent(options.tabWidth));\n                }\n            }\n            parts.push(oneLine_1 ? rightBrace : \"\\n\" + rightBrace);\n            if (i_1 !== 0 && oneLine_1 && options.objectCurlySpacing) {\n                parts[leftBraceIndex] = leftBrace + \" \";\n                parts[parts.length - 1] = \" \" + rightBrace;\n            }\n            if (n.typeAnnotation) {\n                parts.push(path.call(print, \"typeAnnotation\"));\n            }\n            return lines_1.concat(parts);\n        }\n        case \"PropertyPattern\":\n            return lines_1.concat([\n                path.call(print, \"key\"),\n                \": \",\n                path.call(print, \"pattern\"),\n            ]);\n        case \"ObjectProperty\": // Babel 6\n        case \"Property\": {\n            // Non-standard AST node type.\n            if (n.method || n.kind === \"get\" || n.kind === \"set\") {\n                return printMethod(path, options, print);\n            }\n            if (n.shorthand && n.value.type === \"AssignmentPattern\") {\n                return path.call(print, \"value\");\n            }\n            var key = path.call(print, \"key\");\n            if (n.computed) {\n                parts.push(\"[\", key, \"]\");\n            }\n            else {\n                parts.push(key);\n            }\n            if (!n.shorthand || n.key.name !== n.value.name) {\n                parts.push(\": \", path.call(print, \"value\"));\n            }\n            return lines_1.concat(parts);\n        }\n        case \"ClassMethod\": // Babel 6\n        case \"ObjectMethod\": // Babel 6\n        case \"ClassPrivateMethod\":\n        case \"TSDeclareMethod\":\n            return printMethod(path, options, print);\n        case \"PrivateName\":\n            return lines_1.concat([\"#\", path.call(print, \"id\")]);\n        case \"Decorator\":\n            return lines_1.concat([\"@\", path.call(print, \"expression\")]);\n        case \"ArrayExpression\":\n        case \"ArrayPattern\": {\n            var elems = n.elements;\n            var len_2 = elems.length;\n            var printed_1 = path.map(print, \"elements\");\n            var joined = lines_1.fromString(\", \").join(printed_1);\n            var oneLine_2 = joined.getLineLength(1) <= options.wrapColumn;\n            if (oneLine_2) {\n                if (options.arrayBracketSpacing) {\n                    parts.push(\"[ \");\n                }\n                else {\n                    parts.push(\"[\");\n                }\n            }\n            else {\n                parts.push(\"[\\n\");\n            }\n            path.each(function (elemPath) {\n                var i = elemPath.getName();\n                var elem = elemPath.getValue();\n                if (!elem) {\n                    // If the array expression ends with a hole, that hole\n                    // will be ignored by the interpreter, but if it ends with\n                    // two (or more) holes, we need to write out two (or more)\n                    // commas so that the resulting code is interpreted with\n                    // both (all) of the holes.\n                    parts.push(\",\");\n                }\n                else {\n                    var lines = printed_1[i];\n                    if (oneLine_2) {\n                        if (i > 0)\n                            parts.push(\" \");\n                    }\n                    else {\n                        lines = lines.indent(options.tabWidth);\n                    }\n                    parts.push(lines);\n                    if (i < len_2 - 1 ||\n                        (!oneLine_2 && util.isTrailingCommaEnabled(options, \"arrays\")))\n                        parts.push(\",\");\n                    if (!oneLine_2)\n                        parts.push(\"\\n\");\n                }\n            }, \"elements\");\n            if (oneLine_2 && options.arrayBracketSpacing) {\n                parts.push(\" ]\");\n            }\n            else {\n                parts.push(\"]\");\n            }\n            if (n.typeAnnotation) {\n                parts.push(path.call(print, \"typeAnnotation\"));\n            }\n            return lines_1.concat(parts);\n        }\n        case \"SequenceExpression\":\n            return lines_1.fromString(\", \").join(path.map(print, \"expressions\"));\n        case \"ThisExpression\":\n            return lines_1.fromString(\"this\");\n        case \"Super\":\n            return lines_1.fromString(\"super\");\n        case \"NullLiteral\": // Babel 6 Literal split\n            return lines_1.fromString(\"null\");\n        case \"RegExpLiteral\": // Babel 6 Literal split\n            return lines_1.fromString(n.extra.raw);\n        case \"BigIntLiteral\": // Babel 7 Literal split\n            return lines_1.fromString(n.value + \"n\");\n        case \"NumericLiteral\": // Babel 6 Literal Split\n            // Keep original representation for numeric values not in base 10.\n            if (n.extra &&\n                typeof n.extra.raw === \"string\" &&\n                Number(n.extra.raw) === n.value) {\n                return lines_1.fromString(n.extra.raw, options);\n            }\n            return lines_1.fromString(n.value, options);\n        case \"BooleanLiteral\": // Babel 6 Literal split\n        case \"StringLiteral\": // Babel 6 Literal split\n        case \"Literal\":\n            // Numeric values may be in bases other than 10. Use their raw\n            // representation if equivalent.\n            if (typeof n.value === \"number\" &&\n                typeof n.raw === \"string\" &&\n                Number(n.raw) === n.value) {\n                return lines_1.fromString(n.raw, options);\n            }\n            if (typeof n.value !== \"string\") {\n                return lines_1.fromString(n.value, options);\n            }\n            return lines_1.fromString(nodeStr(n.value, options), options);\n        case \"Directive\": // Babel 6\n            return path.call(print, \"value\");\n        case \"DirectiveLiteral\": // Babel 6\n            return lines_1.fromString(nodeStr(n.value, options));\n        case \"InterpreterDirective\":\n            return lines_1.fromString(\"#!\" + n.value + \"\\n\", options);\n        case \"ModuleSpecifier\":\n            if (n.local) {\n                throw new Error(\"The ESTree ModuleSpecifier type should be abstract\");\n            }\n            // The Esprima ModuleSpecifier type is just a string-valued\n            // Literal identifying the imported-from module.\n            return lines_1.fromString(nodeStr(n.value, options), options);\n        case \"UnaryExpression\":\n            parts.push(n.operator);\n            if (/[a-z]$/.test(n.operator))\n                parts.push(\" \");\n            parts.push(path.call(print, \"argument\"));\n            return lines_1.concat(parts);\n        case \"UpdateExpression\":\n            parts.push(path.call(print, \"argument\"), n.operator);\n            if (n.prefix)\n                parts.reverse();\n            return lines_1.concat(parts);\n        case \"ConditionalExpression\":\n            return lines_1.concat([\n                path.call(print, \"test\"),\n                \" ? \",\n                path.call(print, \"consequent\"),\n                \" : \",\n                path.call(print, \"alternate\"),\n            ]);\n        case \"NewExpression\": {\n            parts.push(\"new \", path.call(print, \"callee\"));\n            if (n.typeParameters) {\n                parts.push(path.call(print, \"typeParameters\"));\n            }\n            if (n.typeArguments) {\n                parts.push(path.call(print, \"typeArguments\"));\n            }\n            var args = n.arguments;\n            if (args) {\n                parts.push(printArgumentsList(path, options, print));\n            }\n            return lines_1.concat(parts);\n        }\n        case \"VariableDeclaration\": {\n            if (n.declare) {\n                parts.push(\"declare \");\n            }\n            parts.push(n.kind, \" \");\n            var maxLen_1 = 0;\n            var printed = path.map(function (childPath) {\n                var lines = print(childPath);\n                maxLen_1 = Math.max(lines.length, maxLen_1);\n                return lines;\n            }, \"declarations\");\n            if (maxLen_1 === 1) {\n                parts.push(lines_1.fromString(\", \").join(printed));\n            }\n            else if (printed.length > 1) {\n                parts.push(lines_1.fromString(\",\\n\")\n                    .join(printed)\n                    .indentTail(n.kind.length + 1));\n            }\n            else {\n                parts.push(printed[0]);\n            }\n            // We generally want to terminate all variable declarations with a\n            // semicolon, except when they are children of for loops.\n            var parentNode = path.getParentNode();\n            if (!namedTypes.ForStatement.check(parentNode) &&\n                !namedTypes.ForInStatement.check(parentNode) &&\n                !(namedTypes.ForOfStatement &&\n                    namedTypes.ForOfStatement.check(parentNode)) &&\n                !(namedTypes.ForAwaitStatement &&\n                    namedTypes.ForAwaitStatement.check(parentNode))) {\n                parts.push(\";\");\n            }\n            return lines_1.concat(parts);\n        }\n        case \"VariableDeclarator\":\n            return n.init\n                ? lines_1.fromString(\" = \").join([\n                    path.call(print, \"id\"),\n                    path.call(print, \"init\"),\n                ])\n                : path.call(print, \"id\");\n        case \"WithStatement\":\n            return lines_1.concat([\n                \"with (\",\n                path.call(print, \"object\"),\n                \") \",\n                path.call(print, \"body\"),\n            ]);\n        case \"IfStatement\": {\n            var con = adjustClause(path.call(print, \"consequent\"), options);\n            parts.push(\"if (\", path.call(print, \"test\"), \")\", con);\n            if (n.alternate)\n                parts.push(endsWithBrace(con) ? \" else\" : \"\\nelse\", adjustClause(path.call(print, \"alternate\"), options));\n            return lines_1.concat(parts);\n        }\n        case \"ForStatement\": {\n            // TODO Get the for (;;) case right.\n            var init = path.call(print, \"init\");\n            var sep = init.length > 1 ? \";\\n\" : \"; \";\n            var forParen = \"for (\";\n            var indented = lines_1.fromString(sep)\n                .join([init, path.call(print, \"test\"), path.call(print, \"update\")])\n                .indentTail(forParen.length);\n            var head = lines_1.concat([forParen, indented, \")\"]);\n            var clause = adjustClause(path.call(print, \"body\"), options);\n            parts.push(head);\n            if (head.length > 1) {\n                parts.push(\"\\n\");\n                clause = clause.trimLeft();\n            }\n            parts.push(clause);\n            return lines_1.concat(parts);\n        }\n        case \"WhileStatement\":\n            return lines_1.concat([\n                \"while (\",\n                path.call(print, \"test\"),\n                \")\",\n                adjustClause(path.call(print, \"body\"), options),\n            ]);\n        case \"ForInStatement\":\n            // Note: esprima can't actually parse \"for each (\".\n            return lines_1.concat([\n                n.each ? \"for each (\" : \"for (\",\n                path.call(print, \"left\"),\n                \" in \",\n                path.call(print, \"right\"),\n                \")\",\n                adjustClause(path.call(print, \"body\"), options),\n            ]);\n        case \"ForOfStatement\":\n        case \"ForAwaitStatement\":\n            parts.push(\"for \");\n            if (n.await || n.type === \"ForAwaitStatement\") {\n                parts.push(\"await \");\n            }\n            parts.push(\"(\", path.call(print, \"left\"), \" of \", path.call(print, \"right\"), \")\", adjustClause(path.call(print, \"body\"), options));\n            return lines_1.concat(parts);\n        case \"DoWhileStatement\": {\n            var doBody = lines_1.concat([\n                \"do\",\n                adjustClause(path.call(print, \"body\"), options),\n            ]);\n            parts.push(doBody);\n            if (endsWithBrace(doBody))\n                parts.push(\" while\");\n            else\n                parts.push(\"\\nwhile\");\n            parts.push(\" (\", path.call(print, \"test\"), \");\");\n            return lines_1.concat(parts);\n        }\n        case \"DoExpression\": {\n            var statements = path.call(function (bodyPath) { return printStatementSequence(bodyPath, options, print); }, \"body\");\n            return lines_1.concat([\"do {\\n\", statements.indent(options.tabWidth), \"\\n}\"]);\n        }\n        case \"BreakStatement\":\n            parts.push(\"break\");\n            if (n.label)\n                parts.push(\" \", path.call(print, \"label\"));\n            parts.push(\";\");\n            return lines_1.concat(parts);\n        case \"ContinueStatement\":\n            parts.push(\"continue\");\n            if (n.label)\n                parts.push(\" \", path.call(print, \"label\"));\n            parts.push(\";\");\n            return lines_1.concat(parts);\n        case \"LabeledStatement\":\n            return lines_1.concat([\n                path.call(print, \"label\"),\n                \":\\n\",\n                path.call(print, \"body\"),\n            ]);\n        case \"TryStatement\":\n            parts.push(\"try \", path.call(print, \"block\"));\n            if (n.handler) {\n                parts.push(\" \", path.call(print, \"handler\"));\n            }\n            else if (n.handlers) {\n                path.each(function (handlerPath) {\n                    parts.push(\" \", print(handlerPath));\n                }, \"handlers\");\n            }\n            if (n.finalizer) {\n                parts.push(\" finally \", path.call(print, \"finalizer\"));\n            }\n            return lines_1.concat(parts);\n        case \"CatchClause\":\n            parts.push(\"catch \");\n            if (n.param) {\n                parts.push(\"(\", path.call(print, \"param\"));\n            }\n            if (n.guard) {\n                // Note: esprima does not recognize conditional catch clauses.\n                parts.push(\" if \", path.call(print, \"guard\"));\n            }\n            if (n.param) {\n                parts.push(\") \");\n            }\n            parts.push(path.call(print, \"body\"));\n            return lines_1.concat(parts);\n        case \"ThrowStatement\":\n            return lines_1.concat([\"throw \", path.call(print, \"argument\"), \";\"]);\n        case \"SwitchStatement\":\n            return lines_1.concat([\n                \"switch (\",\n                path.call(print, \"discriminant\"),\n                \") {\\n\",\n                lines_1.fromString(\"\\n\").join(path.map(print, \"cases\")),\n                \"\\n}\",\n            ]);\n        // Note: ignoring n.lexical because it has no printing consequences.\n        case \"SwitchCase\":\n            if (n.test)\n                parts.push(\"case \", path.call(print, \"test\"), \":\");\n            else\n                parts.push(\"default:\");\n            if (n.consequent.length > 0) {\n                parts.push(\"\\n\", path\n                    .call(function (consequentPath) {\n                    return printStatementSequence(consequentPath, options, print);\n                }, \"consequent\")\n                    .indent(options.tabWidth));\n            }\n            return lines_1.concat(parts);\n        case \"DebuggerStatement\":\n            return lines_1.fromString(\"debugger;\");\n        // JSX extensions below.\n        case \"JSXAttribute\":\n            parts.push(path.call(print, \"name\"));\n            if (n.value)\n                parts.push(\"=\", path.call(print, \"value\"));\n            return lines_1.concat(parts);\n        case \"JSXIdentifier\":\n            return lines_1.fromString(n.name, options);\n        case \"JSXNamespacedName\":\n            return lines_1.fromString(\":\").join([\n                path.call(print, \"namespace\"),\n                path.call(print, \"name\"),\n            ]);\n        case \"JSXMemberExpression\":\n            return lines_1.fromString(\".\").join([\n                path.call(print, \"object\"),\n                path.call(print, \"property\"),\n            ]);\n        case \"JSXSpreadAttribute\":\n            return lines_1.concat([\"{...\", path.call(print, \"argument\"), \"}\"]);\n        case \"JSXSpreadChild\":\n            return lines_1.concat([\"{...\", path.call(print, \"expression\"), \"}\"]);\n        case \"JSXExpressionContainer\":\n            return lines_1.concat([\"{\", path.call(print, \"expression\"), \"}\"]);\n        case \"JSXElement\":\n        case \"JSXFragment\": {\n            var openingPropName = \"opening\" + (n.type === \"JSXElement\" ? \"Element\" : \"Fragment\");\n            var closingPropName = \"closing\" + (n.type === \"JSXElement\" ? \"Element\" : \"Fragment\");\n            var openingLines = path.call(print, openingPropName);\n            if (n[openingPropName].selfClosing) {\n                assert_1.default.ok(!n[closingPropName], \"unexpected \" +\n                    closingPropName +\n                    \" element in self-closing \" +\n                    n.type);\n                return openingLines;\n            }\n            var childLines = lines_1.concat(path.map(function (childPath) {\n                var child = childPath.getValue();\n                if (namedTypes.Literal.check(child) &&\n                    typeof child.value === \"string\") {\n                    if (/\\S/.test(child.value)) {\n                        return child.value.replace(/^\\s+|\\s+$/g, \"\");\n                    }\n                    else if (/\\n/.test(child.value)) {\n                        return \"\\n\";\n                    }\n                }\n                return print(childPath);\n            }, \"children\")).indentTail(options.tabWidth);\n            var closingLines = path.call(print, closingPropName);\n            return lines_1.concat([openingLines, childLines, closingLines]);\n        }\n        case \"JSXOpeningElement\": {\n            parts.push(\"<\", path.call(print, \"name\"));\n            var attrParts_1 = [];\n            path.each(function (attrPath) {\n                attrParts_1.push(\" \", print(attrPath));\n            }, \"attributes\");\n            var attrLines = lines_1.concat(attrParts_1);\n            var needLineWrap = attrLines.length > 1 || attrLines.getLineLength(1) > options.wrapColumn;\n            if (needLineWrap) {\n                attrParts_1.forEach(function (part, i) {\n                    if (part === \" \") {\n                        assert_1.default.strictEqual(i % 2, 0);\n                        attrParts_1[i] = \"\\n\";\n                    }\n                });\n                attrLines = lines_1.concat(attrParts_1).indentTail(options.tabWidth);\n            }\n            parts.push(attrLines, n.selfClosing ? \" />\" : \">\");\n            return lines_1.concat(parts);\n        }\n        case \"JSXClosingElement\":\n            return lines_1.concat([\"</\", path.call(print, \"name\"), \">\"]);\n        case \"JSXOpeningFragment\":\n            return lines_1.fromString(\"<>\");\n        case \"JSXClosingFragment\":\n            return lines_1.fromString(\"</>\");\n        case \"JSXText\":\n            return lines_1.fromString(n.value, options);\n        case \"JSXEmptyExpression\":\n            return lines_1.fromString(\"\");\n        case \"TypeAnnotatedIdentifier\":\n            return lines_1.concat([\n                path.call(print, \"annotation\"),\n                \" \",\n                path.call(print, \"identifier\"),\n            ]);\n        case \"ClassBody\":\n            if (n.body.length === 0) {\n                return lines_1.fromString(\"{}\");\n            }\n            return lines_1.concat([\n                \"{\\n\",\n                path\n                    .call(function (bodyPath) { return printStatementSequence(bodyPath, options, print); }, \"body\")\n                    .indent(options.tabWidth),\n                \"\\n}\",\n            ]);\n        case \"ClassPropertyDefinition\":\n            parts.push(\"static \", path.call(print, \"definition\"));\n            if (!namedTypes.MethodDefinition.check(n.definition))\n                parts.push(\";\");\n            return lines_1.concat(parts);\n        case \"ClassProperty\": {\n            if (n.declare) {\n                parts.push(\"declare \");\n            }\n            var access = n.accessibility || n.access;\n            if (typeof access === \"string\") {\n                parts.push(access, \" \");\n            }\n            if (n.static) {\n                parts.push(\"static \");\n            }\n            if (n.abstract) {\n                parts.push(\"abstract \");\n            }\n            if (n.readonly) {\n                parts.push(\"readonly \");\n            }\n            var key = path.call(print, \"key\");\n            if (n.computed) {\n                key = lines_1.concat([\"[\", key, \"]\"]);\n            }\n            if (n.variance) {\n                key = lines_1.concat([printVariance(path, print), key]);\n            }\n            parts.push(key);\n            if (n.optional) {\n                parts.push(\"?\");\n            }\n            if (n.typeAnnotation) {\n                parts.push(path.call(print, \"typeAnnotation\"));\n            }\n            if (n.value) {\n                parts.push(\" = \", path.call(print, \"value\"));\n            }\n            parts.push(\";\");\n            return lines_1.concat(parts);\n        }\n        case \"ClassPrivateProperty\":\n            if (n.static) {\n                parts.push(\"static \");\n            }\n            parts.push(path.call(print, \"key\"));\n            if (n.typeAnnotation) {\n                parts.push(path.call(print, \"typeAnnotation\"));\n            }\n            if (n.value) {\n                parts.push(\" = \", path.call(print, \"value\"));\n            }\n            parts.push(\";\");\n            return lines_1.concat(parts);\n        case \"ClassDeclaration\":\n        case \"ClassExpression\":\n            if (n.declare) {\n                parts.push(\"declare \");\n            }\n            if (n.abstract) {\n                parts.push(\"abstract \");\n            }\n            parts.push(\"class\");\n            if (n.id) {\n                parts.push(\" \", path.call(print, \"id\"));\n            }\n            if (n.typeParameters) {\n                parts.push(path.call(print, \"typeParameters\"));\n            }\n            if (n.superClass) {\n                parts.push(\" extends \", path.call(print, \"superClass\"), path.call(print, \"superTypeParameters\"));\n            }\n            if (n[\"implements\"] && n[\"implements\"].length > 0) {\n                parts.push(\" implements \", lines_1.fromString(\", \").join(path.map(print, \"implements\")));\n            }\n            parts.push(\" \", path.call(print, \"body\"));\n            return lines_1.concat(parts);\n        case \"TemplateElement\":\n            return lines_1.fromString(n.value.raw, options).lockIndentTail();\n        case \"TemplateLiteral\": {\n            var expressions_1 = path.map(print, \"expressions\");\n            parts.push(\"`\");\n            path.each(function (childPath) {\n                var i = childPath.getName();\n                parts.push(print(childPath));\n                if (i < expressions_1.length) {\n                    parts.push(\"${\", expressions_1[i], \"}\");\n                }\n            }, \"quasis\");\n            parts.push(\"`\");\n            return lines_1.concat(parts).lockIndentTail();\n        }\n        case \"TaggedTemplateExpression\":\n            return lines_1.concat([path.call(print, \"tag\"), path.call(print, \"quasi\")]);\n        // These types are unprintable because they serve as abstract\n        // supertypes for other (printable) types.\n        case \"Node\":\n        case \"Printable\":\n        case \"SourceLocation\":\n        case \"Position\":\n        case \"Statement\":\n        case \"Function\":\n        case \"Pattern\":\n        case \"Expression\":\n        case \"Declaration\":\n        case \"Specifier\":\n        case \"NamedSpecifier\":\n        case \"Comment\": // Supertype of Block and Line\n        case \"Flow\": // Supertype of all Flow AST node types\n        case \"FlowType\": // Supertype of all Flow types\n        case \"FlowPredicate\": // Supertype of InferredPredicate and DeclaredPredicate\n        case \"MemberTypeAnnotation\": // Flow\n        case \"Type\": // Flow\n        case \"TSHasOptionalTypeParameterInstantiation\":\n        case \"TSHasOptionalTypeParameters\":\n        case \"TSHasOptionalTypeAnnotation\":\n        case \"ChainElement\": // Supertype of MemberExpression and CallExpression\n            throw new Error(\"unprintable type: \" + JSON.stringify(n.type));\n        case \"CommentBlock\": // Babel block comment.\n        case \"Block\": // Esprima block comment.\n            return lines_1.concat([\"/*\", lines_1.fromString(n.value, options), \"*/\"]);\n        case \"CommentLine\": // Babel line comment.\n        case \"Line\": // Esprima line comment.\n            return lines_1.concat([\"//\", lines_1.fromString(n.value, options)]);\n        // Type Annotations for Facebook Flow, typically stripped out or\n        // transformed away before printing.\n        case \"TypeAnnotation\":\n            if (n.typeAnnotation) {\n                if (n.typeAnnotation.type !== \"FunctionTypeAnnotation\") {\n                    parts.push(\": \");\n                }\n                parts.push(path.call(print, \"typeAnnotation\"));\n                return lines_1.concat(parts);\n            }\n            return lines_1.fromString(\"\");\n        case \"ExistentialTypeParam\":\n        case \"ExistsTypeAnnotation\":\n            return lines_1.fromString(\"*\", options);\n        case \"EmptyTypeAnnotation\":\n            return lines_1.fromString(\"empty\", options);\n        case \"AnyTypeAnnotation\":\n            return lines_1.fromString(\"any\", options);\n        case \"MixedTypeAnnotation\":\n            return lines_1.fromString(\"mixed\", options);\n        case \"ArrayTypeAnnotation\":\n            return lines_1.concat([path.call(print, \"elementType\"), \"[]\"]);\n        case \"TupleTypeAnnotation\": {\n            var printed_2 = path.map(print, \"types\");\n            var joined = lines_1.fromString(\", \").join(printed_2);\n            var oneLine_3 = joined.getLineLength(1) <= options.wrapColumn;\n            if (oneLine_3) {\n                if (options.arrayBracketSpacing) {\n                    parts.push(\"[ \");\n                }\n                else {\n                    parts.push(\"[\");\n                }\n            }\n            else {\n                parts.push(\"[\\n\");\n            }\n            path.each(function (elemPath) {\n                var i = elemPath.getName();\n                var elem = elemPath.getValue();\n                if (!elem) {\n                    // If the array expression ends with a hole, that hole\n                    // will be ignored by the interpreter, but if it ends with\n                    // two (or more) holes, we need to write out two (or more)\n                    // commas so that the resulting code is interpreted with\n                    // both (all) of the holes.\n                    parts.push(\",\");\n                }\n                else {\n                    var lines = printed_2[i];\n                    if (oneLine_3) {\n                        if (i > 0)\n                            parts.push(\" \");\n                    }\n                    else {\n                        lines = lines.indent(options.tabWidth);\n                    }\n                    parts.push(lines);\n                    if (i < n.types.length - 1 ||\n                        (!oneLine_3 && util.isTrailingCommaEnabled(options, \"arrays\")))\n                        parts.push(\",\");\n                    if (!oneLine_3)\n                        parts.push(\"\\n\");\n                }\n            }, \"types\");\n            if (oneLine_3 && options.arrayBracketSpacing) {\n                parts.push(\" ]\");\n            }\n            else {\n                parts.push(\"]\");\n            }\n            return lines_1.concat(parts);\n        }\n        case \"BooleanTypeAnnotation\":\n            return lines_1.fromString(\"boolean\", options);\n        case \"BooleanLiteralTypeAnnotation\":\n            assert_1.default.strictEqual(typeof n.value, \"boolean\");\n            return lines_1.fromString(\"\" + n.value, options);\n        case \"InterfaceTypeAnnotation\":\n            parts.push(\"interface\");\n            if (n.extends && n.extends.length > 0) {\n                parts.push(\" extends \", lines_1.fromString(\", \").join(path.map(print, \"extends\")));\n            }\n            parts.push(\" \", path.call(print, \"body\"));\n            return lines_1.concat(parts);\n        case \"DeclareClass\":\n            return printFlowDeclaration(path, [\n                \"class \",\n                path.call(print, \"id\"),\n                \" \",\n                path.call(print, \"body\"),\n            ]);\n        case \"DeclareFunction\":\n            return printFlowDeclaration(path, [\n                \"function \",\n                path.call(print, \"id\"),\n                \";\",\n            ]);\n        case \"DeclareModule\":\n            return printFlowDeclaration(path, [\n                \"module \",\n                path.call(print, \"id\"),\n                \" \",\n                path.call(print, \"body\"),\n            ]);\n        case \"DeclareModuleExports\":\n            return printFlowDeclaration(path, [\n                \"module.exports\",\n                path.call(print, \"typeAnnotation\"),\n            ]);\n        case \"DeclareVariable\":\n            return printFlowDeclaration(path, [\"var \", path.call(print, \"id\"), \";\"]);\n        case \"DeclareExportDeclaration\":\n        case \"DeclareExportAllDeclaration\":\n            return lines_1.concat([\"declare \", printExportDeclaration(path, options, print)]);\n        case \"EnumDeclaration\":\n            return lines_1.concat([\n                \"enum \",\n                path.call(print, \"id\"),\n                path.call(print, \"body\"),\n            ]);\n        case \"EnumBooleanBody\":\n        case \"EnumNumberBody\":\n        case \"EnumStringBody\":\n        case \"EnumSymbolBody\": {\n            if (n.type === \"EnumSymbolBody\" || n.explicitType) {\n                parts.push(\" of \", \n                // EnumBooleanBody => boolean, etc.\n                n.type.slice(4, -4).toLowerCase());\n            }\n            parts.push(\" {\\n\", lines_1.fromString(\"\\n\")\n                .join(path.map(print, \"members\"))\n                .indent(options.tabWidth), \"\\n}\");\n            return lines_1.concat(parts);\n        }\n        case \"EnumDefaultedMember\":\n            return lines_1.concat([path.call(print, \"id\"), \",\"]);\n        case \"EnumBooleanMember\":\n        case \"EnumNumberMember\":\n        case \"EnumStringMember\":\n            return lines_1.concat([\n                path.call(print, \"id\"),\n                \" = \",\n                path.call(print, \"init\"),\n                \",\",\n            ]);\n        case \"InferredPredicate\":\n            return lines_1.fromString(\"%checks\", options);\n        case \"DeclaredPredicate\":\n            return lines_1.concat([\"%checks(\", path.call(print, \"value\"), \")\"]);\n        case \"FunctionTypeAnnotation\": {\n            // FunctionTypeAnnotation is ambiguous:\n            // declare function(a: B): void; OR\n            // const A: (a: B) => void;\n            var parent = path.getParentNode(0);\n            var isArrowFunctionTypeAnnotation = !(namedTypes.ObjectTypeCallProperty.check(parent) ||\n                (namedTypes.ObjectTypeInternalSlot.check(parent) && parent.method) ||\n                namedTypes.DeclareFunction.check(path.getParentNode(2)));\n            var needsColon = isArrowFunctionTypeAnnotation &&\n                !namedTypes.FunctionTypeParam.check(parent) &&\n                !namedTypes.TypeAlias.check(parent);\n            if (needsColon) {\n                parts.push(\": \");\n            }\n            var needsParens = n.params.length !== 1 || n.params[0].name;\n            parts.push(needsParens ? \"(\" : \"\", printFunctionParams(path, options, print), needsParens ? \")\" : \"\");\n            // The returnType is not wrapped in a TypeAnnotation, so the colon\n            // needs to be added separately.\n            if (n.returnType) {\n                parts.push(isArrowFunctionTypeAnnotation ? \" => \" : \": \", path.call(print, \"returnType\"));\n            }\n            return lines_1.concat(parts);\n        }\n        case \"FunctionTypeParam\": {\n            var name = path.call(print, \"name\");\n            parts.push(name);\n            if (n.optional) {\n                parts.push(\"?\");\n            }\n            if (name.infos[0].line) {\n                parts.push(\": \");\n            }\n            parts.push(path.call(print, \"typeAnnotation\"));\n            return lines_1.concat(parts);\n        }\n        case \"GenericTypeAnnotation\":\n            return lines_1.concat([\n                path.call(print, \"id\"),\n                path.call(print, \"typeParameters\"),\n            ]);\n        case \"DeclareInterface\":\n            parts.push(\"declare \");\n        // Fall through to InterfaceDeclaration...\n        case \"InterfaceDeclaration\":\n        case \"TSInterfaceDeclaration\":\n            if (n.declare) {\n                parts.push(\"declare \");\n            }\n            parts.push(\"interface \", path.call(print, \"id\"), path.call(print, \"typeParameters\"), \" \");\n            if (n[\"extends\"] && n[\"extends\"].length > 0) {\n                parts.push(\"extends \", lines_1.fromString(\", \").join(path.map(print, \"extends\")), \" \");\n            }\n            if (n.body) {\n                parts.push(path.call(print, \"body\"));\n            }\n            return lines_1.concat(parts);\n        case \"ClassImplements\":\n        case \"InterfaceExtends\":\n            return lines_1.concat([\n                path.call(print, \"id\"),\n                path.call(print, \"typeParameters\"),\n            ]);\n        case \"IntersectionTypeAnnotation\":\n            return lines_1.fromString(\" & \").join(path.map(print, \"types\"));\n        case \"NullableTypeAnnotation\":\n            return lines_1.concat([\"?\", path.call(print, \"typeAnnotation\")]);\n        case \"NullLiteralTypeAnnotation\":\n            return lines_1.fromString(\"null\", options);\n        case \"ThisTypeAnnotation\":\n            return lines_1.fromString(\"this\", options);\n        case \"NumberTypeAnnotation\":\n            return lines_1.fromString(\"number\", options);\n        case \"ObjectTypeCallProperty\":\n            return path.call(print, \"value\");\n        case \"ObjectTypeIndexer\":\n            if (n.static) {\n                parts.push(\"static \");\n            }\n            parts.push(printVariance(path, print), \"[\");\n            if (n.id) {\n                parts.push(path.call(print, \"id\"), \": \");\n            }\n            parts.push(path.call(print, \"key\"), \"]: \", path.call(print, \"value\"));\n            return lines_1.concat(parts);\n        case \"ObjectTypeProperty\":\n            return lines_1.concat([\n                printVariance(path, print),\n                path.call(print, \"key\"),\n                n.optional ? \"?\" : \"\",\n                \": \",\n                path.call(print, \"value\"),\n            ]);\n        case \"ObjectTypeInternalSlot\":\n            return lines_1.concat([\n                n.static ? \"static \" : \"\",\n                \"[[\",\n                path.call(print, \"id\"),\n                \"]]\",\n                n.optional ? \"?\" : \"\",\n                n.value.type !== \"FunctionTypeAnnotation\" ? \": \" : \"\",\n                path.call(print, \"value\"),\n            ]);\n        case \"QualifiedTypeIdentifier\":\n            return lines_1.concat([\n                path.call(print, \"qualification\"),\n                \".\",\n                path.call(print, \"id\"),\n            ]);\n        case \"StringLiteralTypeAnnotation\":\n            return lines_1.fromString(nodeStr(n.value, options), options);\n        case \"NumberLiteralTypeAnnotation\":\n        case \"NumericLiteralTypeAnnotation\":\n            assert_1.default.strictEqual(typeof n.value, \"number\");\n            return lines_1.fromString(JSON.stringify(n.value), options);\n        case \"BigIntLiteralTypeAnnotation\":\n            return lines_1.fromString(n.raw, options);\n        case \"StringTypeAnnotation\":\n            return lines_1.fromString(\"string\", options);\n        case \"DeclareTypeAlias\":\n            parts.push(\"declare \");\n        // Fall through to TypeAlias...\n        case \"TypeAlias\":\n            return lines_1.concat([\n                \"type \",\n                path.call(print, \"id\"),\n                path.call(print, \"typeParameters\"),\n                \" = \",\n                path.call(print, \"right\"),\n                \";\",\n            ]);\n        case \"DeclareOpaqueType\":\n            parts.push(\"declare \");\n        // Fall through to OpaqueType...\n        case \"OpaqueType\":\n            parts.push(\"opaque type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"));\n            if (n[\"supertype\"]) {\n                parts.push(\": \", path.call(print, \"supertype\"));\n            }\n            if (n[\"impltype\"]) {\n                parts.push(\" = \", path.call(print, \"impltype\"));\n            }\n            parts.push(\";\");\n            return lines_1.concat(parts);\n        case \"TypeCastExpression\":\n            return lines_1.concat([\n                \"(\",\n                path.call(print, \"expression\"),\n                path.call(print, \"typeAnnotation\"),\n                \")\",\n            ]);\n        case \"TypeParameterDeclaration\":\n        case \"TypeParameterInstantiation\":\n            return lines_1.concat([\n                \"<\",\n                lines_1.fromString(\", \").join(path.map(print, \"params\")),\n                \">\",\n            ]);\n        case \"Variance\":\n            if (n.kind === \"plus\") {\n                return lines_1.fromString(\"+\");\n            }\n            if (n.kind === \"minus\") {\n                return lines_1.fromString(\"-\");\n            }\n            return lines_1.fromString(\"\");\n        case \"TypeParameter\":\n            if (n.variance) {\n                parts.push(printVariance(path, print));\n            }\n            parts.push(path.call(print, \"name\"));\n            if (n.bound) {\n                parts.push(path.call(print, \"bound\"));\n            }\n            if (n[\"default\"]) {\n                parts.push(\"=\", path.call(print, \"default\"));\n            }\n            return lines_1.concat(parts);\n        case \"TypeofTypeAnnotation\":\n            return lines_1.concat([\n                lines_1.fromString(\"typeof \", options),\n                path.call(print, \"argument\"),\n            ]);\n        case \"UnionTypeAnnotation\":\n            return lines_1.fromString(\" | \").join(path.map(print, \"types\"));\n        case \"VoidTypeAnnotation\":\n            return lines_1.fromString(\"void\", options);\n        case \"NullTypeAnnotation\":\n            return lines_1.fromString(\"null\", options);\n        case \"SymbolTypeAnnotation\":\n            return lines_1.fromString(\"symbol\", options);\n        case \"BigIntTypeAnnotation\":\n            return lines_1.fromString(\"bigint\", options);\n        // Type Annotations for TypeScript (when using Babylon as parser)\n        case \"TSType\":\n            throw new Error(\"unprintable type: \" + JSON.stringify(n.type));\n        case \"TSNumberKeyword\":\n            return lines_1.fromString(\"number\", options);\n        case \"TSBigIntKeyword\":\n            return lines_1.fromString(\"bigint\", options);\n        case \"TSObjectKeyword\":\n            return lines_1.fromString(\"object\", options);\n        case \"TSBooleanKeyword\":\n            return lines_1.fromString(\"boolean\", options);\n        case \"TSStringKeyword\":\n            return lines_1.fromString(\"string\", options);\n        case \"TSSymbolKeyword\":\n            return lines_1.fromString(\"symbol\", options);\n        case \"TSAnyKeyword\":\n            return lines_1.fromString(\"any\", options);\n        case \"TSVoidKeyword\":\n            return lines_1.fromString(\"void\", options);\n        case \"TSThisType\":\n            return lines_1.fromString(\"this\", options);\n        case \"TSNullKeyword\":\n            return lines_1.fromString(\"null\", options);\n        case \"TSUndefinedKeyword\":\n            return lines_1.fromString(\"undefined\", options);\n        case \"TSUnknownKeyword\":\n            return lines_1.fromString(\"unknown\", options);\n        case \"TSNeverKeyword\":\n            return lines_1.fromString(\"never\", options);\n        case \"TSArrayType\":\n            return lines_1.concat([path.call(print, \"elementType\"), \"[]\"]);\n        case \"TSLiteralType\":\n            return path.call(print, \"literal\");\n        case \"TSUnionType\":\n            return lines_1.fromString(\" | \").join(path.map(print, \"types\"));\n        case \"TSIntersectionType\":\n            return lines_1.fromString(\" & \").join(path.map(print, \"types\"));\n        case \"TSConditionalType\":\n            parts.push(path.call(print, \"checkType\"), \" extends \", path.call(print, \"extendsType\"), \" ? \", path.call(print, \"trueType\"), \" : \", path.call(print, \"falseType\"));\n            return lines_1.concat(parts);\n        case \"TSInferType\":\n            parts.push(\"infer \", path.call(print, \"typeParameter\"));\n            return lines_1.concat(parts);\n        case \"TSParenthesizedType\":\n            return lines_1.concat([\"(\", path.call(print, \"typeAnnotation\"), \")\"]);\n        case \"TSFunctionType\":\n            return lines_1.concat([\n                path.call(print, \"typeParameters\"),\n                \"(\",\n                printFunctionParams(path, options, print),\n                \") => \",\n                path.call(print, \"typeAnnotation\", \"typeAnnotation\"),\n            ]);\n        case \"TSConstructorType\":\n            return lines_1.concat([\n                \"new \",\n                path.call(print, \"typeParameters\"),\n                \"(\",\n                printFunctionParams(path, options, print),\n                \") => \",\n                path.call(print, \"typeAnnotation\", \"typeAnnotation\"),\n            ]);\n        case \"TSMappedType\": {\n            parts.push(n.readonly ? \"readonly \" : \"\", \"[\", path.call(print, \"typeParameter\"), \"]\", n.optional ? \"?\" : \"\");\n            if (n.typeAnnotation) {\n                parts.push(\": \", path.call(print, \"typeAnnotation\"), \";\");\n            }\n            return lines_1.concat([\"{\\n\", lines_1.concat(parts).indent(options.tabWidth), \"\\n}\"]);\n        }\n        case \"TSTupleType\":\n            return lines_1.concat([\n                \"[\",\n                lines_1.fromString(\", \").join(path.map(print, \"elementTypes\")),\n                \"]\",\n            ]);\n        case \"TSNamedTupleMember\":\n            parts.push(path.call(print, \"label\"));\n            if (n.optional) {\n                parts.push(\"?\");\n            }\n            parts.push(\": \", path.call(print, \"elementType\"));\n            return lines_1.concat(parts);\n        case \"TSRestType\":\n            return lines_1.concat([\"...\", path.call(print, \"typeAnnotation\")]);\n        case \"TSOptionalType\":\n            return lines_1.concat([path.call(print, \"typeAnnotation\"), \"?\"]);\n        case \"TSIndexedAccessType\":\n            return lines_1.concat([\n                path.call(print, \"objectType\"),\n                \"[\",\n                path.call(print, \"indexType\"),\n                \"]\",\n            ]);\n        case \"TSTypeOperator\":\n            return lines_1.concat([\n                path.call(print, \"operator\"),\n                \" \",\n                path.call(print, \"typeAnnotation\"),\n            ]);\n        case \"TSTypeLiteral\": {\n            var memberLines = lines_1.fromString(\",\\n\").join(path.map(print, \"members\"));\n            if (memberLines.isEmpty()) {\n                return lines_1.fromString(\"{}\", options);\n            }\n            parts.push(\"{\\n\", memberLines.indent(options.tabWidth), \"\\n}\");\n            return lines_1.concat(parts);\n        }\n        case \"TSEnumMember\":\n            parts.push(path.call(print, \"id\"));\n            if (n.initializer) {\n                parts.push(\" = \", path.call(print, \"initializer\"));\n            }\n            return lines_1.concat(parts);\n        case \"TSTypeQuery\":\n            return lines_1.concat([\"typeof \", path.call(print, \"exprName\")]);\n        case \"TSParameterProperty\":\n            if (n.accessibility) {\n                parts.push(n.accessibility, \" \");\n            }\n            if (n.export) {\n                parts.push(\"export \");\n            }\n            if (n.static) {\n                parts.push(\"static \");\n            }\n            if (n.readonly) {\n                parts.push(\"readonly \");\n            }\n            parts.push(path.call(print, \"parameter\"));\n            return lines_1.concat(parts);\n        case \"TSTypeReference\":\n            return lines_1.concat([\n                path.call(print, \"typeName\"),\n                path.call(print, \"typeParameters\"),\n            ]);\n        case \"TSQualifiedName\":\n            return lines_1.concat([path.call(print, \"left\"), \".\", path.call(print, \"right\")]);\n        case \"TSAsExpression\": {\n            var expression = path.call(print, \"expression\");\n            parts.push(expression, lines_1.fromString(\" as \"), path.call(print, \"typeAnnotation\"));\n            return lines_1.concat(parts);\n        }\n        case \"TSNonNullExpression\":\n            return lines_1.concat([path.call(print, \"expression\"), \"!\"]);\n        case \"TSTypeAnnotation\":\n            return lines_1.concat([\": \", path.call(print, \"typeAnnotation\")]);\n        case \"TSIndexSignature\":\n            return lines_1.concat([\n                n.readonly ? \"readonly \" : \"\",\n                \"[\",\n                path.map(print, \"parameters\"),\n                \"]\",\n                path.call(print, \"typeAnnotation\"),\n            ]);\n        case \"TSPropertySignature\":\n            parts.push(printVariance(path, print), n.readonly ? \"readonly \" : \"\");\n            if (n.computed) {\n                parts.push(\"[\", path.call(print, \"key\"), \"]\");\n            }\n            else {\n                parts.push(path.call(print, \"key\"));\n            }\n            parts.push(n.optional ? \"?\" : \"\", path.call(print, \"typeAnnotation\"));\n            return lines_1.concat(parts);\n        case \"TSMethodSignature\":\n            if (n.computed) {\n                parts.push(\"[\", path.call(print, \"key\"), \"]\");\n            }\n            else {\n                parts.push(path.call(print, \"key\"));\n            }\n            if (n.optional) {\n                parts.push(\"?\");\n            }\n            parts.push(path.call(print, \"typeParameters\"), \"(\", printFunctionParams(path, options, print), \")\", path.call(print, \"typeAnnotation\"));\n            return lines_1.concat(parts);\n        case \"TSTypePredicate\":\n            if (n.asserts) {\n                parts.push(\"asserts \");\n            }\n            parts.push(path.call(print, \"parameterName\"));\n            if (n.typeAnnotation) {\n                parts.push(\" is \", path.call(print, \"typeAnnotation\", \"typeAnnotation\"));\n            }\n            return lines_1.concat(parts);\n        case \"TSCallSignatureDeclaration\":\n            return lines_1.concat([\n                path.call(print, \"typeParameters\"),\n                \"(\",\n                printFunctionParams(path, options, print),\n                \")\",\n                path.call(print, \"typeAnnotation\"),\n            ]);\n        case \"TSConstructSignatureDeclaration\":\n            if (n.typeParameters) {\n                parts.push(\"new\", path.call(print, \"typeParameters\"));\n            }\n            else {\n                parts.push(\"new \");\n            }\n            parts.push(\"(\", printFunctionParams(path, options, print), \")\", path.call(print, \"typeAnnotation\"));\n            return lines_1.concat(parts);\n        case \"TSTypeAliasDeclaration\":\n            return lines_1.concat([\n                n.declare ? \"declare \" : \"\",\n                \"type \",\n                path.call(print, \"id\"),\n                path.call(print, \"typeParameters\"),\n                \" = \",\n                path.call(print, \"typeAnnotation\"),\n                \";\",\n            ]);\n        case \"TSTypeParameter\": {\n            parts.push(path.call(print, \"name\"));\n            // ambiguous because of TSMappedType\n            var parent = path.getParentNode(0);\n            var isInMappedType = namedTypes.TSMappedType.check(parent);\n            if (n.constraint) {\n                parts.push(isInMappedType ? \" in \" : \" extends \", path.call(print, \"constraint\"));\n            }\n            if (n[\"default\"]) {\n                parts.push(\" = \", path.call(print, \"default\"));\n            }\n            return lines_1.concat(parts);\n        }\n        case \"TSTypeAssertion\": {\n            parts.push(\"<\", path.call(print, \"typeAnnotation\"), \"> \", path.call(print, \"expression\"));\n            return lines_1.concat(parts);\n        }\n        case \"TSTypeParameterDeclaration\":\n        case \"TSTypeParameterInstantiation\":\n            return lines_1.concat([\n                \"<\",\n                lines_1.fromString(\", \").join(path.map(print, \"params\")),\n                \">\",\n            ]);\n        case \"TSEnumDeclaration\": {\n            parts.push(n.declare ? \"declare \" : \"\", n.const ? \"const \" : \"\", \"enum \", path.call(print, \"id\"));\n            var memberLines = lines_1.fromString(\",\\n\").join(path.map(print, \"members\"));\n            if (memberLines.isEmpty()) {\n                parts.push(\" {}\");\n            }\n            else {\n                parts.push(\" {\\n\", memberLines.indent(options.tabWidth), \"\\n}\");\n            }\n            return lines_1.concat(parts);\n        }\n        case \"TSExpressionWithTypeArguments\":\n            return lines_1.concat([\n                path.call(print, \"expression\"),\n                path.call(print, \"typeParameters\"),\n            ]);\n        case \"TSInterfaceBody\": {\n            var lines = lines_1.fromString(\";\\n\").join(path.map(print, \"body\"));\n            if (lines.isEmpty()) {\n                return lines_1.fromString(\"{}\", options);\n            }\n            return lines_1.concat([\"{\\n\", lines.indent(options.tabWidth), \";\", \"\\n}\"]);\n        }\n        case \"TSImportType\":\n            parts.push(\"import(\", path.call(print, \"argument\"), \")\");\n            if (n.qualifier) {\n                parts.push(\".\", path.call(print, \"qualifier\"));\n            }\n            if (n.typeParameters) {\n                parts.push(path.call(print, \"typeParameters\"));\n            }\n            return lines_1.concat(parts);\n        case \"TSImportEqualsDeclaration\":\n            if (n.isExport) {\n                parts.push(\"export \");\n            }\n            parts.push(\"import \", path.call(print, \"id\"), \" = \", path.call(print, \"moduleReference\"));\n            return maybeAddSemicolon(lines_1.concat(parts));\n        case \"TSExternalModuleReference\":\n            return lines_1.concat([\"require(\", path.call(print, \"expression\"), \")\"]);\n        case \"TSModuleDeclaration\": {\n            var parent = path.getParentNode();\n            if (parent.type === \"TSModuleDeclaration\") {\n                parts.push(\".\");\n            }\n            else {\n                if (n.declare) {\n                    parts.push(\"declare \");\n                }\n                if (!n.global) {\n                    var isExternal = n.id.type === \"StringLiteral\" ||\n                        (n.id.type === \"Literal\" && typeof n.id.value === \"string\");\n                    if (isExternal) {\n                        parts.push(\"module \");\n                    }\n                    else if (n.loc && n.loc.lines && n.id.loc) {\n                        var prefix = n.loc.lines.sliceString(n.loc.start, n.id.loc.start);\n                        // These keywords are fundamentally ambiguous in the\n                        // Babylon parser, and not reflected in the AST, so\n                        // the best we can do is to match the original code,\n                        // when possible.\n                        if (prefix.indexOf(\"module\") >= 0) {\n                            parts.push(\"module \");\n                        }\n                        else {\n                            parts.push(\"namespace \");\n                        }\n                    }\n                    else {\n                        parts.push(\"namespace \");\n                    }\n                }\n            }\n            parts.push(path.call(print, \"id\"));\n            if (n.body && n.body.type === \"TSModuleDeclaration\") {\n                parts.push(path.call(print, \"body\"));\n            }\n            else if (n.body) {\n                var bodyLines = path.call(print, \"body\");\n                if (bodyLines.isEmpty()) {\n                    parts.push(\" {}\");\n                }\n                else {\n                    parts.push(\" {\\n\", bodyLines.indent(options.tabWidth), \"\\n}\");\n                }\n            }\n            return lines_1.concat(parts);\n        }\n        case \"TSModuleBlock\":\n            return path.call(function (bodyPath) { return printStatementSequence(bodyPath, options, print); }, \"body\");\n        // Unhandled types below. If encountered, nodes of these types should\n        // be either left alone or desugared into AST types that are fully\n        // supported by the pretty-printer.\n        case \"ClassHeritage\": // TODO\n        case \"ComprehensionBlock\": // TODO\n        case \"ComprehensionExpression\": // TODO\n        case \"Glob\": // TODO\n        case \"GeneratorExpression\": // TODO\n        case \"LetStatement\": // TODO\n        case \"LetExpression\": // TODO\n        case \"GraphExpression\": // TODO\n        case \"GraphIndexExpression\": // TODO\n        case \"XMLDefaultDeclaration\":\n        case \"XMLAnyName\":\n        case \"XMLQualifiedIdentifier\":\n        case \"XMLFunctionQualifiedIdentifier\":\n        case \"XMLAttributeSelector\":\n        case \"XMLFilterExpression\":\n        case \"XML\":\n        case \"XMLElement\":\n        case \"XMLList\":\n        case \"XMLEscape\":\n        case \"XMLText\":\n        case \"XMLStartTag\":\n        case \"XMLEndTag\":\n        case \"XMLPointTag\":\n        case \"XMLName\":\n        case \"XMLAttribute\":\n        case \"XMLCdata\":\n        case \"XMLComment\":\n        case \"XMLProcessingInstruction\":\n        default:\n            debugger;\n            throw new Error(\"unknown type: \" + JSON.stringify(n.type));\n    }\n}\nfunction printDecorators(path, printPath) {\n    var parts = [];\n    var node = path.getValue();\n    if (node.decorators &&\n        node.decorators.length > 0 &&\n        // If the parent node is an export declaration, it will be\n        // responsible for printing node.decorators.\n        !util.getParentExportDeclaration(path)) {\n        path.each(function (decoratorPath) {\n            parts.push(printPath(decoratorPath), \"\\n\");\n        }, \"decorators\");\n    }\n    else if (util.isExportDeclaration(node) &&\n        node.declaration &&\n        node.declaration.decorators) {\n        // Export declarations are responsible for printing any decorators\n        // that logically apply to node.declaration.\n        path.each(function (decoratorPath) {\n            parts.push(printPath(decoratorPath), \"\\n\");\n        }, \"declaration\", \"decorators\");\n    }\n    return lines_1.concat(parts);\n}\nfunction printStatementSequence(path, options, print) {\n    var filtered = [];\n    var sawComment = false;\n    var sawStatement = false;\n    path.each(function (stmtPath) {\n        var stmt = stmtPath.getValue();\n        // Just in case the AST has been modified to contain falsy\n        // \"statements,\" it's safer simply to skip them.\n        if (!stmt) {\n            return;\n        }\n        // Skip printing EmptyStatement nodes to avoid leaving stray\n        // semicolons lying around.\n        if (stmt.type === \"EmptyStatement\" &&\n            !(stmt.comments && stmt.comments.length > 0)) {\n            return;\n        }\n        if (namedTypes.Comment.check(stmt)) {\n            // The pretty printer allows a dangling Comment node to act as\n            // a Statement when the Comment can't be attached to any other\n            // non-Comment node in the tree.\n            sawComment = true;\n        }\n        else if (namedTypes.Statement.check(stmt)) {\n            sawStatement = true;\n        }\n        else {\n            // When the pretty printer encounters a string instead of an\n            // AST node, it just prints the string. This behavior can be\n            // useful for fine-grained formatting decisions like inserting\n            // blank lines.\n            isString.assert(stmt);\n        }\n        // We can't hang onto stmtPath outside of this function, because\n        // it's just a reference to a mutable FastPath object, so we have\n        // to go ahead and print it here.\n        filtered.push({\n            node: stmt,\n            printed: print(stmtPath),\n        });\n    });\n    if (sawComment) {\n        assert_1.default.strictEqual(sawStatement, false, \"Comments may appear as statements in otherwise empty statement \" +\n            \"lists, but may not coexist with non-Comment nodes.\");\n    }\n    var prevTrailingSpace = null;\n    var len = filtered.length;\n    var parts = [];\n    filtered.forEach(function (info, i) {\n        var printed = info.printed;\n        var stmt = info.node;\n        var multiLine = printed.length > 1;\n        var notFirst = i > 0;\n        var notLast = i < len - 1;\n        var leadingSpace;\n        var trailingSpace;\n        var lines = stmt && stmt.loc && stmt.loc.lines;\n        var trueLoc = lines && options.reuseWhitespace && util.getTrueLoc(stmt, lines);\n        if (notFirst) {\n            if (trueLoc) {\n                var beforeStart = lines.skipSpaces(trueLoc.start, true);\n                var beforeStartLine = beforeStart ? beforeStart.line : 1;\n                var leadingGap = trueLoc.start.line - beforeStartLine;\n                leadingSpace = Array(leadingGap + 1).join(\"\\n\");\n            }\n            else {\n                leadingSpace = multiLine ? \"\\n\\n\" : \"\\n\";\n            }\n        }\n        else {\n            leadingSpace = \"\";\n        }\n        if (notLast) {\n            if (trueLoc) {\n                var afterEnd = lines.skipSpaces(trueLoc.end);\n                var afterEndLine = afterEnd ? afterEnd.line : lines.length;\n                var trailingGap = afterEndLine - trueLoc.end.line;\n                trailingSpace = Array(trailingGap + 1).join(\"\\n\");\n            }\n            else {\n                trailingSpace = multiLine ? \"\\n\\n\" : \"\\n\";\n            }\n        }\n        else {\n            trailingSpace = \"\";\n        }\n        parts.push(maxSpace(prevTrailingSpace, leadingSpace), printed);\n        if (notLast) {\n            prevTrailingSpace = trailingSpace;\n        }\n        else if (trailingSpace) {\n            parts.push(trailingSpace);\n        }\n    });\n    return lines_1.concat(parts);\n}\nfunction maxSpace(s1, s2) {\n    if (!s1 && !s2) {\n        return lines_1.fromString(\"\");\n    }\n    if (!s1) {\n        return lines_1.fromString(s2);\n    }\n    if (!s2) {\n        return lines_1.fromString(s1);\n    }\n    var spaceLines1 = lines_1.fromString(s1);\n    var spaceLines2 = lines_1.fromString(s2);\n    if (spaceLines2.length > spaceLines1.length) {\n        return spaceLines2;\n    }\n    return spaceLines1;\n}\nfunction printMethod(path, options, print) {\n    var node = path.getNode();\n    var kind = node.kind;\n    var parts = [];\n    var nodeValue = node.value;\n    if (!namedTypes.FunctionExpression.check(nodeValue)) {\n        nodeValue = node;\n    }\n    var access = node.accessibility || node.access;\n    if (typeof access === \"string\") {\n        parts.push(access, \" \");\n    }\n    if (node.static) {\n        parts.push(\"static \");\n    }\n    if (node.abstract) {\n        parts.push(\"abstract \");\n    }\n    if (node.readonly) {\n        parts.push(\"readonly \");\n    }\n    if (nodeValue.async) {\n        parts.push(\"async \");\n    }\n    if (nodeValue.generator) {\n        parts.push(\"*\");\n    }\n    if (kind === \"get\" || kind === \"set\") {\n        parts.push(kind, \" \");\n    }\n    var key = path.call(print, \"key\");\n    if (node.computed) {\n        key = lines_1.concat([\"[\", key, \"]\"]);\n    }\n    parts.push(key);\n    if (node.optional) {\n        parts.push(\"?\");\n    }\n    if (node === nodeValue) {\n        parts.push(path.call(print, \"typeParameters\"), \"(\", printFunctionParams(path, options, print), \")\", path.call(print, \"returnType\"));\n        if (node.body) {\n            parts.push(\" \", path.call(print, \"body\"));\n        }\n        else {\n            parts.push(\";\");\n        }\n    }\n    else {\n        parts.push(path.call(print, \"value\", \"typeParameters\"), \"(\", path.call(function (valuePath) { return printFunctionParams(valuePath, options, print); }, \"value\"), \")\", path.call(print, \"value\", \"returnType\"));\n        if (nodeValue.body) {\n            parts.push(\" \", path.call(print, \"value\", \"body\"));\n        }\n        else {\n            parts.push(\";\");\n        }\n    }\n    return lines_1.concat(parts);\n}\nfunction printArgumentsList(path, options, print) {\n    var printed = path.map(print, \"arguments\");\n    var trailingComma = util.isTrailingCommaEnabled(options, \"parameters\");\n    var joined = lines_1.fromString(\", \").join(printed);\n    if (joined.getLineLength(1) > options.wrapColumn) {\n        joined = lines_1.fromString(\",\\n\").join(printed);\n        return lines_1.concat([\n            \"(\\n\",\n            joined.indent(options.tabWidth),\n            trailingComma ? \",\\n)\" : \"\\n)\",\n        ]);\n    }\n    return lines_1.concat([\"(\", joined, \")\"]);\n}\nfunction printFunctionParams(path, options, print) {\n    var fun = path.getValue();\n    var params;\n    var printed = [];\n    if (fun.params) {\n        params = fun.params;\n        printed = path.map(print, \"params\");\n    }\n    else if (fun.parameters) {\n        params = fun.parameters;\n        printed = path.map(print, \"parameters\");\n    }\n    if (fun.defaults) {\n        path.each(function (defExprPath) {\n            var i = defExprPath.getName();\n            var p = printed[i];\n            if (p && defExprPath.getValue()) {\n                printed[i] = lines_1.concat([p, \" = \", print(defExprPath)]);\n            }\n        }, \"defaults\");\n    }\n    if (fun.rest) {\n        printed.push(lines_1.concat([\"...\", path.call(print, \"rest\")]));\n    }\n    var joined = lines_1.fromString(\", \").join(printed);\n    if (joined.length > 1 || joined.getLineLength(1) > options.wrapColumn) {\n        joined = lines_1.fromString(\",\\n\").join(printed);\n        if (util.isTrailingCommaEnabled(options, \"parameters\") &&\n            !fun.rest &&\n            params[params.length - 1].type !== \"RestElement\") {\n            joined = lines_1.concat([joined, \",\\n\"]);\n        }\n        else {\n            joined = lines_1.concat([joined, \"\\n\"]);\n        }\n        return lines_1.concat([\"\\n\", joined.indent(options.tabWidth)]);\n    }\n    return joined;\n}\nfunction printExportDeclaration(path, options, print) {\n    var decl = path.getValue();\n    var parts = [\"export \"];\n    if (decl.exportKind && decl.exportKind === \"type\") {\n        if (!decl.declaration) {\n            parts.push(\"type \");\n        }\n    }\n    var shouldPrintSpaces = options.objectCurlySpacing;\n    namedTypes.Declaration.assert(decl);\n    if (decl[\"default\"] || decl.type === \"ExportDefaultDeclaration\") {\n        parts.push(\"default \");\n    }\n    if (decl.declaration) {\n        parts.push(path.call(print, \"declaration\"));\n    }\n    else if (decl.specifiers) {\n        if (decl.specifiers.length === 1 &&\n            decl.specifiers[0].type === \"ExportBatchSpecifier\") {\n            parts.push(\"*\");\n        }\n        else if (decl.specifiers.length === 0) {\n            parts.push(\"{}\");\n        }\n        else if (decl.specifiers[0].type === \"ExportDefaultSpecifier\") {\n            var unbracedSpecifiers_2 = [];\n            var bracedSpecifiers_2 = [];\n            path.each(function (specifierPath) {\n                var spec = specifierPath.getValue();\n                if (spec.type === \"ExportDefaultSpecifier\") {\n                    unbracedSpecifiers_2.push(print(specifierPath));\n                }\n                else {\n                    bracedSpecifiers_2.push(print(specifierPath));\n                }\n            }, \"specifiers\");\n            unbracedSpecifiers_2.forEach(function (lines, i) {\n                if (i > 0) {\n                    parts.push(\", \");\n                }\n                parts.push(lines);\n            });\n            if (bracedSpecifiers_2.length > 0) {\n                var lines_2 = lines_1.fromString(\", \").join(bracedSpecifiers_2);\n                if (lines_2.getLineLength(1) > options.wrapColumn) {\n                    lines_2 = lines_1.concat([\n                        lines_1.fromString(\",\\n\").join(bracedSpecifiers_2).indent(options.tabWidth),\n                        \",\",\n                    ]);\n                }\n                if (unbracedSpecifiers_2.length > 0) {\n                    parts.push(\", \");\n                }\n                if (lines_2.length > 1) {\n                    parts.push(\"{\\n\", lines_2, \"\\n}\");\n                }\n                else if (options.objectCurlySpacing) {\n                    parts.push(\"{ \", lines_2, \" }\");\n                }\n                else {\n                    parts.push(\"{\", lines_2, \"}\");\n                }\n            }\n        }\n        else {\n            parts.push(shouldPrintSpaces ? \"{ \" : \"{\", lines_1.fromString(\", \").join(path.map(print, \"specifiers\")), shouldPrintSpaces ? \" }\" : \"}\");\n        }\n        if (decl.source) {\n            parts.push(\" from \", path.call(print, \"source\"));\n        }\n    }\n    var lines = lines_1.concat(parts);\n    if (lastNonSpaceCharacter(lines) !== \";\" &&\n        !(decl.declaration &&\n            (decl.declaration.type === \"FunctionDeclaration\" ||\n                decl.declaration.type === \"ClassDeclaration\" ||\n                decl.declaration.type === \"TSModuleDeclaration\" ||\n                decl.declaration.type === \"TSInterfaceDeclaration\" ||\n                decl.declaration.type === \"TSEnumDeclaration\"))) {\n        lines = lines_1.concat([lines, \";\"]);\n    }\n    return lines;\n}\nfunction printFlowDeclaration(path, parts) {\n    var parentExportDecl = util.getParentExportDeclaration(path);\n    if (parentExportDecl) {\n        assert_1.default.strictEqual(parentExportDecl.type, \"DeclareExportDeclaration\");\n    }\n    else {\n        // If the parent node has type DeclareExportDeclaration, then it\n        // will be responsible for printing the \"declare\" token. Otherwise\n        // it needs to be printed with this non-exported declaration node.\n        parts.unshift(\"declare \");\n    }\n    return lines_1.concat(parts);\n}\nfunction printVariance(path, print) {\n    return path.call(function (variancePath) {\n        var value = variancePath.getValue();\n        if (value) {\n            if (value === \"plus\") {\n                return lines_1.fromString(\"+\");\n            }\n            if (value === \"minus\") {\n                return lines_1.fromString(\"-\");\n            }\n            return print(variancePath);\n        }\n        return lines_1.fromString(\"\");\n    }, \"variance\");\n}\nfunction adjustClause(clause, options) {\n    if (clause.length > 1)\n        return lines_1.concat([\" \", clause]);\n    return lines_1.concat([\"\\n\", maybeAddSemicolon(clause).indent(options.tabWidth)]);\n}\nfunction lastNonSpaceCharacter(lines) {\n    var pos = lines.lastPos();\n    do {\n        var ch = lines.charAt(pos);\n        if (/\\S/.test(ch))\n            return ch;\n    } while (lines.prevPos(pos));\n}\nfunction endsWithBrace(lines) {\n    return lastNonSpaceCharacter(lines) === \"}\";\n}\nfunction swapQuotes(str) {\n    return str.replace(/['\"]/g, function (m) { return (m === '\"' ? \"'\" : '\"'); });\n}\nfunction nodeStr(str, options) {\n    isString.assert(str);\n    switch (options.quote) {\n        case \"auto\": {\n            var double = JSON.stringify(str);\n            var single = swapQuotes(JSON.stringify(swapQuotes(str)));\n            return double.length > single.length ? single : double;\n        }\n        case \"single\":\n            return swapQuotes(JSON.stringify(swapQuotes(str)));\n        case \"double\":\n        default:\n            return JSON.stringify(str);\n    }\n}\nfunction maybeAddSemicolon(lines) {\n    var eoc = lastNonSpaceCharacter(lines);\n    if (!eoc || \"\\n};\".indexOf(eoc) < 0)\n        return lines_1.concat([lines, \";\"]);\n    return lines;\n}\n"]},"metadata":{},"sourceType":"script"}