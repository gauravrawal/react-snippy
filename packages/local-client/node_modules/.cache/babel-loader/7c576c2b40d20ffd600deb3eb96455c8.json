{"ast":null,"code":"\"use strict\";\n\n;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction scopePlugin(fork) {\n  var types = fork.use(types_1.default);\n  var Type = types.Type;\n  var namedTypes = types.namedTypes;\n  var Node = namedTypes.Node;\n  var Expression = namedTypes.Expression;\n  var isArray = types.builtInTypes.array;\n  var b = types.builders;\n\n  var Scope = function Scope(path, parentScope) {\n    if (!(this instanceof Scope)) {\n      throw new Error(\"Scope constructor cannot be invoked without 'new'\");\n    }\n\n    ScopeType.assert(path.value);\n    var depth;\n\n    if (parentScope) {\n      if (!(parentScope instanceof Scope)) {\n        throw new Error(\"\");\n      }\n\n      depth = parentScope.depth + 1;\n    } else {\n      parentScope = null;\n      depth = 0;\n    }\n\n    Object.defineProperties(this, {\n      path: {\n        value: path\n      },\n      node: {\n        value: path.value\n      },\n      isGlobal: {\n        value: !parentScope,\n        enumerable: true\n      },\n      depth: {\n        value: depth\n      },\n      parent: {\n        value: parentScope\n      },\n      bindings: {\n        value: {}\n      },\n      types: {\n        value: {}\n      }\n    });\n  };\n\n  var scopeTypes = [// Program nodes introduce global scopes.\n  namedTypes.Program, // Function is the supertype of FunctionExpression,\n  // FunctionDeclaration, ArrowExpression, etc.\n  namedTypes.Function, // In case you didn't know, the caught parameter shadows any variable\n  // of the same name in an outer scope.\n  namedTypes.CatchClause];\n  var ScopeType = Type.or.apply(Type, scopeTypes);\n\n  Scope.isEstablishedBy = function (node) {\n    return ScopeType.check(node);\n  };\n\n  var Sp = Scope.prototype; // Will be overridden after an instance lazily calls scanScope.\n\n  Sp.didScan = false;\n\n  Sp.declares = function (name) {\n    this.scan();\n    return hasOwn.call(this.bindings, name);\n  };\n\n  Sp.declaresType = function (name) {\n    this.scan();\n    return hasOwn.call(this.types, name);\n  };\n\n  Sp.declareTemporary = function (prefix) {\n    if (prefix) {\n      if (!/^[a-z$_]/i.test(prefix)) {\n        throw new Error(\"\");\n      }\n    } else {\n      prefix = \"t$\";\n    } // Include this.depth in the name to make sure the name does not\n    // collide with any variables in nested/enclosing scopes.\n\n\n    prefix += this.depth.toString(36) + \"$\";\n    this.scan();\n    var index = 0;\n\n    while (this.declares(prefix + index)) {\n      ++index;\n    }\n\n    var name = prefix + index;\n    return this.bindings[name] = types.builders.identifier(name);\n  };\n\n  Sp.injectTemporary = function (identifier, init) {\n    identifier || (identifier = this.declareTemporary());\n    var bodyPath = this.path.get(\"body\");\n\n    if (namedTypes.BlockStatement.check(bodyPath.value)) {\n      bodyPath = bodyPath.get(\"body\");\n    }\n\n    bodyPath.unshift(b.variableDeclaration(\"var\", [b.variableDeclarator(identifier, init || null)]));\n    return identifier;\n  };\n\n  Sp.scan = function (force) {\n    if (force || !this.didScan) {\n      for (var name in this.bindings) {\n        // Empty out this.bindings, just in cases.\n        delete this.bindings[name];\n      }\n\n      scanScope(this.path, this.bindings, this.types);\n      this.didScan = true;\n    }\n  };\n\n  Sp.getBindings = function () {\n    this.scan();\n    return this.bindings;\n  };\n\n  Sp.getTypes = function () {\n    this.scan();\n    return this.types;\n  };\n\n  function scanScope(path, bindings, scopeTypes) {\n    var node = path.value;\n    ScopeType.assert(node);\n\n    if (namedTypes.CatchClause.check(node)) {\n      // A catch clause establishes a new scope but the only variable\n      // bound in that scope is the catch parameter. Any other\n      // declarations create bindings in the outer scope.\n      var param = path.get(\"param\");\n\n      if (param.value) {\n        addPattern(param, bindings);\n      }\n    } else {\n      recursiveScanScope(path, bindings, scopeTypes);\n    }\n  }\n\n  function recursiveScanScope(path, bindings, scopeTypes) {\n    var node = path.value;\n\n    if (path.parent && namedTypes.FunctionExpression.check(path.parent.node) && path.parent.node.id) {\n      addPattern(path.parent.get(\"id\"), bindings);\n    }\n\n    if (!node) {// None of the remaining cases matter if node is falsy.\n    } else if (isArray.check(node)) {\n      path.each(function (childPath) {\n        recursiveScanChild(childPath, bindings, scopeTypes);\n      });\n    } else if (namedTypes.Function.check(node)) {\n      path.get(\"params\").each(function (paramPath) {\n        addPattern(paramPath, bindings);\n      });\n      recursiveScanChild(path.get(\"body\"), bindings, scopeTypes);\n    } else if (namedTypes.TypeAlias && namedTypes.TypeAlias.check(node) || namedTypes.InterfaceDeclaration && namedTypes.InterfaceDeclaration.check(node) || namedTypes.TSTypeAliasDeclaration && namedTypes.TSTypeAliasDeclaration.check(node) || namedTypes.TSInterfaceDeclaration && namedTypes.TSInterfaceDeclaration.check(node)) {\n      addTypePattern(path.get(\"id\"), scopeTypes);\n    } else if (namedTypes.VariableDeclarator.check(node)) {\n      addPattern(path.get(\"id\"), bindings);\n      recursiveScanChild(path.get(\"init\"), bindings, scopeTypes);\n    } else if (node.type === \"ImportSpecifier\" || node.type === \"ImportNamespaceSpecifier\" || node.type === \"ImportDefaultSpecifier\") {\n      addPattern( // Esprima used to use the .name field to refer to the local\n      // binding identifier for ImportSpecifier nodes, but .id for\n      // ImportNamespaceSpecifier and ImportDefaultSpecifier nodes.\n      // ESTree/Acorn/ESpree use .local for all three node types.\n      path.get(node.local ? \"local\" : node.name ? \"name\" : \"id\"), bindings);\n    } else if (Node.check(node) && !Expression.check(node)) {\n      types.eachField(node, function (name, child) {\n        var childPath = path.get(name);\n\n        if (!pathHasValue(childPath, child)) {\n          throw new Error(\"\");\n        }\n\n        recursiveScanChild(childPath, bindings, scopeTypes);\n      });\n    }\n  }\n\n  function pathHasValue(path, value) {\n    if (path.value === value) {\n      return true;\n    } // Empty arrays are probably produced by defaults.emptyArray, in which\n    // case is makes sense to regard them as equivalent, if not ===.\n\n\n    if (Array.isArray(path.value) && path.value.length === 0 && Array.isArray(value) && value.length === 0) {\n      return true;\n    }\n\n    return false;\n  }\n\n  function recursiveScanChild(path, bindings, scopeTypes) {\n    var node = path.value;\n\n    if (!node || Expression.check(node)) {// Ignore falsy values and Expressions.\n    } else if (namedTypes.FunctionDeclaration.check(node) && node.id !== null) {\n      addPattern(path.get(\"id\"), bindings);\n    } else if (namedTypes.ClassDeclaration && namedTypes.ClassDeclaration.check(node)) {\n      addPattern(path.get(\"id\"), bindings);\n    } else if (ScopeType.check(node)) {\n      if (namedTypes.CatchClause.check(node) && // TODO Broaden this to accept any pattern.\n      namedTypes.Identifier.check(node.param)) {\n        var catchParamName = node.param.name;\n        var hadBinding = hasOwn.call(bindings, catchParamName); // Any declarations that occur inside the catch body that do\n        // not have the same name as the catch parameter should count\n        // as bindings in the outer scope.\n\n        recursiveScanScope(path.get(\"body\"), bindings, scopeTypes); // If a new binding matching the catch parameter name was\n        // created while scanning the catch body, ignore it because it\n        // actually refers to the catch parameter and not the outer\n        // scope that we're currently scanning.\n\n        if (!hadBinding) {\n          delete bindings[catchParamName];\n        }\n      }\n    } else {\n      recursiveScanScope(path, bindings, scopeTypes);\n    }\n  }\n\n  function addPattern(patternPath, bindings) {\n    var pattern = patternPath.value;\n    namedTypes.Pattern.assert(pattern);\n\n    if (namedTypes.Identifier.check(pattern)) {\n      if (hasOwn.call(bindings, pattern.name)) {\n        bindings[pattern.name].push(patternPath);\n      } else {\n        bindings[pattern.name] = [patternPath];\n      }\n    } else if (namedTypes.AssignmentPattern && namedTypes.AssignmentPattern.check(pattern)) {\n      addPattern(patternPath.get('left'), bindings);\n    } else if (namedTypes.ObjectPattern && namedTypes.ObjectPattern.check(pattern)) {\n      patternPath.get('properties').each(function (propertyPath) {\n        var property = propertyPath.value;\n\n        if (namedTypes.Pattern.check(property)) {\n          addPattern(propertyPath, bindings);\n        } else if (namedTypes.Property.check(property)) {\n          addPattern(propertyPath.get('value'), bindings);\n        } else if (namedTypes.SpreadProperty && namedTypes.SpreadProperty.check(property)) {\n          addPattern(propertyPath.get('argument'), bindings);\n        }\n      });\n    } else if (namedTypes.ArrayPattern && namedTypes.ArrayPattern.check(pattern)) {\n      patternPath.get('elements').each(function (elementPath) {\n        var element = elementPath.value;\n\n        if (namedTypes.Pattern.check(element)) {\n          addPattern(elementPath, bindings);\n        } else if (namedTypes.SpreadElement && namedTypes.SpreadElement.check(element)) {\n          addPattern(elementPath.get(\"argument\"), bindings);\n        }\n      });\n    } else if (namedTypes.PropertyPattern && namedTypes.PropertyPattern.check(pattern)) {\n      addPattern(patternPath.get('pattern'), bindings);\n    } else if (namedTypes.SpreadElementPattern && namedTypes.SpreadElementPattern.check(pattern) || namedTypes.RestElement && namedTypes.RestElement.check(pattern) || namedTypes.SpreadPropertyPattern && namedTypes.SpreadPropertyPattern.check(pattern)) {\n      addPattern(patternPath.get('argument'), bindings);\n    }\n  }\n\n  function addTypePattern(patternPath, types) {\n    var pattern = patternPath.value;\n    namedTypes.Pattern.assert(pattern);\n\n    if (namedTypes.Identifier.check(pattern)) {\n      if (hasOwn.call(types, pattern.name)) {\n        types[pattern.name].push(patternPath);\n      } else {\n        types[pattern.name] = [patternPath];\n      }\n    }\n  }\n\n  Sp.lookup = function (name) {\n    for (var scope = this; scope; scope = scope.parent) if (scope.declares(name)) break;\n\n    return scope;\n  };\n\n  Sp.lookupType = function (name) {\n    for (var scope = this; scope; scope = scope.parent) if (scope.declaresType(name)) break;\n\n    return scope;\n  };\n\n  Sp.getGlobalScope = function () {\n    var scope = this;\n\n    while (!scope.isGlobal) scope = scope.parent;\n\n    return scope;\n  };\n\n  return Scope;\n}\n\nexports.default = scopePlugin;\nmodule.exports = exports[\"default\"];","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/jbook/node_modules/jscodeshift/node_modules/ast-types/lib/scope.js"],"names":["Object","defineProperty","exports","value","tslib_1","require","types_1","__importDefault","hasOwn","prototype","hasOwnProperty","scopePlugin","fork","types","use","default","Type","namedTypes","Node","Expression","isArray","builtInTypes","array","b","builders","Scope","path","parentScope","Error","ScopeType","assert","depth","defineProperties","node","isGlobal","enumerable","parent","bindings","scopeTypes","Program","Function","CatchClause","or","apply","isEstablishedBy","check","Sp","didScan","declares","name","scan","call","declaresType","declareTemporary","prefix","test","toString","index","identifier","injectTemporary","init","bodyPath","get","BlockStatement","unshift","variableDeclaration","variableDeclarator","force","scanScope","getBindings","getTypes","param","addPattern","recursiveScanScope","FunctionExpression","id","each","childPath","recursiveScanChild","paramPath","TypeAlias","InterfaceDeclaration","TSTypeAliasDeclaration","TSInterfaceDeclaration","addTypePattern","VariableDeclarator","type","local","eachField","child","pathHasValue","Array","length","FunctionDeclaration","ClassDeclaration","Identifier","catchParamName","hadBinding","patternPath","pattern","Pattern","push","AssignmentPattern","ObjectPattern","propertyPath","property","Property","SpreadProperty","ArrayPattern","elementPath","element","SpreadElement","PropertyPattern","SpreadElementPattern","RestElement","SpreadPropertyPattern","lookup","scope","lookupType","getGlobalScope","module"],"mappings":"AAAA;;AAAa;AACbA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAIC,OAAO,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,IAAIC,OAAO,GAAGF,OAAO,CAACG,eAAR,CAAwBF,OAAO,CAAC,SAAD,CAA/B,CAAd;;AACA,IAAIG,MAAM,GAAGR,MAAM,CAACS,SAAP,CAAiBC,cAA9B;;AACA,SAASC,WAAT,CAAqBC,IAArB,EAA2B;AACvB,MAAIC,KAAK,GAAGD,IAAI,CAACE,GAAL,CAASR,OAAO,CAACS,OAAjB,CAAZ;AACA,MAAIC,IAAI,GAAGH,KAAK,CAACG,IAAjB;AACA,MAAIC,UAAU,GAAGJ,KAAK,CAACI,UAAvB;AACA,MAAIC,IAAI,GAAGD,UAAU,CAACC,IAAtB;AACA,MAAIC,UAAU,GAAGF,UAAU,CAACE,UAA5B;AACA,MAAIC,OAAO,GAAGP,KAAK,CAACQ,YAAN,CAAmBC,KAAjC;AACA,MAAIC,CAAC,GAAGV,KAAK,CAACW,QAAd;;AACA,MAAIC,KAAK,GAAG,SAASA,KAAT,CAAeC,IAAf,EAAqBC,WAArB,EAAkC;AAC1C,QAAI,EAAE,gBAAgBF,KAAlB,CAAJ,EAA8B;AAC1B,YAAM,IAAIG,KAAJ,CAAU,mDAAV,CAAN;AACH;;AACDC,IAAAA,SAAS,CAACC,MAAV,CAAiBJ,IAAI,CAACvB,KAAtB;AACA,QAAI4B,KAAJ;;AACA,QAAIJ,WAAJ,EAAiB;AACb,UAAI,EAAEA,WAAW,YAAYF,KAAzB,CAAJ,EAAqC;AACjC,cAAM,IAAIG,KAAJ,CAAU,EAAV,CAAN;AACH;;AACDG,MAAAA,KAAK,GAAGJ,WAAW,CAACI,KAAZ,GAAoB,CAA5B;AACH,KALD,MAMK;AACDJ,MAAAA,WAAW,GAAG,IAAd;AACAI,MAAAA,KAAK,GAAG,CAAR;AACH;;AACD/B,IAAAA,MAAM,CAACgC,gBAAP,CAAwB,IAAxB,EAA8B;AAC1BN,MAAAA,IAAI,EAAE;AAAEvB,QAAAA,KAAK,EAAEuB;AAAT,OADoB;AAE1BO,MAAAA,IAAI,EAAE;AAAE9B,QAAAA,KAAK,EAAEuB,IAAI,CAACvB;AAAd,OAFoB;AAG1B+B,MAAAA,QAAQ,EAAE;AAAE/B,QAAAA,KAAK,EAAE,CAACwB,WAAV;AAAuBQ,QAAAA,UAAU,EAAE;AAAnC,OAHgB;AAI1BJ,MAAAA,KAAK,EAAE;AAAE5B,QAAAA,KAAK,EAAE4B;AAAT,OAJmB;AAK1BK,MAAAA,MAAM,EAAE;AAAEjC,QAAAA,KAAK,EAAEwB;AAAT,OALkB;AAM1BU,MAAAA,QAAQ,EAAE;AAAElC,QAAAA,KAAK,EAAE;AAAT,OANgB;AAO1BU,MAAAA,KAAK,EAAE;AAAEV,QAAAA,KAAK,EAAE;AAAT;AAPmB,KAA9B;AASH,GAzBD;;AA0BA,MAAImC,UAAU,GAAG,CACb;AACArB,EAAAA,UAAU,CAACsB,OAFE,EAGb;AACA;AACAtB,EAAAA,UAAU,CAACuB,QALE,EAMb;AACA;AACAvB,EAAAA,UAAU,CAACwB,WARE,CAAjB;AAUA,MAAIZ,SAAS,GAAGb,IAAI,CAAC0B,EAAL,CAAQC,KAAR,CAAc3B,IAAd,EAAoBsB,UAApB,CAAhB;;AACAb,EAAAA,KAAK,CAACmB,eAAN,GAAwB,UAAUX,IAAV,EAAgB;AACpC,WAAOJ,SAAS,CAACgB,KAAV,CAAgBZ,IAAhB,CAAP;AACH,GAFD;;AAGA,MAAIa,EAAE,GAAGrB,KAAK,CAAChB,SAAf,CAhDuB,CAiDvB;;AACAqC,EAAAA,EAAE,CAACC,OAAH,GAAa,KAAb;;AACAD,EAAAA,EAAE,CAACE,QAAH,GAAc,UAAUC,IAAV,EAAgB;AAC1B,SAAKC,IAAL;AACA,WAAO1C,MAAM,CAAC2C,IAAP,CAAY,KAAKd,QAAjB,EAA2BY,IAA3B,CAAP;AACH,GAHD;;AAIAH,EAAAA,EAAE,CAACM,YAAH,GAAkB,UAAUH,IAAV,EAAgB;AAC9B,SAAKC,IAAL;AACA,WAAO1C,MAAM,CAAC2C,IAAP,CAAY,KAAKtC,KAAjB,EAAwBoC,IAAxB,CAAP;AACH,GAHD;;AAIAH,EAAAA,EAAE,CAACO,gBAAH,GAAsB,UAAUC,MAAV,EAAkB;AACpC,QAAIA,MAAJ,EAAY;AACR,UAAI,CAAC,YAAYC,IAAZ,CAAiBD,MAAjB,CAAL,EAA+B;AAC3B,cAAM,IAAI1B,KAAJ,CAAU,EAAV,CAAN;AACH;AACJ,KAJD,MAKK;AACD0B,MAAAA,MAAM,GAAG,IAAT;AACH,KARmC,CASpC;AACA;;;AACAA,IAAAA,MAAM,IAAI,KAAKvB,KAAL,CAAWyB,QAAX,CAAoB,EAApB,IAA0B,GAApC;AACA,SAAKN,IAAL;AACA,QAAIO,KAAK,GAAG,CAAZ;;AACA,WAAO,KAAKT,QAAL,CAAcM,MAAM,GAAGG,KAAvB,CAAP,EAAsC;AAClC,QAAEA,KAAF;AACH;;AACD,QAAIR,IAAI,GAAGK,MAAM,GAAGG,KAApB;AACA,WAAO,KAAKpB,QAAL,CAAcY,IAAd,IAAsBpC,KAAK,CAACW,QAAN,CAAekC,UAAf,CAA0BT,IAA1B,CAA7B;AACH,GAnBD;;AAoBAH,EAAAA,EAAE,CAACa,eAAH,GAAqB,UAAUD,UAAV,EAAsBE,IAAtB,EAA4B;AAC7CF,IAAAA,UAAU,KAAKA,UAAU,GAAG,KAAKL,gBAAL,EAAlB,CAAV;AACA,QAAIQ,QAAQ,GAAG,KAAKnC,IAAL,CAAUoC,GAAV,CAAc,MAAd,CAAf;;AACA,QAAI7C,UAAU,CAAC8C,cAAX,CAA0BlB,KAA1B,CAAgCgB,QAAQ,CAAC1D,KAAzC,CAAJ,EAAqD;AACjD0D,MAAAA,QAAQ,GAAGA,QAAQ,CAACC,GAAT,CAAa,MAAb,CAAX;AACH;;AACDD,IAAAA,QAAQ,CAACG,OAAT,CAAiBzC,CAAC,CAAC0C,mBAAF,CAAsB,KAAtB,EAA6B,CAAC1C,CAAC,CAAC2C,kBAAF,CAAqBR,UAArB,EAAiCE,IAAI,IAAI,IAAzC,CAAD,CAA7B,CAAjB;AACA,WAAOF,UAAP;AACH,GARD;;AASAZ,EAAAA,EAAE,CAACI,IAAH,GAAU,UAAUiB,KAAV,EAAiB;AACvB,QAAIA,KAAK,IAAI,CAAC,KAAKpB,OAAnB,EAA4B;AACxB,WAAK,IAAIE,IAAT,IAAiB,KAAKZ,QAAtB,EAAgC;AAC5B;AACA,eAAO,KAAKA,QAAL,CAAcY,IAAd,CAAP;AACH;;AACDmB,MAAAA,SAAS,CAAC,KAAK1C,IAAN,EAAY,KAAKW,QAAjB,EAA2B,KAAKxB,KAAhC,CAAT;AACA,WAAKkC,OAAL,GAAe,IAAf;AACH;AACJ,GATD;;AAUAD,EAAAA,EAAE,CAACuB,WAAH,GAAiB,YAAY;AACzB,SAAKnB,IAAL;AACA,WAAO,KAAKb,QAAZ;AACH,GAHD;;AAIAS,EAAAA,EAAE,CAACwB,QAAH,GAAc,YAAY;AACtB,SAAKpB,IAAL;AACA,WAAO,KAAKrC,KAAZ;AACH,GAHD;;AAIA,WAASuD,SAAT,CAAmB1C,IAAnB,EAAyBW,QAAzB,EAAmCC,UAAnC,EAA+C;AAC3C,QAAIL,IAAI,GAAGP,IAAI,CAACvB,KAAhB;AACA0B,IAAAA,SAAS,CAACC,MAAV,CAAiBG,IAAjB;;AACA,QAAIhB,UAAU,CAACwB,WAAX,CAAuBI,KAAvB,CAA6BZ,IAA7B,CAAJ,EAAwC;AACpC;AACA;AACA;AACA,UAAIsC,KAAK,GAAG7C,IAAI,CAACoC,GAAL,CAAS,OAAT,CAAZ;;AACA,UAAIS,KAAK,CAACpE,KAAV,EAAiB;AACbqE,QAAAA,UAAU,CAACD,KAAD,EAAQlC,QAAR,CAAV;AACH;AACJ,KARD,MASK;AACDoC,MAAAA,kBAAkB,CAAC/C,IAAD,EAAOW,QAAP,EAAiBC,UAAjB,CAAlB;AACH;AACJ;;AACD,WAASmC,kBAAT,CAA4B/C,IAA5B,EAAkCW,QAAlC,EAA4CC,UAA5C,EAAwD;AACpD,QAAIL,IAAI,GAAGP,IAAI,CAACvB,KAAhB;;AACA,QAAIuB,IAAI,CAACU,MAAL,IACAnB,UAAU,CAACyD,kBAAX,CAA8B7B,KAA9B,CAAoCnB,IAAI,CAACU,MAAL,CAAYH,IAAhD,CADA,IAEAP,IAAI,CAACU,MAAL,CAAYH,IAAZ,CAAiB0C,EAFrB,EAEyB;AACrBH,MAAAA,UAAU,CAAC9C,IAAI,CAACU,MAAL,CAAY0B,GAAZ,CAAgB,IAAhB,CAAD,EAAwBzB,QAAxB,CAAV;AACH;;AACD,QAAI,CAACJ,IAAL,EAAW,CACP;AACH,KAFD,MAGK,IAAIb,OAAO,CAACyB,KAAR,CAAcZ,IAAd,CAAJ,EAAyB;AAC1BP,MAAAA,IAAI,CAACkD,IAAL,CAAU,UAAUC,SAAV,EAAqB;AAC3BC,QAAAA,kBAAkB,CAACD,SAAD,EAAYxC,QAAZ,EAAsBC,UAAtB,CAAlB;AACH,OAFD;AAGH,KAJI,MAKA,IAAIrB,UAAU,CAACuB,QAAX,CAAoBK,KAApB,CAA0BZ,IAA1B,CAAJ,EAAqC;AACtCP,MAAAA,IAAI,CAACoC,GAAL,CAAS,QAAT,EAAmBc,IAAnB,CAAwB,UAAUG,SAAV,EAAqB;AACzCP,QAAAA,UAAU,CAACO,SAAD,EAAY1C,QAAZ,CAAV;AACH,OAFD;AAGAyC,MAAAA,kBAAkB,CAACpD,IAAI,CAACoC,GAAL,CAAS,MAAT,CAAD,EAAmBzB,QAAnB,EAA6BC,UAA7B,CAAlB;AACH,KALI,MAMA,IAAKrB,UAAU,CAAC+D,SAAX,IAAwB/D,UAAU,CAAC+D,SAAX,CAAqBnC,KAArB,CAA2BZ,IAA3B,CAAzB,IACJhB,UAAU,CAACgE,oBAAX,IAAmChE,UAAU,CAACgE,oBAAX,CAAgCpC,KAAhC,CAAsCZ,IAAtC,CAD/B,IAEJhB,UAAU,CAACiE,sBAAX,IAAqCjE,UAAU,CAACiE,sBAAX,CAAkCrC,KAAlC,CAAwCZ,IAAxC,CAFjC,IAGJhB,UAAU,CAACkE,sBAAX,IAAqClE,UAAU,CAACkE,sBAAX,CAAkCtC,KAAlC,CAAwCZ,IAAxC,CAHrC,EAGqF;AACtFmD,MAAAA,cAAc,CAAC1D,IAAI,CAACoC,GAAL,CAAS,IAAT,CAAD,EAAiBxB,UAAjB,CAAd;AACH,KALI,MAMA,IAAIrB,UAAU,CAACoE,kBAAX,CAA8BxC,KAA9B,CAAoCZ,IAApC,CAAJ,EAA+C;AAChDuC,MAAAA,UAAU,CAAC9C,IAAI,CAACoC,GAAL,CAAS,IAAT,CAAD,EAAiBzB,QAAjB,CAAV;AACAyC,MAAAA,kBAAkB,CAACpD,IAAI,CAACoC,GAAL,CAAS,MAAT,CAAD,EAAmBzB,QAAnB,EAA6BC,UAA7B,CAAlB;AACH,KAHI,MAIA,IAAIL,IAAI,CAACqD,IAAL,KAAc,iBAAd,IACLrD,IAAI,CAACqD,IAAL,KAAc,0BADT,IAELrD,IAAI,CAACqD,IAAL,KAAc,wBAFb,EAEuC;AACxCd,MAAAA,UAAU,EACV;AACA;AACA;AACA;AACA9C,MAAAA,IAAI,CAACoC,GAAL,CAAS7B,IAAI,CAACsD,KAAL,GAAa,OAAb,GACLtD,IAAI,CAACgB,IAAL,GAAY,MAAZ,GAAqB,IADzB,CALU,EAMsBZ,QANtB,CAAV;AAOH,KAVI,MAWA,IAAInB,IAAI,CAAC2B,KAAL,CAAWZ,IAAX,KAAoB,CAACd,UAAU,CAAC0B,KAAX,CAAiBZ,IAAjB,CAAzB,EAAiD;AAClDpB,MAAAA,KAAK,CAAC2E,SAAN,CAAgBvD,IAAhB,EAAsB,UAAUgB,IAAV,EAAgBwC,KAAhB,EAAuB;AACzC,YAAIZ,SAAS,GAAGnD,IAAI,CAACoC,GAAL,CAASb,IAAT,CAAhB;;AACA,YAAI,CAACyC,YAAY,CAACb,SAAD,EAAYY,KAAZ,CAAjB,EAAqC;AACjC,gBAAM,IAAI7D,KAAJ,CAAU,EAAV,CAAN;AACH;;AACDkD,QAAAA,kBAAkB,CAACD,SAAD,EAAYxC,QAAZ,EAAsBC,UAAtB,CAAlB;AACH,OAND;AAOH;AACJ;;AACD,WAASoD,YAAT,CAAsBhE,IAAtB,EAA4BvB,KAA5B,EAAmC;AAC/B,QAAIuB,IAAI,CAACvB,KAAL,KAAeA,KAAnB,EAA0B;AACtB,aAAO,IAAP;AACH,KAH8B,CAI/B;AACA;;;AACA,QAAIwF,KAAK,CAACvE,OAAN,CAAcM,IAAI,CAACvB,KAAnB,KACAuB,IAAI,CAACvB,KAAL,CAAWyF,MAAX,KAAsB,CADtB,IAEAD,KAAK,CAACvE,OAAN,CAAcjB,KAAd,CAFA,IAGAA,KAAK,CAACyF,MAAN,KAAiB,CAHrB,EAGwB;AACpB,aAAO,IAAP;AACH;;AACD,WAAO,KAAP;AACH;;AACD,WAASd,kBAAT,CAA4BpD,IAA5B,EAAkCW,QAAlC,EAA4CC,UAA5C,EAAwD;AACpD,QAAIL,IAAI,GAAGP,IAAI,CAACvB,KAAhB;;AACA,QAAI,CAAC8B,IAAD,IAASd,UAAU,CAAC0B,KAAX,CAAiBZ,IAAjB,CAAb,EAAqC,CACjC;AACH,KAFD,MAGK,IAAIhB,UAAU,CAAC4E,mBAAX,CAA+BhD,KAA/B,CAAqCZ,IAArC,KACLA,IAAI,CAAC0C,EAAL,KAAY,IADX,EACiB;AAClBH,MAAAA,UAAU,CAAC9C,IAAI,CAACoC,GAAL,CAAS,IAAT,CAAD,EAAiBzB,QAAjB,CAAV;AACH,KAHI,MAIA,IAAIpB,UAAU,CAAC6E,gBAAX,IACL7E,UAAU,CAAC6E,gBAAX,CAA4BjD,KAA5B,CAAkCZ,IAAlC,CADC,EACwC;AACzCuC,MAAAA,UAAU,CAAC9C,IAAI,CAACoC,GAAL,CAAS,IAAT,CAAD,EAAiBzB,QAAjB,CAAV;AACH,KAHI,MAIA,IAAIR,SAAS,CAACgB,KAAV,CAAgBZ,IAAhB,CAAJ,EAA2B;AAC5B,UAAIhB,UAAU,CAACwB,WAAX,CAAuBI,KAAvB,CAA6BZ,IAA7B,KACA;AACAhB,MAAAA,UAAU,CAAC8E,UAAX,CAAsBlD,KAAtB,CAA4BZ,IAAI,CAACsC,KAAjC,CAFJ,EAE6C;AACzC,YAAIyB,cAAc,GAAG/D,IAAI,CAACsC,KAAL,CAAWtB,IAAhC;AACA,YAAIgD,UAAU,GAAGzF,MAAM,CAAC2C,IAAP,CAAYd,QAAZ,EAAsB2D,cAAtB,CAAjB,CAFyC,CAGzC;AACA;AACA;;AACAvB,QAAAA,kBAAkB,CAAC/C,IAAI,CAACoC,GAAL,CAAS,MAAT,CAAD,EAAmBzB,QAAnB,EAA6BC,UAA7B,CAAlB,CANyC,CAOzC;AACA;AACA;AACA;;AACA,YAAI,CAAC2D,UAAL,EAAiB;AACb,iBAAO5D,QAAQ,CAAC2D,cAAD,CAAf;AACH;AACJ;AACJ,KAlBI,MAmBA;AACDvB,MAAAA,kBAAkB,CAAC/C,IAAD,EAAOW,QAAP,EAAiBC,UAAjB,CAAlB;AACH;AACJ;;AACD,WAASkC,UAAT,CAAoB0B,WAApB,EAAiC7D,QAAjC,EAA2C;AACvC,QAAI8D,OAAO,GAAGD,WAAW,CAAC/F,KAA1B;AACAc,IAAAA,UAAU,CAACmF,OAAX,CAAmBtE,MAAnB,CAA0BqE,OAA1B;;AACA,QAAIlF,UAAU,CAAC8E,UAAX,CAAsBlD,KAAtB,CAA4BsD,OAA5B,CAAJ,EAA0C;AACtC,UAAI3F,MAAM,CAAC2C,IAAP,CAAYd,QAAZ,EAAsB8D,OAAO,CAAClD,IAA9B,CAAJ,EAAyC;AACrCZ,QAAAA,QAAQ,CAAC8D,OAAO,CAAClD,IAAT,CAAR,CAAuBoD,IAAvB,CAA4BH,WAA5B;AACH,OAFD,MAGK;AACD7D,QAAAA,QAAQ,CAAC8D,OAAO,CAAClD,IAAT,CAAR,GAAyB,CAACiD,WAAD,CAAzB;AACH;AACJ,KAPD,MAQK,IAAIjF,UAAU,CAACqF,iBAAX,IACLrF,UAAU,CAACqF,iBAAX,CAA6BzD,KAA7B,CAAmCsD,OAAnC,CADC,EAC4C;AAC7C3B,MAAAA,UAAU,CAAC0B,WAAW,CAACpC,GAAZ,CAAgB,MAAhB,CAAD,EAA0BzB,QAA1B,CAAV;AACH,KAHI,MAIA,IAAIpB,UAAU,CAACsF,aAAX,IACLtF,UAAU,CAACsF,aAAX,CAAyB1D,KAAzB,CAA+BsD,OAA/B,CADC,EACwC;AACzCD,MAAAA,WAAW,CAACpC,GAAZ,CAAgB,YAAhB,EAA8Bc,IAA9B,CAAmC,UAAU4B,YAAV,EAAwB;AACvD,YAAIC,QAAQ,GAAGD,YAAY,CAACrG,KAA5B;;AACA,YAAIc,UAAU,CAACmF,OAAX,CAAmBvD,KAAnB,CAAyB4D,QAAzB,CAAJ,EAAwC;AACpCjC,UAAAA,UAAU,CAACgC,YAAD,EAAenE,QAAf,CAAV;AACH,SAFD,MAGK,IAAIpB,UAAU,CAACyF,QAAX,CAAoB7D,KAApB,CAA0B4D,QAA1B,CAAJ,EAAyC;AAC1CjC,UAAAA,UAAU,CAACgC,YAAY,CAAC1C,GAAb,CAAiB,OAAjB,CAAD,EAA4BzB,QAA5B,CAAV;AACH,SAFI,MAGA,IAAIpB,UAAU,CAAC0F,cAAX,IACL1F,UAAU,CAAC0F,cAAX,CAA0B9D,KAA1B,CAAgC4D,QAAhC,CADC,EAC0C;AAC3CjC,UAAAA,UAAU,CAACgC,YAAY,CAAC1C,GAAb,CAAiB,UAAjB,CAAD,EAA+BzB,QAA/B,CAAV;AACH;AACJ,OAZD;AAaH,KAfI,MAgBA,IAAIpB,UAAU,CAAC2F,YAAX,IACL3F,UAAU,CAAC2F,YAAX,CAAwB/D,KAAxB,CAA8BsD,OAA9B,CADC,EACuC;AACxCD,MAAAA,WAAW,CAACpC,GAAZ,CAAgB,UAAhB,EAA4Bc,IAA5B,CAAiC,UAAUiC,WAAV,EAAuB;AACpD,YAAIC,OAAO,GAAGD,WAAW,CAAC1G,KAA1B;;AACA,YAAIc,UAAU,CAACmF,OAAX,CAAmBvD,KAAnB,CAAyBiE,OAAzB,CAAJ,EAAuC;AACnCtC,UAAAA,UAAU,CAACqC,WAAD,EAAcxE,QAAd,CAAV;AACH,SAFD,MAGK,IAAIpB,UAAU,CAAC8F,aAAX,IACL9F,UAAU,CAAC8F,aAAX,CAAyBlE,KAAzB,CAA+BiE,OAA/B,CADC,EACwC;AACzCtC,UAAAA,UAAU,CAACqC,WAAW,CAAC/C,GAAZ,CAAgB,UAAhB,CAAD,EAA8BzB,QAA9B,CAAV;AACH;AACJ,OATD;AAUH,KAZI,MAaA,IAAIpB,UAAU,CAAC+F,eAAX,IACL/F,UAAU,CAAC+F,eAAX,CAA2BnE,KAA3B,CAAiCsD,OAAjC,CADC,EAC0C;AAC3C3B,MAAAA,UAAU,CAAC0B,WAAW,CAACpC,GAAZ,CAAgB,SAAhB,CAAD,EAA6BzB,QAA7B,CAAV;AACH,KAHI,MAIA,IAAKpB,UAAU,CAACgG,oBAAX,IACNhG,UAAU,CAACgG,oBAAX,CAAgCpE,KAAhC,CAAsCsD,OAAtC,CADK,IAEJlF,UAAU,CAACiG,WAAX,IACGjG,UAAU,CAACiG,WAAX,CAAuBrE,KAAvB,CAA6BsD,OAA7B,CAHC,IAIJlF,UAAU,CAACkG,qBAAX,IACGlG,UAAU,CAACkG,qBAAX,CAAiCtE,KAAjC,CAAuCsD,OAAvC,CALH,EAKqD;AACtD3B,MAAAA,UAAU,CAAC0B,WAAW,CAACpC,GAAZ,CAAgB,UAAhB,CAAD,EAA8BzB,QAA9B,CAAV;AACH;AACJ;;AACD,WAAS+C,cAAT,CAAwBc,WAAxB,EAAqCrF,KAArC,EAA4C;AACxC,QAAIsF,OAAO,GAAGD,WAAW,CAAC/F,KAA1B;AACAc,IAAAA,UAAU,CAACmF,OAAX,CAAmBtE,MAAnB,CAA0BqE,OAA1B;;AACA,QAAIlF,UAAU,CAAC8E,UAAX,CAAsBlD,KAAtB,CAA4BsD,OAA5B,CAAJ,EAA0C;AACtC,UAAI3F,MAAM,CAAC2C,IAAP,CAAYtC,KAAZ,EAAmBsF,OAAO,CAAClD,IAA3B,CAAJ,EAAsC;AAClCpC,QAAAA,KAAK,CAACsF,OAAO,CAAClD,IAAT,CAAL,CAAoBoD,IAApB,CAAyBH,WAAzB;AACH,OAFD,MAGK;AACDrF,QAAAA,KAAK,CAACsF,OAAO,CAAClD,IAAT,CAAL,GAAsB,CAACiD,WAAD,CAAtB;AACH;AACJ;AACJ;;AACDpD,EAAAA,EAAE,CAACsE,MAAH,GAAY,UAAUnE,IAAV,EAAgB;AACxB,SAAK,IAAIoE,KAAK,GAAG,IAAjB,EAAuBA,KAAvB,EAA8BA,KAAK,GAAGA,KAAK,CAACjF,MAA5C,EACI,IAAIiF,KAAK,CAACrE,QAAN,CAAeC,IAAf,CAAJ,EACI;;AACR,WAAOoE,KAAP;AACH,GALD;;AAMAvE,EAAAA,EAAE,CAACwE,UAAH,GAAgB,UAAUrE,IAAV,EAAgB;AAC5B,SAAK,IAAIoE,KAAK,GAAG,IAAjB,EAAuBA,KAAvB,EAA8BA,KAAK,GAAGA,KAAK,CAACjF,MAA5C,EACI,IAAIiF,KAAK,CAACjE,YAAN,CAAmBH,IAAnB,CAAJ,EACI;;AACR,WAAOoE,KAAP;AACH,GALD;;AAMAvE,EAAAA,EAAE,CAACyE,cAAH,GAAoB,YAAY;AAC5B,QAAIF,KAAK,GAAG,IAAZ;;AACA,WAAO,CAACA,KAAK,CAACnF,QAAd,EACImF,KAAK,GAAGA,KAAK,CAACjF,MAAd;;AACJ,WAAOiF,KAAP;AACH,GALD;;AAMA,SAAO5F,KAAP;AACH;;AACDvB,OAAO,CAACa,OAAR,GAAkBJ,WAAlB;AACA6G,MAAM,CAACtH,OAAP,GAAiBA,OAAO,CAAC,SAAD,CAAxB","sourcesContent":["\"use strict\";;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\nvar hasOwn = Object.prototype.hasOwnProperty;\nfunction scopePlugin(fork) {\n    var types = fork.use(types_1.default);\n    var Type = types.Type;\n    var namedTypes = types.namedTypes;\n    var Node = namedTypes.Node;\n    var Expression = namedTypes.Expression;\n    var isArray = types.builtInTypes.array;\n    var b = types.builders;\n    var Scope = function Scope(path, parentScope) {\n        if (!(this instanceof Scope)) {\n            throw new Error(\"Scope constructor cannot be invoked without 'new'\");\n        }\n        ScopeType.assert(path.value);\n        var depth;\n        if (parentScope) {\n            if (!(parentScope instanceof Scope)) {\n                throw new Error(\"\");\n            }\n            depth = parentScope.depth + 1;\n        }\n        else {\n            parentScope = null;\n            depth = 0;\n        }\n        Object.defineProperties(this, {\n            path: { value: path },\n            node: { value: path.value },\n            isGlobal: { value: !parentScope, enumerable: true },\n            depth: { value: depth },\n            parent: { value: parentScope },\n            bindings: { value: {} },\n            types: { value: {} },\n        });\n    };\n    var scopeTypes = [\n        // Program nodes introduce global scopes.\n        namedTypes.Program,\n        // Function is the supertype of FunctionExpression,\n        // FunctionDeclaration, ArrowExpression, etc.\n        namedTypes.Function,\n        // In case you didn't know, the caught parameter shadows any variable\n        // of the same name in an outer scope.\n        namedTypes.CatchClause\n    ];\n    var ScopeType = Type.or.apply(Type, scopeTypes);\n    Scope.isEstablishedBy = function (node) {\n        return ScopeType.check(node);\n    };\n    var Sp = Scope.prototype;\n    // Will be overridden after an instance lazily calls scanScope.\n    Sp.didScan = false;\n    Sp.declares = function (name) {\n        this.scan();\n        return hasOwn.call(this.bindings, name);\n    };\n    Sp.declaresType = function (name) {\n        this.scan();\n        return hasOwn.call(this.types, name);\n    };\n    Sp.declareTemporary = function (prefix) {\n        if (prefix) {\n            if (!/^[a-z$_]/i.test(prefix)) {\n                throw new Error(\"\");\n            }\n        }\n        else {\n            prefix = \"t$\";\n        }\n        // Include this.depth in the name to make sure the name does not\n        // collide with any variables in nested/enclosing scopes.\n        prefix += this.depth.toString(36) + \"$\";\n        this.scan();\n        var index = 0;\n        while (this.declares(prefix + index)) {\n            ++index;\n        }\n        var name = prefix + index;\n        return this.bindings[name] = types.builders.identifier(name);\n    };\n    Sp.injectTemporary = function (identifier, init) {\n        identifier || (identifier = this.declareTemporary());\n        var bodyPath = this.path.get(\"body\");\n        if (namedTypes.BlockStatement.check(bodyPath.value)) {\n            bodyPath = bodyPath.get(\"body\");\n        }\n        bodyPath.unshift(b.variableDeclaration(\"var\", [b.variableDeclarator(identifier, init || null)]));\n        return identifier;\n    };\n    Sp.scan = function (force) {\n        if (force || !this.didScan) {\n            for (var name in this.bindings) {\n                // Empty out this.bindings, just in cases.\n                delete this.bindings[name];\n            }\n            scanScope(this.path, this.bindings, this.types);\n            this.didScan = true;\n        }\n    };\n    Sp.getBindings = function () {\n        this.scan();\n        return this.bindings;\n    };\n    Sp.getTypes = function () {\n        this.scan();\n        return this.types;\n    };\n    function scanScope(path, bindings, scopeTypes) {\n        var node = path.value;\n        ScopeType.assert(node);\n        if (namedTypes.CatchClause.check(node)) {\n            // A catch clause establishes a new scope but the only variable\n            // bound in that scope is the catch parameter. Any other\n            // declarations create bindings in the outer scope.\n            var param = path.get(\"param\");\n            if (param.value) {\n                addPattern(param, bindings);\n            }\n        }\n        else {\n            recursiveScanScope(path, bindings, scopeTypes);\n        }\n    }\n    function recursiveScanScope(path, bindings, scopeTypes) {\n        var node = path.value;\n        if (path.parent &&\n            namedTypes.FunctionExpression.check(path.parent.node) &&\n            path.parent.node.id) {\n            addPattern(path.parent.get(\"id\"), bindings);\n        }\n        if (!node) {\n            // None of the remaining cases matter if node is falsy.\n        }\n        else if (isArray.check(node)) {\n            path.each(function (childPath) {\n                recursiveScanChild(childPath, bindings, scopeTypes);\n            });\n        }\n        else if (namedTypes.Function.check(node)) {\n            path.get(\"params\").each(function (paramPath) {\n                addPattern(paramPath, bindings);\n            });\n            recursiveScanChild(path.get(\"body\"), bindings, scopeTypes);\n        }\n        else if ((namedTypes.TypeAlias && namedTypes.TypeAlias.check(node)) ||\n            (namedTypes.InterfaceDeclaration && namedTypes.InterfaceDeclaration.check(node)) ||\n            (namedTypes.TSTypeAliasDeclaration && namedTypes.TSTypeAliasDeclaration.check(node)) ||\n            (namedTypes.TSInterfaceDeclaration && namedTypes.TSInterfaceDeclaration.check(node))) {\n            addTypePattern(path.get(\"id\"), scopeTypes);\n        }\n        else if (namedTypes.VariableDeclarator.check(node)) {\n            addPattern(path.get(\"id\"), bindings);\n            recursiveScanChild(path.get(\"init\"), bindings, scopeTypes);\n        }\n        else if (node.type === \"ImportSpecifier\" ||\n            node.type === \"ImportNamespaceSpecifier\" ||\n            node.type === \"ImportDefaultSpecifier\") {\n            addPattern(\n            // Esprima used to use the .name field to refer to the local\n            // binding identifier for ImportSpecifier nodes, but .id for\n            // ImportNamespaceSpecifier and ImportDefaultSpecifier nodes.\n            // ESTree/Acorn/ESpree use .local for all three node types.\n            path.get(node.local ? \"local\" :\n                node.name ? \"name\" : \"id\"), bindings);\n        }\n        else if (Node.check(node) && !Expression.check(node)) {\n            types.eachField(node, function (name, child) {\n                var childPath = path.get(name);\n                if (!pathHasValue(childPath, child)) {\n                    throw new Error(\"\");\n                }\n                recursiveScanChild(childPath, bindings, scopeTypes);\n            });\n        }\n    }\n    function pathHasValue(path, value) {\n        if (path.value === value) {\n            return true;\n        }\n        // Empty arrays are probably produced by defaults.emptyArray, in which\n        // case is makes sense to regard them as equivalent, if not ===.\n        if (Array.isArray(path.value) &&\n            path.value.length === 0 &&\n            Array.isArray(value) &&\n            value.length === 0) {\n            return true;\n        }\n        return false;\n    }\n    function recursiveScanChild(path, bindings, scopeTypes) {\n        var node = path.value;\n        if (!node || Expression.check(node)) {\n            // Ignore falsy values and Expressions.\n        }\n        else if (namedTypes.FunctionDeclaration.check(node) &&\n            node.id !== null) {\n            addPattern(path.get(\"id\"), bindings);\n        }\n        else if (namedTypes.ClassDeclaration &&\n            namedTypes.ClassDeclaration.check(node)) {\n            addPattern(path.get(\"id\"), bindings);\n        }\n        else if (ScopeType.check(node)) {\n            if (namedTypes.CatchClause.check(node) &&\n                // TODO Broaden this to accept any pattern.\n                namedTypes.Identifier.check(node.param)) {\n                var catchParamName = node.param.name;\n                var hadBinding = hasOwn.call(bindings, catchParamName);\n                // Any declarations that occur inside the catch body that do\n                // not have the same name as the catch parameter should count\n                // as bindings in the outer scope.\n                recursiveScanScope(path.get(\"body\"), bindings, scopeTypes);\n                // If a new binding matching the catch parameter name was\n                // created while scanning the catch body, ignore it because it\n                // actually refers to the catch parameter and not the outer\n                // scope that we're currently scanning.\n                if (!hadBinding) {\n                    delete bindings[catchParamName];\n                }\n            }\n        }\n        else {\n            recursiveScanScope(path, bindings, scopeTypes);\n        }\n    }\n    function addPattern(patternPath, bindings) {\n        var pattern = patternPath.value;\n        namedTypes.Pattern.assert(pattern);\n        if (namedTypes.Identifier.check(pattern)) {\n            if (hasOwn.call(bindings, pattern.name)) {\n                bindings[pattern.name].push(patternPath);\n            }\n            else {\n                bindings[pattern.name] = [patternPath];\n            }\n        }\n        else if (namedTypes.AssignmentPattern &&\n            namedTypes.AssignmentPattern.check(pattern)) {\n            addPattern(patternPath.get('left'), bindings);\n        }\n        else if (namedTypes.ObjectPattern &&\n            namedTypes.ObjectPattern.check(pattern)) {\n            patternPath.get('properties').each(function (propertyPath) {\n                var property = propertyPath.value;\n                if (namedTypes.Pattern.check(property)) {\n                    addPattern(propertyPath, bindings);\n                }\n                else if (namedTypes.Property.check(property)) {\n                    addPattern(propertyPath.get('value'), bindings);\n                }\n                else if (namedTypes.SpreadProperty &&\n                    namedTypes.SpreadProperty.check(property)) {\n                    addPattern(propertyPath.get('argument'), bindings);\n                }\n            });\n        }\n        else if (namedTypes.ArrayPattern &&\n            namedTypes.ArrayPattern.check(pattern)) {\n            patternPath.get('elements').each(function (elementPath) {\n                var element = elementPath.value;\n                if (namedTypes.Pattern.check(element)) {\n                    addPattern(elementPath, bindings);\n                }\n                else if (namedTypes.SpreadElement &&\n                    namedTypes.SpreadElement.check(element)) {\n                    addPattern(elementPath.get(\"argument\"), bindings);\n                }\n            });\n        }\n        else if (namedTypes.PropertyPattern &&\n            namedTypes.PropertyPattern.check(pattern)) {\n            addPattern(patternPath.get('pattern'), bindings);\n        }\n        else if ((namedTypes.SpreadElementPattern &&\n            namedTypes.SpreadElementPattern.check(pattern)) ||\n            (namedTypes.RestElement &&\n                namedTypes.RestElement.check(pattern)) ||\n            (namedTypes.SpreadPropertyPattern &&\n                namedTypes.SpreadPropertyPattern.check(pattern))) {\n            addPattern(patternPath.get('argument'), bindings);\n        }\n    }\n    function addTypePattern(patternPath, types) {\n        var pattern = patternPath.value;\n        namedTypes.Pattern.assert(pattern);\n        if (namedTypes.Identifier.check(pattern)) {\n            if (hasOwn.call(types, pattern.name)) {\n                types[pattern.name].push(patternPath);\n            }\n            else {\n                types[pattern.name] = [patternPath];\n            }\n        }\n    }\n    Sp.lookup = function (name) {\n        for (var scope = this; scope; scope = scope.parent)\n            if (scope.declares(name))\n                break;\n        return scope;\n    };\n    Sp.lookupType = function (name) {\n        for (var scope = this; scope; scope = scope.parent)\n            if (scope.declaresType(name))\n                break;\n        return scope;\n    };\n    Sp.getGlobalScope = function () {\n        var scope = this;\n        while (!scope.isGlobal)\n            scope = scope.parent;\n        return scope;\n    };\n    return Scope;\n}\nexports.default = scopePlugin;\nmodule.exports = exports[\"default\"];\n"]},"metadata":{},"sourceType":"script"}