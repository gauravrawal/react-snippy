{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nconst Collection = require('../Collection');\n\nconst NodeCollection = require('./Node');\n\nconst once = require('../utils/once');\n\nconst recast = require('recast');\n\nconst astNodesAreEquivalent = recast.types.astNodesAreEquivalent;\nconst b = recast.types.builders;\nvar types = recast.types.namedTypes;\nconst VariableDeclarator = recast.types.namedTypes.VariableDeclarator;\n/**\n* @mixin\n*/\n\nconst globalMethods = {\n  /**\n   * Finds all variable declarators, optionally filtered by name.\n   *\n   * @param {string} name\n   * @return {Collection}\n   */\n  findVariableDeclarators: function (name) {\n    const filter = name ? {\n      id: {\n        name: name\n      }\n    } : null;\n    return this.find(VariableDeclarator, filter);\n  }\n};\nconst filterMethods = {\n  /**\n   * Returns a function that returns true if the provided path is a variable\n   * declarator and requires one of the specified module names.\n   *\n   * @param {string|Array} names A module name or an array of module names\n   * @return {Function}\n   */\n  requiresModule: function (names) {\n    if (names && !Array.isArray(names)) {\n      names = [names];\n    }\n\n    const requireIdentifier = b.identifier('require');\n    return function (path) {\n      const node = path.value;\n\n      if (!VariableDeclarator.check(node) || !types.CallExpression.check(node.init) || !astNodesAreEquivalent(node.init.callee, requireIdentifier)) {\n        return false;\n      }\n\n      return !names || names.some(n => astNodesAreEquivalent(node.init.arguments[0], b.literal(n)));\n    };\n  }\n};\n/**\n* @mixin\n*/\n\nconst transformMethods = {\n  /**\n   * Renames a variable and all its occurrences.\n   *\n   * @param {string} newName\n   * @return {Collection}\n   */\n  renameTo: function (newName) {\n    // TODO: Include JSXElements\n    return this.forEach(function (path) {\n      const node = path.value;\n      const oldName = node.id.name;\n      const rootScope = path.scope;\n      const rootPath = rootScope.path;\n      Collection.fromPaths([rootPath]).find(types.Identifier, {\n        name: oldName\n      }).filter(function (path) {\n        // ignore non-variables\n        const parent = path.parent.node;\n\n        if (types.MemberExpression.check(parent) && parent.property === path.node && !parent.computed) {\n          // obj.oldName\n          return false;\n        }\n\n        if (types.Property.check(parent) && parent.key === path.node && !parent.computed) {\n          // { oldName: 3 }\n          return false;\n        }\n\n        if (types.MethodDefinition.check(parent) && parent.key === path.node && !parent.computed) {\n          // class A { oldName() {} }\n          return false;\n        }\n\n        if (types.ClassProperty.check(parent) && parent.key === path.node && !parent.computed) {\n          // class A { oldName = 3 }\n          return false;\n        }\n\n        if (types.JSXAttribute.check(parent) && parent.name === path.node && !parent.computed) {\n          // <Foo oldName={oldName} />\n          return false;\n        }\n\n        return true;\n      }).forEach(function (path) {\n        let scope = path.scope;\n\n        while (scope && scope !== rootScope) {\n          if (scope.declares(oldName)) {\n            return;\n          }\n\n          scope = scope.parent;\n        }\n\n        if (scope) {\n          // identifier must refer to declared variable\n          // It may look like we filtered out properties,\n          // but the filter only ignored property \"keys\", not \"value\"s\n          // In shorthand properties, \"key\" and \"value\" both have an\n          // Identifier with the same structure.\n          const parent = path.parent.node;\n\n          if (types.Property.check(parent) && parent.shorthand && !parent.method) {\n            path.parent.get('shorthand').replace(false);\n          }\n\n          path.get('name').replace(newName);\n        }\n      });\n    });\n  }\n};\n\nfunction register() {\n  NodeCollection.register();\n  Collection.registerMethods(globalMethods);\n  Collection.registerMethods(transformMethods, VariableDeclarator);\n}\n\nexports.register = once(register);\nexports.filters = filterMethods;","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/github/react-snippy/node_modules/jscodeshift/src/collections/VariableDeclarator.js"],"names":["Collection","require","NodeCollection","once","recast","astNodesAreEquivalent","types","b","builders","namedTypes","VariableDeclarator","globalMethods","findVariableDeclarators","name","filter","id","find","filterMethods","requiresModule","names","Array","isArray","requireIdentifier","identifier","path","node","value","check","CallExpression","init","callee","some","n","arguments","literal","transformMethods","renameTo","newName","forEach","oldName","rootScope","scope","rootPath","fromPaths","Identifier","parent","MemberExpression","property","computed","Property","key","MethodDefinition","ClassProperty","JSXAttribute","declares","shorthand","method","get","replace","register","registerMethods","exports","filters"],"mappings":"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","sourcesContent":["\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst Collection = require('../Collection');\nconst NodeCollection = require('./Node');\nconst once = require('../utils/once');\nconst recast = require('recast');\n\nconst astNodesAreEquivalent = recast.types.astNodesAreEquivalent;\nconst b = recast.types.builders;\nvar types = recast.types.namedTypes;\n\nconst VariableDeclarator = recast.types.namedTypes.VariableDeclarator;\n\n/**\n* @mixin\n*/\nconst globalMethods = {\n  /**\n   * Finds all variable declarators, optionally filtered by name.\n   *\n   * @param {string} name\n   * @return {Collection}\n   */\n  findVariableDeclarators: function(name) {\n    const filter = name ? {id: {name: name}} : null;\n    return this.find(VariableDeclarator, filter);\n  }\n};\n\nconst filterMethods = {\n  /**\n   * Returns a function that returns true if the provided path is a variable\n   * declarator and requires one of the specified module names.\n   *\n   * @param {string|Array} names A module name or an array of module names\n   * @return {Function}\n   */\n  requiresModule: function(names) {\n    if (names && !Array.isArray(names)) {\n      names = [names];\n    }\n    const requireIdentifier = b.identifier('require');\n    return function(path) {\n      const node = path.value;\n      if (!VariableDeclarator.check(node) ||\n          !types.CallExpression.check(node.init) ||\n          !astNodesAreEquivalent(node.init.callee, requireIdentifier)) {\n        return false;\n      }\n      return !names ||\n        names.some(\n          n => astNodesAreEquivalent(node.init.arguments[0], b.literal(n))\n        );\n    };\n  }\n};\n\n/**\n* @mixin\n*/\nconst transformMethods = {\n  /**\n   * Renames a variable and all its occurrences.\n   *\n   * @param {string} newName\n   * @return {Collection}\n   */\n  renameTo: function(newName) {\n    // TODO: Include JSXElements\n    return this.forEach(function(path) {\n      const node = path.value;\n      const oldName = node.id.name;\n      const rootScope = path.scope;\n      const rootPath = rootScope.path;\n      Collection.fromPaths([rootPath])\n        .find(types.Identifier, {name: oldName})\n        .filter(function(path) { // ignore non-variables\n          const parent = path.parent.node;\n\n          if (\n            types.MemberExpression.check(parent) &&\n            parent.property === path.node &&\n            !parent.computed\n          ) {\n            // obj.oldName\n            return false;\n          }\n\n          if (\n            types.Property.check(parent) &&\n            parent.key === path.node &&\n            !parent.computed\n          ) {\n            // { oldName: 3 }\n            return false;\n          }\n\n          if (\n            types.MethodDefinition.check(parent) &&\n            parent.key === path.node &&\n            !parent.computed\n          ) {\n            // class A { oldName() {} }\n            return false;\n          }\n\n          if (\n            types.ClassProperty.check(parent) &&\n            parent.key === path.node &&\n            !parent.computed\n          ) {\n            // class A { oldName = 3 }\n            return false;\n          }\n\n          if (\n            types.JSXAttribute.check(parent) &&\n            parent.name === path.node &&\n            !parent.computed\n          ) {\n            // <Foo oldName={oldName} />\n            return false;\n          }\n\n          return true;\n        })\n        .forEach(function(path) {\n          let scope = path.scope;\n          while (scope && scope !== rootScope) {\n            if (scope.declares(oldName)) {\n              return;\n            }\n            scope = scope.parent;\n          }\n          if (scope) { // identifier must refer to declared variable\n\n            // It may look like we filtered out properties,\n            // but the filter only ignored property \"keys\", not \"value\"s\n            // In shorthand properties, \"key\" and \"value\" both have an\n            // Identifier with the same structure.\n            const parent = path.parent.node;\n            if (\n              types.Property.check(parent) &&\n              parent.shorthand &&\n              !parent.method\n            )  {\n\n              path.parent.get('shorthand').replace(false);\n            }\n\n            path.get('name').replace(newName);\n          }\n        });\n    });\n  }\n};\n\n\nfunction register() {\n  NodeCollection.register();\n  Collection.registerMethods(globalMethods);\n  Collection.registerMethods(transformMethods, VariableDeclarator);\n}\n\nexports.register = once(register);\nexports.filters = filterMethods;\n"]},"metadata":{},"sourceType":"script"}