{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.printComments = exports.attach = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\n\nvar types = tslib_1.__importStar(require(\"ast-types\"));\n\nvar n = types.namedTypes;\nvar isArray = types.builtInTypes.array;\nvar isObject = types.builtInTypes.object;\n\nvar lines_1 = require(\"./lines\");\n\nvar util_1 = require(\"./util\");\n\nvar childNodesCache = new WeakMap(); // TODO Move a non-caching implementation of this function into ast-types,\n// and implement a caching wrapper function here.\n\nfunction getSortedChildNodes(node, lines, resultArray) {\n  if (!node) {\n    return resultArray;\n  } // The .loc checks below are sensitive to some of the problems that\n  // are fixed by this utility function. Specifically, if it decides to\n  // set node.loc to null, indicating that the node's .loc information\n  // is unreliable, then we don't want to add node to the resultArray.\n\n\n  util_1.fixFaultyLocations(node, lines);\n\n  if (resultArray) {\n    if (n.Node.check(node) && n.SourceLocation.check(node.loc)) {\n      // This reverse insertion sort almost always takes constant\n      // time because we almost always (maybe always?) append the\n      // nodes in order anyway.\n      var i = resultArray.length - 1;\n\n      for (; i >= 0; --i) {\n        var child = resultArray[i];\n\n        if (child && child.loc && util_1.comparePos(child.loc.end, node.loc.start) <= 0) {\n          break;\n        }\n      }\n\n      resultArray.splice(i + 1, 0, node);\n      return resultArray;\n    }\n  } else {\n    var childNodes = childNodesCache.get(node);\n\n    if (childNodes) {\n      return childNodes;\n    }\n  }\n\n  var names;\n\n  if (isArray.check(node)) {\n    names = Object.keys(node);\n  } else if (isObject.check(node)) {\n    names = types.getFieldNames(node);\n  } else {\n    return resultArray;\n  }\n\n  if (!resultArray) {\n    childNodesCache.set(node, resultArray = []);\n  }\n\n  for (var i = 0, nameCount = names.length; i < nameCount; ++i) {\n    getSortedChildNodes(node[names[i]], lines, resultArray);\n  }\n\n  return resultArray;\n} // As efficiently as possible, decorate the comment object with\n// .precedingNode, .enclosingNode, and/or .followingNode properties, at\n// least one of which is guaranteed to be defined.\n\n\nfunction decorateComment(node, comment, lines) {\n  var childNodes = getSortedChildNodes(node, lines); // Time to dust off the old binary search robes and wizard hat.\n\n  var left = 0;\n  var right = childNodes && childNodes.length;\n  var precedingNode;\n  var followingNode;\n\n  while (typeof right === \"number\" && left < right) {\n    var middle = left + right >> 1;\n    var child = childNodes[middle];\n\n    if (util_1.comparePos(child.loc.start, comment.loc.start) <= 0 && util_1.comparePos(comment.loc.end, child.loc.end) <= 0) {\n      // The comment is completely contained by this child node.\n      decorateComment(comment.enclosingNode = child, comment, lines);\n      return; // Abandon the binary search at this level.\n    }\n\n    if (util_1.comparePos(child.loc.end, comment.loc.start) <= 0) {\n      // This child node falls completely before the comment.\n      // Because we will never consider this node or any nodes\n      // before it again, this node must be the closest preceding\n      // node we have encountered so far.\n      precedingNode = child;\n      left = middle + 1;\n      continue;\n    }\n\n    if (util_1.comparePos(comment.loc.end, child.loc.start) <= 0) {\n      // This child node falls completely after the comment.\n      // Because we will never consider this node or any nodes after\n      // it again, this node must be the closest following node we\n      // have encountered so far.\n      followingNode = child;\n      right = middle;\n      continue;\n    }\n\n    throw new Error(\"Comment location overlaps with node location\");\n  }\n\n  if (precedingNode) {\n    comment.precedingNode = precedingNode;\n  }\n\n  if (followingNode) {\n    comment.followingNode = followingNode;\n  }\n}\n\nfunction attach(comments, ast, lines) {\n  if (!isArray.check(comments)) {\n    return;\n  }\n\n  var tiesToBreak = [];\n  comments.forEach(function (comment) {\n    comment.loc.lines = lines;\n    decorateComment(ast, comment, lines);\n    var pn = comment.precedingNode;\n    var en = comment.enclosingNode;\n    var fn = comment.followingNode;\n\n    if (pn && fn) {\n      var tieCount = tiesToBreak.length;\n\n      if (tieCount > 0) {\n        var lastTie = tiesToBreak[tieCount - 1];\n        assert_1.default.strictEqual(lastTie.precedingNode === comment.precedingNode, lastTie.followingNode === comment.followingNode);\n\n        if (lastTie.followingNode !== comment.followingNode) {\n          breakTies(tiesToBreak, lines);\n        }\n      }\n\n      tiesToBreak.push(comment);\n    } else if (pn) {\n      // No contest: we have a trailing comment.\n      breakTies(tiesToBreak, lines);\n      addTrailingComment(pn, comment);\n    } else if (fn) {\n      // No contest: we have a leading comment.\n      breakTies(tiesToBreak, lines);\n      addLeadingComment(fn, comment);\n    } else if (en) {\n      // The enclosing node has no child nodes at all, so what we\n      // have here is a dangling comment, e.g. [/* crickets */].\n      breakTies(tiesToBreak, lines);\n      addDanglingComment(en, comment);\n    } else {\n      throw new Error(\"AST contains no nodes at all?\");\n    }\n  });\n  breakTies(tiesToBreak, lines);\n  comments.forEach(function (comment) {\n    // These node references were useful for breaking ties, but we\n    // don't need them anymore, and they create cycles in the AST that\n    // may lead to infinite recursion if we don't delete them here.\n    delete comment.precedingNode;\n    delete comment.enclosingNode;\n    delete comment.followingNode;\n  });\n}\n\nexports.attach = attach;\n\nfunction breakTies(tiesToBreak, lines) {\n  var tieCount = tiesToBreak.length;\n\n  if (tieCount === 0) {\n    return;\n  }\n\n  var pn = tiesToBreak[0].precedingNode;\n  var fn = tiesToBreak[0].followingNode;\n  var gapEndPos = fn.loc.start; // Iterate backwards through tiesToBreak, examining the gaps\n  // between the tied comments. In order to qualify as leading, a\n  // comment must be separated from fn by an unbroken series of\n  // whitespace-only gaps (or other comments).\n\n  var indexOfFirstLeadingComment = tieCount;\n  var comment;\n\n  for (; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {\n    comment = tiesToBreak[indexOfFirstLeadingComment - 1];\n    assert_1.default.strictEqual(comment.precedingNode, pn);\n    assert_1.default.strictEqual(comment.followingNode, fn);\n    var gap = lines.sliceString(comment.loc.end, gapEndPos);\n\n    if (/\\S/.test(gap)) {\n      // The gap string contained something other than whitespace.\n      break;\n    }\n\n    gapEndPos = comment.loc.start;\n  }\n\n  while (indexOfFirstLeadingComment <= tieCount && (comment = tiesToBreak[indexOfFirstLeadingComment]) && ( // If the comment is a //-style comment and indented more\n  // deeply than the node itself, reconsider it as trailing.\n  comment.type === \"Line\" || comment.type === \"CommentLine\") && comment.loc.start.column > fn.loc.start.column) {\n    ++indexOfFirstLeadingComment;\n  }\n\n  tiesToBreak.forEach(function (comment, i) {\n    if (i < indexOfFirstLeadingComment) {\n      addTrailingComment(pn, comment);\n    } else {\n      addLeadingComment(fn, comment);\n    }\n  });\n  tiesToBreak.length = 0;\n}\n\nfunction addCommentHelper(node, comment) {\n  var comments = node.comments || (node.comments = []);\n  comments.push(comment);\n}\n\nfunction addLeadingComment(node, comment) {\n  comment.leading = true;\n  comment.trailing = false;\n  addCommentHelper(node, comment);\n}\n\nfunction addDanglingComment(node, comment) {\n  comment.leading = false;\n  comment.trailing = false;\n  addCommentHelper(node, comment);\n}\n\nfunction addTrailingComment(node, comment) {\n  comment.leading = false;\n  comment.trailing = true;\n  addCommentHelper(node, comment);\n}\n\nfunction printLeadingComment(commentPath, print) {\n  var comment = commentPath.getValue();\n  n.Comment.assert(comment);\n  var loc = comment.loc;\n  var lines = loc && loc.lines;\n  var parts = [print(commentPath)];\n\n  if (comment.trailing) {\n    // When we print trailing comments as leading comments, we don't\n    // want to bring any trailing spaces along.\n    parts.push(\"\\n\");\n  } else if (lines instanceof lines_1.Lines) {\n    var trailingSpace = lines.slice(loc.end, lines.skipSpaces(loc.end) || lines.lastPos());\n\n    if (trailingSpace.length === 1) {\n      // If the trailing space contains no newlines, then we want to\n      // preserve it exactly as we found it.\n      parts.push(trailingSpace);\n    } else {\n      // If the trailing space contains newlines, then replace it\n      // with just that many newlines, with all other spaces removed.\n      parts.push(new Array(trailingSpace.length).join(\"\\n\"));\n    }\n  } else {\n    parts.push(\"\\n\");\n  }\n\n  return lines_1.concat(parts);\n}\n\nfunction printTrailingComment(commentPath, print) {\n  var comment = commentPath.getValue(commentPath);\n  n.Comment.assert(comment);\n  var loc = comment.loc;\n  var lines = loc && loc.lines;\n  var parts = [];\n\n  if (lines instanceof lines_1.Lines) {\n    var fromPos = lines.skipSpaces(loc.start, true) || lines.firstPos();\n    var leadingSpace = lines.slice(fromPos, loc.start);\n\n    if (leadingSpace.length === 1) {\n      // If the leading space contains no newlines, then we want to\n      // preserve it exactly as we found it.\n      parts.push(leadingSpace);\n    } else {\n      // If the leading space contains newlines, then replace it\n      // with just that many newlines, sans all other spaces.\n      parts.push(new Array(leadingSpace.length).join(\"\\n\"));\n    }\n  }\n\n  parts.push(print(commentPath));\n  return lines_1.concat(parts);\n}\n\nfunction printComments(path, print) {\n  var value = path.getValue();\n  var innerLines = print(path);\n  var comments = n.Node.check(value) && types.getFieldValue(value, \"comments\");\n\n  if (!comments || comments.length === 0) {\n    return innerLines;\n  }\n\n  var leadingParts = [];\n  var trailingParts = [innerLines];\n  path.each(function (commentPath) {\n    var comment = commentPath.getValue();\n    var leading = types.getFieldValue(comment, \"leading\");\n    var trailing = types.getFieldValue(comment, \"trailing\");\n\n    if (leading || trailing && !(n.Statement.check(value) || comment.type === \"Block\" || comment.type === \"CommentBlock\")) {\n      leadingParts.push(printLeadingComment(commentPath, print));\n    } else if (trailing) {\n      trailingParts.push(printTrailingComment(commentPath, print));\n    }\n  }, \"comments\");\n  leadingParts.push.apply(leadingParts, trailingParts);\n  return lines_1.concat(leadingParts);\n}\n\nexports.printComments = printComments;","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/github/react-snippy/node_modules/jscodeshift/node_modules/recast/lib/comments.js"],"names":["Object","defineProperty","exports","value","printComments","attach","tslib_1","require","assert_1","__importDefault","types","__importStar","n","namedTypes","isArray","builtInTypes","array","isObject","object","lines_1","util_1","childNodesCache","WeakMap","getSortedChildNodes","node","lines","resultArray","fixFaultyLocations","Node","check","SourceLocation","loc","i","length","child","comparePos","end","start","splice","childNodes","get","names","keys","getFieldNames","set","nameCount","decorateComment","comment","left","right","precedingNode","followingNode","middle","enclosingNode","Error","comments","ast","tiesToBreak","forEach","pn","en","fn","tieCount","lastTie","default","strictEqual","breakTies","push","addTrailingComment","addLeadingComment","addDanglingComment","gapEndPos","indexOfFirstLeadingComment","gap","sliceString","test","type","column","addCommentHelper","leading","trailing","printLeadingComment","commentPath","print","getValue","Comment","assert","parts","Lines","trailingSpace","slice","skipSpaces","lastPos","Array","join","concat","printTrailingComment","fromPos","firstPos","leadingSpace","path","innerLines","getFieldValue","leadingParts","trailingParts","each","Statement","apply"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.printComments = exports.attach = void 0;\nvar tslib_1 = require(\"tslib\");\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\nvar types = tslib_1.__importStar(require(\"ast-types\"));\nvar n = types.namedTypes;\nvar isArray = types.builtInTypes.array;\nvar isObject = types.builtInTypes.object;\nvar lines_1 = require(\"./lines\");\nvar util_1 = require(\"./util\");\nvar childNodesCache = new WeakMap();\n// TODO Move a non-caching implementation of this function into ast-types,\n// and implement a caching wrapper function here.\nfunction getSortedChildNodes(node, lines, resultArray) {\n    if (!node) {\n        return resultArray;\n    }\n    // The .loc checks below are sensitive to some of the problems that\n    // are fixed by this utility function. Specifically, if it decides to\n    // set node.loc to null, indicating that the node's .loc information\n    // is unreliable, then we don't want to add node to the resultArray.\n    util_1.fixFaultyLocations(node, lines);\n    if (resultArray) {\n        if (n.Node.check(node) && n.SourceLocation.check(node.loc)) {\n            // This reverse insertion sort almost always takes constant\n            // time because we almost always (maybe always?) append the\n            // nodes in order anyway.\n            var i = resultArray.length - 1;\n            for (; i >= 0; --i) {\n                var child = resultArray[i];\n                if (child &&\n                    child.loc &&\n                    util_1.comparePos(child.loc.end, node.loc.start) <= 0) {\n                    break;\n                }\n            }\n            resultArray.splice(i + 1, 0, node);\n            return resultArray;\n        }\n    }\n    else {\n        var childNodes = childNodesCache.get(node);\n        if (childNodes) {\n            return childNodes;\n        }\n    }\n    var names;\n    if (isArray.check(node)) {\n        names = Object.keys(node);\n    }\n    else if (isObject.check(node)) {\n        names = types.getFieldNames(node);\n    }\n    else {\n        return resultArray;\n    }\n    if (!resultArray) {\n        childNodesCache.set(node, (resultArray = []));\n    }\n    for (var i = 0, nameCount = names.length; i < nameCount; ++i) {\n        getSortedChildNodes(node[names[i]], lines, resultArray);\n    }\n    return resultArray;\n}\n// As efficiently as possible, decorate the comment object with\n// .precedingNode, .enclosingNode, and/or .followingNode properties, at\n// least one of which is guaranteed to be defined.\nfunction decorateComment(node, comment, lines) {\n    var childNodes = getSortedChildNodes(node, lines);\n    // Time to dust off the old binary search robes and wizard hat.\n    var left = 0;\n    var right = childNodes && childNodes.length;\n    var precedingNode;\n    var followingNode;\n    while (typeof right === \"number\" && left < right) {\n        var middle = (left + right) >> 1;\n        var child = childNodes[middle];\n        if (util_1.comparePos(child.loc.start, comment.loc.start) <= 0 &&\n            util_1.comparePos(comment.loc.end, child.loc.end) <= 0) {\n            // The comment is completely contained by this child node.\n            decorateComment((comment.enclosingNode = child), comment, lines);\n            return; // Abandon the binary search at this level.\n        }\n        if (util_1.comparePos(child.loc.end, comment.loc.start) <= 0) {\n            // This child node falls completely before the comment.\n            // Because we will never consider this node or any nodes\n            // before it again, this node must be the closest preceding\n            // node we have encountered so far.\n            precedingNode = child;\n            left = middle + 1;\n            continue;\n        }\n        if (util_1.comparePos(comment.loc.end, child.loc.start) <= 0) {\n            // This child node falls completely after the comment.\n            // Because we will never consider this node or any nodes after\n            // it again, this node must be the closest following node we\n            // have encountered so far.\n            followingNode = child;\n            right = middle;\n            continue;\n        }\n        throw new Error(\"Comment location overlaps with node location\");\n    }\n    if (precedingNode) {\n        comment.precedingNode = precedingNode;\n    }\n    if (followingNode) {\n        comment.followingNode = followingNode;\n    }\n}\nfunction attach(comments, ast, lines) {\n    if (!isArray.check(comments)) {\n        return;\n    }\n    var tiesToBreak = [];\n    comments.forEach(function (comment) {\n        comment.loc.lines = lines;\n        decorateComment(ast, comment, lines);\n        var pn = comment.precedingNode;\n        var en = comment.enclosingNode;\n        var fn = comment.followingNode;\n        if (pn && fn) {\n            var tieCount = tiesToBreak.length;\n            if (tieCount > 0) {\n                var lastTie = tiesToBreak[tieCount - 1];\n                assert_1.default.strictEqual(lastTie.precedingNode === comment.precedingNode, lastTie.followingNode === comment.followingNode);\n                if (lastTie.followingNode !== comment.followingNode) {\n                    breakTies(tiesToBreak, lines);\n                }\n            }\n            tiesToBreak.push(comment);\n        }\n        else if (pn) {\n            // No contest: we have a trailing comment.\n            breakTies(tiesToBreak, lines);\n            addTrailingComment(pn, comment);\n        }\n        else if (fn) {\n            // No contest: we have a leading comment.\n            breakTies(tiesToBreak, lines);\n            addLeadingComment(fn, comment);\n        }\n        else if (en) {\n            // The enclosing node has no child nodes at all, so what we\n            // have here is a dangling comment, e.g. [/* crickets */].\n            breakTies(tiesToBreak, lines);\n            addDanglingComment(en, comment);\n        }\n        else {\n            throw new Error(\"AST contains no nodes at all?\");\n        }\n    });\n    breakTies(tiesToBreak, lines);\n    comments.forEach(function (comment) {\n        // These node references were useful for breaking ties, but we\n        // don't need them anymore, and they create cycles in the AST that\n        // may lead to infinite recursion if we don't delete them here.\n        delete comment.precedingNode;\n        delete comment.enclosingNode;\n        delete comment.followingNode;\n    });\n}\nexports.attach = attach;\nfunction breakTies(tiesToBreak, lines) {\n    var tieCount = tiesToBreak.length;\n    if (tieCount === 0) {\n        return;\n    }\n    var pn = tiesToBreak[0].precedingNode;\n    var fn = tiesToBreak[0].followingNode;\n    var gapEndPos = fn.loc.start;\n    // Iterate backwards through tiesToBreak, examining the gaps\n    // between the tied comments. In order to qualify as leading, a\n    // comment must be separated from fn by an unbroken series of\n    // whitespace-only gaps (or other comments).\n    var indexOfFirstLeadingComment = tieCount;\n    var comment;\n    for (; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {\n        comment = tiesToBreak[indexOfFirstLeadingComment - 1];\n        assert_1.default.strictEqual(comment.precedingNode, pn);\n        assert_1.default.strictEqual(comment.followingNode, fn);\n        var gap = lines.sliceString(comment.loc.end, gapEndPos);\n        if (/\\S/.test(gap)) {\n            // The gap string contained something other than whitespace.\n            break;\n        }\n        gapEndPos = comment.loc.start;\n    }\n    while (indexOfFirstLeadingComment <= tieCount &&\n        (comment = tiesToBreak[indexOfFirstLeadingComment]) &&\n        // If the comment is a //-style comment and indented more\n        // deeply than the node itself, reconsider it as trailing.\n        (comment.type === \"Line\" || comment.type === \"CommentLine\") &&\n        comment.loc.start.column > fn.loc.start.column) {\n        ++indexOfFirstLeadingComment;\n    }\n    tiesToBreak.forEach(function (comment, i) {\n        if (i < indexOfFirstLeadingComment) {\n            addTrailingComment(pn, comment);\n        }\n        else {\n            addLeadingComment(fn, comment);\n        }\n    });\n    tiesToBreak.length = 0;\n}\nfunction addCommentHelper(node, comment) {\n    var comments = node.comments || (node.comments = []);\n    comments.push(comment);\n}\nfunction addLeadingComment(node, comment) {\n    comment.leading = true;\n    comment.trailing = false;\n    addCommentHelper(node, comment);\n}\nfunction addDanglingComment(node, comment) {\n    comment.leading = false;\n    comment.trailing = false;\n    addCommentHelper(node, comment);\n}\nfunction addTrailingComment(node, comment) {\n    comment.leading = false;\n    comment.trailing = true;\n    addCommentHelper(node, comment);\n}\nfunction printLeadingComment(commentPath, print) {\n    var comment = commentPath.getValue();\n    n.Comment.assert(comment);\n    var loc = comment.loc;\n    var lines = loc && loc.lines;\n    var parts = [print(commentPath)];\n    if (comment.trailing) {\n        // When we print trailing comments as leading comments, we don't\n        // want to bring any trailing spaces along.\n        parts.push(\"\\n\");\n    }\n    else if (lines instanceof lines_1.Lines) {\n        var trailingSpace = lines.slice(loc.end, lines.skipSpaces(loc.end) || lines.lastPos());\n        if (trailingSpace.length === 1) {\n            // If the trailing space contains no newlines, then we want to\n            // preserve it exactly as we found it.\n            parts.push(trailingSpace);\n        }\n        else {\n            // If the trailing space contains newlines, then replace it\n            // with just that many newlines, with all other spaces removed.\n            parts.push(new Array(trailingSpace.length).join(\"\\n\"));\n        }\n    }\n    else {\n        parts.push(\"\\n\");\n    }\n    return lines_1.concat(parts);\n}\nfunction printTrailingComment(commentPath, print) {\n    var comment = commentPath.getValue(commentPath);\n    n.Comment.assert(comment);\n    var loc = comment.loc;\n    var lines = loc && loc.lines;\n    var parts = [];\n    if (lines instanceof lines_1.Lines) {\n        var fromPos = lines.skipSpaces(loc.start, true) || lines.firstPos();\n        var leadingSpace = lines.slice(fromPos, loc.start);\n        if (leadingSpace.length === 1) {\n            // If the leading space contains no newlines, then we want to\n            // preserve it exactly as we found it.\n            parts.push(leadingSpace);\n        }\n        else {\n            // If the leading space contains newlines, then replace it\n            // with just that many newlines, sans all other spaces.\n            parts.push(new Array(leadingSpace.length).join(\"\\n\"));\n        }\n    }\n    parts.push(print(commentPath));\n    return lines_1.concat(parts);\n}\nfunction printComments(path, print) {\n    var value = path.getValue();\n    var innerLines = print(path);\n    var comments = n.Node.check(value) && types.getFieldValue(value, \"comments\");\n    if (!comments || comments.length === 0) {\n        return innerLines;\n    }\n    var leadingParts = [];\n    var trailingParts = [innerLines];\n    path.each(function (commentPath) {\n        var comment = commentPath.getValue();\n        var leading = types.getFieldValue(comment, \"leading\");\n        var trailing = types.getFieldValue(comment, \"trailing\");\n        if (leading ||\n            (trailing &&\n                !(n.Statement.check(value) ||\n                    comment.type === \"Block\" ||\n                    comment.type === \"CommentBlock\"))) {\n            leadingParts.push(printLeadingComment(commentPath, print));\n        }\n        else if (trailing) {\n            trailingParts.push(printTrailingComment(commentPath, print));\n        }\n    }, \"comments\");\n    leadingParts.push.apply(leadingParts, trailingParts);\n    return lines_1.concat(leadingParts);\n}\nexports.printComments = printComments;\n"]},"metadata":{},"sourceType":"script"}