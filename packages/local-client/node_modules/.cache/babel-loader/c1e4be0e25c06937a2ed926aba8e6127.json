{"ast":null,"code":"/* eslint-disable regexp/no-dupe-characters-character-class */\n(function (Prism) {\n  /**\n   * Regular expression for characters that are not allowed in identifiers.\n   *\n   * @type {string}\n   */\n  var nonId = /\\s\\x00-\\x1f\\x22-\\x2f\\x3a-\\x3f\\x5b-\\x5e\\x60\\x7b-\\x7e/.source;\n  /**\n   * Surround a regular expression for IDs with patterns for non-ID sequences.\n   *\n   * @param {string} pattern A regular expression for identifiers.\n   * @param {string} [flags] The regular expression flags.\n   * @returns {RegExp} A wrapped regular expression for identifiers.\n   */\n\n  function wrapId(pattern, flags) {\n    return RegExp(pattern.replace(/<nonId>/g, nonId), flags);\n  }\n\n  Prism.languages.kumir = {\n    'comment': {\n      pattern: /\\|.*/\n    },\n    'prolog': {\n      pattern: /#.*/,\n      greedy: true\n    },\n    'string': {\n      pattern: /\"[^\\n\\r\"]*\"|'[^\\n\\r']*'/,\n      greedy: true\n    },\n    'boolean': {\n      pattern: wrapId(/(^|[<nonId>])(?:да|нет)(?=[<nonId>]|$)/.source),\n      lookbehind: true\n    },\n    'operator-word': {\n      pattern: wrapId(/(^|[<nonId>])(?:и|или|не)(?=[<nonId>]|$)/.source),\n      lookbehind: true,\n      alias: 'keyword'\n    },\n    'system-variable': {\n      pattern: wrapId(/(^|[<nonId>])знач(?=[<nonId>]|$)/.source),\n      lookbehind: true,\n      alias: 'keyword'\n    },\n    'type': [{\n      pattern: wrapId(/(^|[<nonId>])(?:вещ|лит|лог|сим|цел)(?:\\x20*таб)?(?=[<nonId>]|$)/.source),\n      lookbehind: true,\n      alias: 'builtin'\n    }, {\n      pattern: wrapId(/(^|[<nonId>])(?:компл|сканкод|файл|цвет)(?=[<nonId>]|$)/.source),\n      lookbehind: true,\n      alias: 'important'\n    }],\n\n    /**\n     * Should be performed after searching for type names because of \"таб\".\n     * \"таб\" is a reserved word, but never used without a preceding type name.\n     * \"НАЗНАЧИТЬ\", \"Фввод\", and \"Фвывод\" are not reserved words.\n     */\n    'keyword': {\n      pattern: wrapId(/(^|[<nonId>])(?:алг|арг(?:\\x20*рез)?|ввод|ВКЛЮЧИТЬ|вс[её]|выбор|вывод|выход|дано|для|до|дс|если|иначе|исп|использовать|кон(?:(?:\\x20+|_)исп)?|кц(?:(?:\\x20+|_)при)?|надо|нач|нс|нц|от|пауза|пока|при|раза?|рез|стоп|таб|то|утв|шаг)(?=[<nonId>]|$)/.source),\n      lookbehind: true\n    },\n\n    /** Should be performed after searching for reserved words. */\n    'name': {\n      pattern: wrapId(/(^|[<nonId>])[^\\d<nonId>][^<nonId>]*(?:\\x20+[^<nonId>]+)*(?=[<nonId>]|$)/.source),\n      lookbehind: true\n    },\n\n    /** Should be performed after searching for names. */\n    'number': {\n      pattern: wrapId(/(^|[<nonId>])(?:\\B\\$[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)(?=[<nonId>]|$)/.source, 'i'),\n      lookbehind: true\n    },\n\n    /** Should be performed after searching for words. */\n    'punctuation': /:=|[(),:;\\[\\]]/,\n\n    /**\n     * Should be performed after searching for\n     * - numeric constants (because of \"+\" and \"-\");\n     * - punctuation marks (because of \":=\" and \"=\").\n     */\n    'operator-char': {\n      pattern: /\\*\\*?|<[=>]?|>=?|[-+/=]/,\n      alias: 'operator'\n    }\n  };\n  Prism.languages.kum = Prism.languages.kumir;\n})(Prism);","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/github/react-snippy/node_modules/prismjs/components/prism-kumir.js"],"names":["Prism","nonId","source","wrapId","pattern","flags","RegExp","replace","languages","kumir","greedy","lookbehind","alias","kum"],"mappings":"AAAA;AACC,WAAUA,KAAV,EAAiB;AAEjB;AACD;AACA;AACA;AACA;AACC,MAAIC,KAAK,GAAG,sDAAsDC,MAAlE;AAEA;AACD;AACA;AACA;AACA;AACA;AACA;;AACC,WAASC,MAAT,CAAgBC,OAAhB,EAAyBC,KAAzB,EAAgC;AAC/B,WAAOC,MAAM,CAACF,OAAO,CAACG,OAAR,CAAgB,UAAhB,EAA4BN,KAA5B,CAAD,EAAqCI,KAArC,CAAb;AACA;;AAEDL,EAAAA,KAAK,CAACQ,SAAN,CAAgBC,KAAhB,GAAwB;AACvB,eAAW;AACVL,MAAAA,OAAO,EAAE;AADC,KADY;AAKvB,cAAU;AACTA,MAAAA,OAAO,EAAE,KADA;AAETM,MAAAA,MAAM,EAAE;AAFC,KALa;AAUvB,cAAU;AACTN,MAAAA,OAAO,EAAE,yBADA;AAETM,MAAAA,MAAM,EAAE;AAFC,KAVa;AAevB,eAAW;AACVN,MAAAA,OAAO,EAAED,MAAM,CAAC,yCAAyCD,MAA1C,CADL;AAEVS,MAAAA,UAAU,EAAE;AAFF,KAfY;AAoBvB,qBAAiB;AAChBP,MAAAA,OAAO,EAAED,MAAM,CAAC,2CAA2CD,MAA5C,CADC;AAEhBS,MAAAA,UAAU,EAAE,IAFI;AAGhBC,MAAAA,KAAK,EAAE;AAHS,KApBM;AA0BvB,uBAAmB;AAClBR,MAAAA,OAAO,EAAED,MAAM,CAAC,mCAAmCD,MAApC,CADG;AAElBS,MAAAA,UAAU,EAAE,IAFM;AAGlBC,MAAAA,KAAK,EAAE;AAHW,KA1BI;AAgCvB,YAAQ,CACP;AACCR,MAAAA,OAAO,EAAED,MAAM,CAAC,mEAAmED,MAApE,CADhB;AAECS,MAAAA,UAAU,EAAE,IAFb;AAGCC,MAAAA,KAAK,EAAE;AAHR,KADO,EAMP;AACCR,MAAAA,OAAO,EAAED,MAAM,CAAC,0DAA0DD,MAA3D,CADhB;AAECS,MAAAA,UAAU,EAAE,IAFb;AAGCC,MAAAA,KAAK,EAAE;AAHR,KANO,CAhCe;;AA6CvB;AACF;AACA;AACA;AACA;AACE,eAAW;AACVR,MAAAA,OAAO,EAAED,MAAM,CAAC,qPAAqPD,MAAtP,CADL;AAEVS,MAAAA,UAAU,EAAE;AAFF,KAlDY;;AAuDvB;AACA,YAAQ;AACPP,MAAAA,OAAO,EAAED,MAAM,CAAC,2EAA2ED,MAA5E,CADR;AAEPS,MAAAA,UAAU,EAAE;AAFL,KAxDe;;AA6DvB;AACA,cAAU;AACTP,MAAAA,OAAO,EAAED,MAAM,CAAC,2FAA2FD,MAA5F,EAAoG,GAApG,CADN;AAETS,MAAAA,UAAU,EAAE;AAFH,KA9Da;;AAmEvB;AACA,mBAAe,gBApEQ;;AAsEvB;AACF;AACA;AACA;AACA;AACE,qBAAiB;AAChBP,MAAAA,OAAO,EAAE,yBADO;AAEhBQ,MAAAA,KAAK,EAAE;AAFS;AA3EM,GAAxB;AAiFAZ,EAAAA,KAAK,CAACQ,SAAN,CAAgBK,GAAhB,GAAsBb,KAAK,CAACQ,SAAN,CAAgBC,KAAtC;AAEA,CAvGA,EAuGCT,KAvGD,CAAD","sourcesContent":["/* eslint-disable regexp/no-dupe-characters-character-class */\n(function (Prism) {\n\n\t/**\n\t * Regular expression for characters that are not allowed in identifiers.\n\t *\n\t * @type {string}\n\t */\n\tvar nonId = /\\s\\x00-\\x1f\\x22-\\x2f\\x3a-\\x3f\\x5b-\\x5e\\x60\\x7b-\\x7e/.source;\n\n\t/**\n\t * Surround a regular expression for IDs with patterns for non-ID sequences.\n\t *\n\t * @param {string} pattern A regular expression for identifiers.\n\t * @param {string} [flags] The regular expression flags.\n\t * @returns {RegExp} A wrapped regular expression for identifiers.\n\t */\n\tfunction wrapId(pattern, flags) {\n\t\treturn RegExp(pattern.replace(/<nonId>/g, nonId), flags);\n\t}\n\n\tPrism.languages.kumir = {\n\t\t'comment': {\n\t\t\tpattern: /\\|.*/\n\t\t},\n\n\t\t'prolog': {\n\t\t\tpattern: /#.*/,\n\t\t\tgreedy: true\n\t\t},\n\n\t\t'string': {\n\t\t\tpattern: /\"[^\\n\\r\"]*\"|'[^\\n\\r']*'/,\n\t\t\tgreedy: true\n\t\t},\n\n\t\t'boolean': {\n\t\t\tpattern: wrapId(/(^|[<nonId>])(?:да|нет)(?=[<nonId>]|$)/.source),\n\t\t\tlookbehind: true\n\t\t},\n\n\t\t'operator-word': {\n\t\t\tpattern: wrapId(/(^|[<nonId>])(?:и|или|не)(?=[<nonId>]|$)/.source),\n\t\t\tlookbehind: true,\n\t\t\talias: 'keyword'\n\t\t},\n\n\t\t'system-variable': {\n\t\t\tpattern: wrapId(/(^|[<nonId>])знач(?=[<nonId>]|$)/.source),\n\t\t\tlookbehind: true,\n\t\t\talias: 'keyword'\n\t\t},\n\n\t\t'type': [\n\t\t\t{\n\t\t\t\tpattern: wrapId(/(^|[<nonId>])(?:вещ|лит|лог|сим|цел)(?:\\x20*таб)?(?=[<nonId>]|$)/.source),\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'builtin'\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: wrapId(/(^|[<nonId>])(?:компл|сканкод|файл|цвет)(?=[<nonId>]|$)/.source),\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'important'\n\t\t\t}\n\t\t],\n\n\t\t/**\n\t\t * Should be performed after searching for type names because of \"таб\".\n\t\t * \"таб\" is a reserved word, but never used without a preceding type name.\n\t\t * \"НАЗНАЧИТЬ\", \"Фввод\", and \"Фвывод\" are not reserved words.\n\t\t */\n\t\t'keyword': {\n\t\t\tpattern: wrapId(/(^|[<nonId>])(?:алг|арг(?:\\x20*рез)?|ввод|ВКЛЮЧИТЬ|вс[её]|выбор|вывод|выход|дано|для|до|дс|если|иначе|исп|использовать|кон(?:(?:\\x20+|_)исп)?|кц(?:(?:\\x20+|_)при)?|надо|нач|нс|нц|от|пауза|пока|при|раза?|рез|стоп|таб|то|утв|шаг)(?=[<nonId>]|$)/.source),\n\t\t\tlookbehind: true\n\t\t},\n\n\t\t/** Should be performed after searching for reserved words. */\n\t\t'name': {\n\t\t\tpattern: wrapId(/(^|[<nonId>])[^\\d<nonId>][^<nonId>]*(?:\\x20+[^<nonId>]+)*(?=[<nonId>]|$)/.source),\n\t\t\tlookbehind: true\n\t\t},\n\n\t\t/** Should be performed after searching for names. */\n\t\t'number': {\n\t\t\tpattern: wrapId(/(^|[<nonId>])(?:\\B\\$[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)(?=[<nonId>]|$)/.source, 'i'),\n\t\t\tlookbehind: true\n\t\t},\n\n\t\t/** Should be performed after searching for words. */\n\t\t'punctuation': /:=|[(),:;\\[\\]]/,\n\n\t\t/**\n\t\t * Should be performed after searching for\n\t\t * - numeric constants (because of \"+\" and \"-\");\n\t\t * - punctuation marks (because of \":=\" and \"=\").\n\t\t */\n\t\t'operator-char': {\n\t\t\tpattern: /\\*\\*?|<[=>]?|>=?|[-+/=]/,\n\t\t\talias: 'operator'\n\t\t}\n\t};\n\n\tPrism.languages.kum = Prism.languages.kumir;\n\n}(Prism));\n"]},"metadata":{},"sourceType":"script"}