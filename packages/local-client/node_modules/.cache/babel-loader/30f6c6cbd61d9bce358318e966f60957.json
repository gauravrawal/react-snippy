{"ast":null,"code":"\"use strict\";\n\n;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\n\nfunction default_1(fork) {\n  var types = fork.use(types_1.default);\n  var Type = types.Type;\n  var builtin = types.builtInTypes;\n  var isNumber = builtin.number; // An example of constructing a new type with arbitrary constraints from\n  // an existing type.\n\n  function geq(than) {\n    return Type.from(function (value) {\n      return isNumber.check(value) && value >= than;\n    }, isNumber + \" >= \" + than);\n  }\n\n  ; // Default value-returning functions that may optionally be passed as a\n  // third argument to Def.prototype.field.\n\n  var defaults = {\n    // Functions were used because (among other reasons) that's the most\n    // elegant way to allow for the emptyArray one always to give a new\n    // array instance.\n    \"null\": function () {\n      return null;\n    },\n    \"emptyArray\": function () {\n      return [];\n    },\n    \"false\": function () {\n      return false;\n    },\n    \"true\": function () {\n      return true;\n    },\n    \"undefined\": function () {},\n    \"use strict\": function () {\n      return \"use strict\";\n    }\n  };\n  var naiveIsPrimitive = Type.or(builtin.string, builtin.number, builtin.boolean, builtin.null, builtin.undefined);\n  var isPrimitive = Type.from(function (value) {\n    if (value === null) return true;\n    var type = typeof value;\n\n    if (type === \"object\" || type === \"function\") {\n      return false;\n    }\n\n    return true;\n  }, naiveIsPrimitive.toString());\n  return {\n    geq: geq,\n    defaults: defaults,\n    isPrimitive: isPrimitive\n  };\n}\n\nexports.default = default_1;\nmodule.exports = exports[\"default\"];","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/github/react-snippy/node_modules/jscodeshift/node_modules/ast-types/lib/shared.js"],"names":["Object","defineProperty","exports","value","tslib_1","require","types_1","__importDefault","default_1","fork","types","use","default","Type","builtin","builtInTypes","isNumber","number","geq","than","from","check","defaults","naiveIsPrimitive","or","string","boolean","null","undefined","isPrimitive","type","toString","module"],"mappings":"AAAA;;AAAa;AACbA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAIC,OAAO,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,IAAIC,OAAO,GAAGF,OAAO,CAACG,eAAR,CAAwBF,OAAO,CAAC,SAAD,CAA/B,CAAd;;AACA,SAASG,SAAT,CAAmBC,IAAnB,EAAyB;AACrB,MAAIC,KAAK,GAAGD,IAAI,CAACE,GAAL,CAASL,OAAO,CAACM,OAAjB,CAAZ;AACA,MAAIC,IAAI,GAAGH,KAAK,CAACG,IAAjB;AACA,MAAIC,OAAO,GAAGJ,KAAK,CAACK,YAApB;AACA,MAAIC,QAAQ,GAAGF,OAAO,CAACG,MAAvB,CAJqB,CAKrB;AACA;;AACA,WAASC,GAAT,CAAaC,IAAb,EAAmB;AACf,WAAON,IAAI,CAACO,IAAL,CAAU,UAAUjB,KAAV,EAAiB;AAAE,aAAOa,QAAQ,CAACK,KAAT,CAAelB,KAAf,KAAyBA,KAAK,IAAIgB,IAAzC;AAAgD,KAA7E,EAA+EH,QAAQ,GAAG,MAAX,GAAoBG,IAAnG,CAAP;AACH;;AACD,GAVqB,CAWrB;AACA;;AACA,MAAIG,QAAQ,GAAG;AACX;AACA;AACA;AACA,YAAQ,YAAY;AAAE,aAAO,IAAP;AAAc,KAJzB;AAKX,kBAAc,YAAY;AAAE,aAAO,EAAP;AAAY,KAL7B;AAMX,aAAS,YAAY;AAAE,aAAO,KAAP;AAAe,KAN3B;AAOX,YAAQ,YAAY;AAAE,aAAO,IAAP;AAAc,KAPzB;AAQX,iBAAa,YAAY,CAAG,CARjB;AASX,kBAAc,YAAY;AAAE,aAAO,YAAP;AAAsB;AATvC,GAAf;AAWA,MAAIC,gBAAgB,GAAGV,IAAI,CAACW,EAAL,CAAQV,OAAO,CAACW,MAAhB,EAAwBX,OAAO,CAACG,MAAhC,EAAwCH,OAAO,CAACY,OAAhD,EAAyDZ,OAAO,CAACa,IAAjE,EAAuEb,OAAO,CAACc,SAA/E,CAAvB;AACA,MAAIC,WAAW,GAAGhB,IAAI,CAACO,IAAL,CAAU,UAAUjB,KAAV,EAAiB;AACzC,QAAIA,KAAK,KAAK,IAAd,EACI,OAAO,IAAP;AACJ,QAAI2B,IAAI,GAAG,OAAO3B,KAAlB;;AACA,QAAI2B,IAAI,KAAK,QAAT,IACAA,IAAI,KAAK,UADb,EACyB;AACrB,aAAO,KAAP;AACH;;AACD,WAAO,IAAP;AACH,GATiB,EASfP,gBAAgB,CAACQ,QAAjB,EATe,CAAlB;AAUA,SAAO;AACHb,IAAAA,GAAG,EAAEA,GADF;AAEHI,IAAAA,QAAQ,EAAEA,QAFP;AAGHO,IAAAA,WAAW,EAAEA;AAHV,GAAP;AAKH;;AACD3B,OAAO,CAACU,OAAR,GAAkBJ,SAAlB;AACAwB,MAAM,CAAC9B,OAAP,GAAiBA,OAAO,CAAC,SAAD,CAAxB","sourcesContent":["\"use strict\";;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\nfunction default_1(fork) {\n    var types = fork.use(types_1.default);\n    var Type = types.Type;\n    var builtin = types.builtInTypes;\n    var isNumber = builtin.number;\n    // An example of constructing a new type with arbitrary constraints from\n    // an existing type.\n    function geq(than) {\n        return Type.from(function (value) { return isNumber.check(value) && value >= than; }, isNumber + \" >= \" + than);\n    }\n    ;\n    // Default value-returning functions that may optionally be passed as a\n    // third argument to Def.prototype.field.\n    var defaults = {\n        // Functions were used because (among other reasons) that's the most\n        // elegant way to allow for the emptyArray one always to give a new\n        // array instance.\n        \"null\": function () { return null; },\n        \"emptyArray\": function () { return []; },\n        \"false\": function () { return false; },\n        \"true\": function () { return true; },\n        \"undefined\": function () { },\n        \"use strict\": function () { return \"use strict\"; }\n    };\n    var naiveIsPrimitive = Type.or(builtin.string, builtin.number, builtin.boolean, builtin.null, builtin.undefined);\n    var isPrimitive = Type.from(function (value) {\n        if (value === null)\n            return true;\n        var type = typeof value;\n        if (type === \"object\" ||\n            type === \"function\") {\n            return false;\n        }\n        return true;\n    }, naiveIsPrimitive.toString());\n    return {\n        geq: geq,\n        defaults: defaults,\n        isPrimitive: isPrimitive,\n    };\n}\nexports.default = default_1;\nmodule.exports = exports[\"default\"];\n"]},"metadata":{},"sourceType":"script"}