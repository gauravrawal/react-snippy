{"ast":null,"code":"// https://smlfamily.github.io/sml97-defn.pdf\n// https://people.mpi-sws.org/~rossberg/sml.html\n(function (Prism) {\n  var keywords = /\\b(?:abstype|and|andalso|as|case|datatype|do|else|end|eqtype|exception|fn|fun|functor|handle|if|in|include|infix|infixr|let|local|nonfix|of|op|open|orelse|raise|rec|sharing|sig|signature|struct|structure|then|type|val|where|while|with|withtype)\\b/i;\n  Prism.languages.sml = {\n    // allow one level of nesting\n    'comment': /\\(\\*(?:[^*(]|\\*(?!\\))|\\((?!\\*)|\\(\\*(?:[^*(]|\\*(?!\\))|\\((?!\\*))*\\*\\))*\\*\\)/,\n    'string': {\n      pattern: /#?\"(?:[^\"\\\\]|\\\\.)*\"/,\n      greedy: true\n    },\n    'class-name': [{\n      // This is only an approximation since the real grammar is context-free\n      //\n      // Why the main loop so complex?\n      // The main loop is approximately the same as /(?:\\s*(?:[*,]|->)\\s*<TERMINAL>)*/ which is, obviously, a lot\n      // simpler. The difference is that if a comma is the last iteration of the loop, then the terminal must be\n      // followed by a long identifier.\n      pattern: RegExp(/((?:^|[^:]):\\s*)<TERMINAL>(?:\\s*(?:(?:\\*|->)\\s*<TERMINAL>|,\\s*<TERMINAL>(?:(?=<NOT-LAST>)|(?!<NOT-LAST>)\\s+<LONG-ID>)))*/.source.replace(/<NOT-LAST>/g, function () {\n        return /\\s*(?:[*,]|->)/.source;\n      }).replace(/<TERMINAL>/g, function () {\n        return /(?:'[\\w']*|<LONG-ID>|\\((?:[^()]|\\([^()]*\\))*\\)|\\{(?:[^{}]|\\{[^{}]*\\})*\\})(?:\\s+<LONG-ID>)*/.source;\n      }).replace(/<LONG-ID>/g, function () {\n        return /(?!<KEYWORD>)[a-z\\d_][\\w'.]*/.source;\n      }).replace(/<KEYWORD>/g, function () {\n        return keywords.source;\n      }), 'i'),\n      lookbehind: true,\n      greedy: true,\n      inside: null // see below\n\n    }, {\n      pattern: /((?:^|[^\\w'])(?:datatype|exception|functor|signature|structure|type)\\s+)[a-z_][\\w'.]*/i,\n      lookbehind: true\n    }],\n    'function': {\n      pattern: /((?:^|[^\\w'])fun\\s+)[a-z_][\\w'.]*/i,\n      lookbehind: true\n    },\n    'keyword': keywords,\n    'variable': {\n      pattern: /(^|[^\\w'])'[\\w']*/,\n      lookbehind: true\n    },\n    'number': /~?\\b(?:\\d+(?:\\.\\d+)?(?:e~?\\d+)?|0x[\\da-f]+)\\b/i,\n    'word': {\n      pattern: /\\b0w(?:\\d+|x[\\da-f]+)\\b/i,\n      alias: 'constant'\n    },\n    'boolean': /\\b(?:false|true)\\b/i,\n    'operator': /\\.\\.\\.|:[>=:]|=>?|->|[<>]=?|[!+\\-*/^#|@~]/,\n    'punctuation': /[(){}\\[\\].:,;]/\n  };\n  Prism.languages.sml['class-name'][0].inside = Prism.languages.sml;\n  Prism.languages.smlnj = Prism.languages.sml;\n})(Prism);","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/github/react-snippy/node_modules/prismjs/components/prism-sml.js"],"names":["Prism","keywords","languages","sml","pattern","greedy","RegExp","source","replace","lookbehind","inside","alias","smlnj"],"mappings":"AAAA;AACA;AACC,WAAUA,KAAV,EAAiB;AAEjB,MAAIC,QAAQ,GAAG,yPAAf;AAEAD,EAAAA,KAAK,CAACE,SAAN,CAAgBC,GAAhB,GAAsB;AACrB;AACA,eAAW,2EAFU;AAGrB,cAAU;AACTC,MAAAA,OAAO,EAAE,qBADA;AAETC,MAAAA,MAAM,EAAE;AAFC,KAHW;AAQrB,kBAAc,CACb;AACC;AACA;AACA;AACA;AACA;AACA;AACAD,MAAAA,OAAO,EAAEE,MAAM,CACd,2HAA2HC,MAA3H,CACEC,OADF,CACU,aADV,EACyB,YAAY;AAAE,eAAO,iBAAiBD,MAAxB;AAAiC,OADxE,EAEEC,OAFF,CAEU,aAFV,EAEyB,YAAY;AACnC,eAAO,6FAA6FD,MAApG;AACA,OAJF,EAKEC,OALF,CAKU,YALV,EAKwB,YAAY;AAAE,eAAO,+BAA+BD,MAAtC;AAA+C,OALrF,EAMEC,OANF,CAMU,YANV,EAMwB,YAAY;AAAE,eAAOP,QAAQ,CAACM,MAAhB;AAAyB,OAN/D,CADc,EAQd,GARc,CAPhB;AAiBCE,MAAAA,UAAU,EAAE,IAjBb;AAkBCJ,MAAAA,MAAM,EAAE,IAlBT;AAmBCK,MAAAA,MAAM,EAAE,IAnBT,CAmBc;;AAnBd,KADa,EAsBb;AACCN,MAAAA,OAAO,EAAE,wFADV;AAECK,MAAAA,UAAU,EAAE;AAFb,KAtBa,CARO;AAmCrB,gBAAY;AACXL,MAAAA,OAAO,EAAE,oCADE;AAEXK,MAAAA,UAAU,EAAE;AAFD,KAnCS;AAwCrB,eAAWR,QAxCU;AAyCrB,gBAAY;AACXG,MAAAA,OAAO,EAAE,mBADE;AAEXK,MAAAA,UAAU,EAAE;AAFD,KAzCS;AA8CrB,cAAU,gDA9CW;AA+CrB,YAAQ;AACPL,MAAAA,OAAO,EAAE,0BADF;AAEPO,MAAAA,KAAK,EAAE;AAFA,KA/Ca;AAoDrB,eAAW,qBApDU;AAqDrB,gBAAY,2CArDS;AAsDrB,mBAAe;AAtDM,GAAtB;AAyDAX,EAAAA,KAAK,CAACE,SAAN,CAAgBC,GAAhB,CAAoB,YAApB,EAAkC,CAAlC,EAAqCO,MAArC,GAA8CV,KAAK,CAACE,SAAN,CAAgBC,GAA9D;AAEAH,EAAAA,KAAK,CAACE,SAAN,CAAgBU,KAAhB,GAAwBZ,KAAK,CAACE,SAAN,CAAgBC,GAAxC;AAEA,CAjEA,EAiECH,KAjED,CAAD","sourcesContent":["// https://smlfamily.github.io/sml97-defn.pdf\n// https://people.mpi-sws.org/~rossberg/sml.html\n(function (Prism) {\n\n\tvar keywords = /\\b(?:abstype|and|andalso|as|case|datatype|do|else|end|eqtype|exception|fn|fun|functor|handle|if|in|include|infix|infixr|let|local|nonfix|of|op|open|orelse|raise|rec|sharing|sig|signature|struct|structure|then|type|val|where|while|with|withtype)\\b/i;\n\n\tPrism.languages.sml = {\n\t\t// allow one level of nesting\n\t\t'comment': /\\(\\*(?:[^*(]|\\*(?!\\))|\\((?!\\*)|\\(\\*(?:[^*(]|\\*(?!\\))|\\((?!\\*))*\\*\\))*\\*\\)/,\n\t\t'string': {\n\t\t\tpattern: /#?\"(?:[^\"\\\\]|\\\\.)*\"/,\n\t\t\tgreedy: true\n\t\t},\n\n\t\t'class-name': [\n\t\t\t{\n\t\t\t\t// This is only an approximation since the real grammar is context-free\n\t\t\t\t//\n\t\t\t\t// Why the main loop so complex?\n\t\t\t\t// The main loop is approximately the same as /(?:\\s*(?:[*,]|->)\\s*<TERMINAL>)*/ which is, obviously, a lot\n\t\t\t\t// simpler. The difference is that if a comma is the last iteration of the loop, then the terminal must be\n\t\t\t\t// followed by a long identifier.\n\t\t\t\tpattern: RegExp(\n\t\t\t\t\t/((?:^|[^:]):\\s*)<TERMINAL>(?:\\s*(?:(?:\\*|->)\\s*<TERMINAL>|,\\s*<TERMINAL>(?:(?=<NOT-LAST>)|(?!<NOT-LAST>)\\s+<LONG-ID>)))*/.source\n\t\t\t\t\t\t.replace(/<NOT-LAST>/g, function () { return /\\s*(?:[*,]|->)/.source; })\n\t\t\t\t\t\t.replace(/<TERMINAL>/g, function () {\n\t\t\t\t\t\t\treturn /(?:'[\\w']*|<LONG-ID>|\\((?:[^()]|\\([^()]*\\))*\\)|\\{(?:[^{}]|\\{[^{}]*\\})*\\})(?:\\s+<LONG-ID>)*/.source;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.replace(/<LONG-ID>/g, function () { return /(?!<KEYWORD>)[a-z\\d_][\\w'.]*/.source; })\n\t\t\t\t\t\t.replace(/<KEYWORD>/g, function () { return keywords.source; }),\n\t\t\t\t\t'i'\n\t\t\t\t),\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: null // see below\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /((?:^|[^\\w'])(?:datatype|exception|functor|signature|structure|type)\\s+)[a-z_][\\w'.]*/i,\n\t\t\t\tlookbehind: true\n\t\t\t}\n\t\t],\n\t\t'function': {\n\t\t\tpattern: /((?:^|[^\\w'])fun\\s+)[a-z_][\\w'.]*/i,\n\t\t\tlookbehind: true\n\t\t},\n\n\t\t'keyword': keywords,\n\t\t'variable': {\n\t\t\tpattern: /(^|[^\\w'])'[\\w']*/,\n\t\t\tlookbehind: true,\n\t\t},\n\n\t\t'number': /~?\\b(?:\\d+(?:\\.\\d+)?(?:e~?\\d+)?|0x[\\da-f]+)\\b/i,\n\t\t'word': {\n\t\t\tpattern: /\\b0w(?:\\d+|x[\\da-f]+)\\b/i,\n\t\t\talias: 'constant'\n\t\t},\n\n\t\t'boolean': /\\b(?:false|true)\\b/i,\n\t\t'operator': /\\.\\.\\.|:[>=:]|=>?|->|[<>]=?|[!+\\-*/^#|@~]/,\n\t\t'punctuation': /[(){}\\[\\].:,;]/\n\t};\n\n\tPrism.languages.sml['class-name'][0].inside = Prism.languages.sml;\n\n\tPrism.languages.smlnj = Prism.languages.sml;\n\n}(Prism));\n"]},"metadata":{},"sourceType":"script"}