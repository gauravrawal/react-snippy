{"ast":null,"code":"(function (Prism) {\n  Prism.languages.http = {\n    'request-line': {\n      pattern: /^(?:GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|PRI|SEARCH)\\s(?:https?:\\/\\/|\\/)\\S*\\sHTTP\\/[0-9.]+/m,\n      inside: {\n        // HTTP Method\n        'method': {\n          pattern: /^[A-Z]+\\b/,\n          alias: 'property'\n        },\n        // Request Target e.g. http://example.com, /path/to/file\n        'request-target': {\n          pattern: /^(\\s)(?:https?:\\/\\/|\\/)\\S*(?=\\s)/,\n          lookbehind: true,\n          alias: 'url',\n          inside: Prism.languages.uri\n        },\n        // HTTP Version\n        'http-version': {\n          pattern: /^(\\s)HTTP\\/[0-9.]+/,\n          lookbehind: true,\n          alias: 'property'\n        }\n      }\n    },\n    'response-status': {\n      pattern: /^HTTP\\/[0-9.]+ \\d+ .+/m,\n      inside: {\n        // HTTP Version\n        'http-version': {\n          pattern: /^HTTP\\/[0-9.]+/,\n          alias: 'property'\n        },\n        // Status Code\n        'status-code': {\n          pattern: /^(\\s)\\d+(?=\\s)/,\n          lookbehind: true,\n          alias: 'number'\n        },\n        // Reason Phrase\n        'reason-phrase': {\n          pattern: /^(\\s).+/,\n          lookbehind: true,\n          alias: 'string'\n        }\n      }\n    },\n    // HTTP header name\n    'header-name': {\n      pattern: /^[\\w-]+:(?=.)/m,\n      alias: 'keyword'\n    }\n  }; // Create a mapping of Content-Type headers to language definitions\n\n  var langs = Prism.languages;\n  var httpLanguages = {\n    'application/javascript': langs.javascript,\n    'application/json': langs.json || langs.javascript,\n    'application/xml': langs.xml,\n    'text/xml': langs.xml,\n    'text/html': langs.html,\n    'text/css': langs.css\n  }; // Declare which types can also be suffixes\n\n  var suffixTypes = {\n    'application/json': true,\n    'application/xml': true\n  };\n  /**\n   * Returns a pattern for the given content type which matches it and any type which has it as a suffix.\n   *\n   * @param {string} contentType\n   * @returns {string}\n   */\n\n  function getSuffixPattern(contentType) {\n    var suffix = contentType.replace(/^[a-z]+\\//, '');\n    var suffixPattern = '\\\\w+/(?:[\\\\w.-]+\\\\+)+' + suffix + '(?![+\\\\w.-])';\n    return '(?:' + contentType + '|' + suffixPattern + ')';\n  } // Insert each content type parser that has its associated language\n  // currently loaded.\n\n\n  var options;\n\n  for (var contentType in httpLanguages) {\n    if (httpLanguages[contentType]) {\n      options = options || {};\n      var pattern = suffixTypes[contentType] ? getSuffixPattern(contentType) : contentType;\n      options[contentType.replace(/\\//g, '-')] = {\n        pattern: RegExp('(content-type:\\\\s*' + pattern + '(?:(?:\\\\r\\\\n?|\\\\n).+)*)(?:\\\\r?\\\\n|\\\\r){2}[\\\\s\\\\S]*', 'i'),\n        lookbehind: true,\n        inside: httpLanguages[contentType]\n      };\n    }\n  }\n\n  if (options) {\n    Prism.languages.insertBefore('http', 'header-name', options);\n  }\n})(Prism);","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/github/react-snippy/node_modules/prismjs/components/prism-http.js"],"names":["Prism","languages","http","pattern","inside","alias","lookbehind","uri","langs","httpLanguages","javascript","json","xml","html","css","suffixTypes","getSuffixPattern","contentType","suffix","replace","suffixPattern","options","RegExp","insertBefore"],"mappings":"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","sourcesContent":["(function (Prism) {\n\tPrism.languages.http = {\n\t\t'request-line': {\n\t\t\tpattern: /^(?:GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|PRI|SEARCH)\\s(?:https?:\\/\\/|\\/)\\S*\\sHTTP\\/[0-9.]+/m,\n\t\t\tinside: {\n\t\t\t\t// HTTP Method\n\t\t\t\t'method': {\n\t\t\t\t\tpattern: /^[A-Z]+\\b/,\n\t\t\t\t\talias: 'property'\n\t\t\t\t},\n\t\t\t\t// Request Target e.g. http://example.com, /path/to/file\n\t\t\t\t'request-target': {\n\t\t\t\t\tpattern: /^(\\s)(?:https?:\\/\\/|\\/)\\S*(?=\\s)/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'url',\n\t\t\t\t\tinside: Prism.languages.uri\n\t\t\t\t},\n\t\t\t\t// HTTP Version\n\t\t\t\t'http-version': {\n\t\t\t\t\tpattern: /^(\\s)HTTP\\/[0-9.]+/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'property'\n\t\t\t\t},\n\t\t\t}\n\t\t},\n\t\t'response-status': {\n\t\t\tpattern: /^HTTP\\/[0-9.]+ \\d+ .+/m,\n\t\t\tinside: {\n\t\t\t\t// HTTP Version\n\t\t\t\t'http-version': {\n\t\t\t\t\tpattern: /^HTTP\\/[0-9.]+/,\n\t\t\t\t\talias: 'property'\n\t\t\t\t},\n\t\t\t\t// Status Code\n\t\t\t\t'status-code': {\n\t\t\t\t\tpattern: /^(\\s)\\d+(?=\\s)/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'number'\n\t\t\t\t},\n\t\t\t\t// Reason Phrase\n\t\t\t\t'reason-phrase': {\n\t\t\t\t\tpattern: /^(\\s).+/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'string'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// HTTP header name\n\t\t'header-name': {\n\t\t\tpattern: /^[\\w-]+:(?=.)/m,\n\t\t\talias: 'keyword'\n\t\t}\n\t};\n\n\t// Create a mapping of Content-Type headers to language definitions\n\tvar langs = Prism.languages;\n\tvar httpLanguages = {\n\t\t'application/javascript': langs.javascript,\n\t\t'application/json': langs.json || langs.javascript,\n\t\t'application/xml': langs.xml,\n\t\t'text/xml': langs.xml,\n\t\t'text/html': langs.html,\n\t\t'text/css': langs.css\n\t};\n\n\t// Declare which types can also be suffixes\n\tvar suffixTypes = {\n\t\t'application/json': true,\n\t\t'application/xml': true\n\t};\n\n\t/**\n\t * Returns a pattern for the given content type which matches it and any type which has it as a suffix.\n\t *\n\t * @param {string} contentType\n\t * @returns {string}\n\t */\n\tfunction getSuffixPattern(contentType) {\n\t\tvar suffix = contentType.replace(/^[a-z]+\\//, '');\n\t\tvar suffixPattern = '\\\\w+/(?:[\\\\w.-]+\\\\+)+' + suffix + '(?![+\\\\w.-])';\n\t\treturn '(?:' + contentType + '|' + suffixPattern + ')';\n\t}\n\n\t// Insert each content type parser that has its associated language\n\t// currently loaded.\n\tvar options;\n\tfor (var contentType in httpLanguages) {\n\t\tif (httpLanguages[contentType]) {\n\t\t\toptions = options || {};\n\n\t\t\tvar pattern = suffixTypes[contentType] ? getSuffixPattern(contentType) : contentType;\n\t\t\toptions[contentType.replace(/\\//g, '-')] = {\n\t\t\t\tpattern: RegExp('(content-type:\\\\s*' + pattern + '(?:(?:\\\\r\\\\n?|\\\\n).+)*)(?:\\\\r?\\\\n|\\\\r){2}[\\\\s\\\\S]*', 'i'),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: httpLanguages[contentType]\n\t\t\t};\n\t\t}\n\t}\n\tif (options) {\n\t\tPrism.languages.insertBefore('http', 'header-name', options);\n\t}\n\n}(Prism));\n"]},"metadata":{},"sourceType":"script"}