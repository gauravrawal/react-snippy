{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.concat = exports.fromString = exports.countSpaces = exports.Lines = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\n\nvar source_map_1 = tslib_1.__importDefault(require(\"source-map\"));\n\nvar options_1 = require(\"./options\");\n\nvar util_1 = require(\"./util\");\n\nvar mapping_1 = tslib_1.__importDefault(require(\"./mapping\"));\n\nvar Lines =\n/** @class */\nfunction () {\n  function Lines(infos, sourceFileName) {\n    if (sourceFileName === void 0) {\n      sourceFileName = null;\n    }\n\n    this.infos = infos;\n    this.mappings = [];\n    this.cachedSourceMap = null;\n    this.cachedTabWidth = void 0;\n    assert_1.default.ok(infos.length > 0);\n    this.length = infos.length;\n    this.name = sourceFileName || null;\n\n    if (this.name) {\n      this.mappings.push(new mapping_1.default(this, {\n        start: this.firstPos(),\n        end: this.lastPos()\n      }));\n    }\n  }\n\n  Lines.prototype.toString = function (options) {\n    return this.sliceString(this.firstPos(), this.lastPos(), options);\n  };\n\n  Lines.prototype.getSourceMap = function (sourceMapName, sourceRoot) {\n    if (!sourceMapName) {\n      // Although we could make up a name or generate an anonymous\n      // source map, instead we assume that any consumer who does not\n      // provide a name does not actually want a source map.\n      return null;\n    }\n\n    var targetLines = this;\n\n    function updateJSON(json) {\n      json = json || {};\n      json.file = sourceMapName;\n\n      if (sourceRoot) {\n        json.sourceRoot = sourceRoot;\n      }\n\n      return json;\n    }\n\n    if (targetLines.cachedSourceMap) {\n      // Since Lines objects are immutable, we can reuse any source map\n      // that was previously generated. Nevertheless, we return a new\n      // JSON object here to protect the cached source map from outside\n      // modification.\n      return updateJSON(targetLines.cachedSourceMap.toJSON());\n    }\n\n    var smg = new source_map_1.default.SourceMapGenerator(updateJSON());\n    var sourcesToContents = {};\n    targetLines.mappings.forEach(function (mapping) {\n      var sourceCursor = mapping.sourceLines.skipSpaces(mapping.sourceLoc.start) || mapping.sourceLines.lastPos();\n      var targetCursor = targetLines.skipSpaces(mapping.targetLoc.start) || targetLines.lastPos();\n\n      while (util_1.comparePos(sourceCursor, mapping.sourceLoc.end) < 0 && util_1.comparePos(targetCursor, mapping.targetLoc.end) < 0) {\n        var sourceChar = mapping.sourceLines.charAt(sourceCursor);\n        var targetChar = targetLines.charAt(targetCursor);\n        assert_1.default.strictEqual(sourceChar, targetChar);\n        var sourceName = mapping.sourceLines.name; // Add mappings one character at a time for maximum resolution.\n\n        smg.addMapping({\n          source: sourceName,\n          original: {\n            line: sourceCursor.line,\n            column: sourceCursor.column\n          },\n          generated: {\n            line: targetCursor.line,\n            column: targetCursor.column\n          }\n        });\n\n        if (!hasOwn.call(sourcesToContents, sourceName)) {\n          var sourceContent = mapping.sourceLines.toString();\n          smg.setSourceContent(sourceName, sourceContent);\n          sourcesToContents[sourceName] = sourceContent;\n        }\n\n        targetLines.nextPos(targetCursor, true);\n        mapping.sourceLines.nextPos(sourceCursor, true);\n      }\n    });\n    targetLines.cachedSourceMap = smg;\n    return smg.toJSON();\n  };\n\n  Lines.prototype.bootstrapCharAt = function (pos) {\n    assert_1.default.strictEqual(typeof pos, \"object\");\n    assert_1.default.strictEqual(typeof pos.line, \"number\");\n    assert_1.default.strictEqual(typeof pos.column, \"number\");\n    var line = pos.line,\n        column = pos.column,\n        strings = this.toString().split(lineTerminatorSeqExp),\n        string = strings[line - 1];\n    if (typeof string === \"undefined\") return \"\";\n    if (column === string.length && line < strings.length) return \"\\n\";\n    if (column >= string.length) return \"\";\n    return string.charAt(column);\n  };\n\n  Lines.prototype.charAt = function (pos) {\n    assert_1.default.strictEqual(typeof pos, \"object\");\n    assert_1.default.strictEqual(typeof pos.line, \"number\");\n    assert_1.default.strictEqual(typeof pos.column, \"number\");\n    var line = pos.line,\n        column = pos.column,\n        secret = this,\n        infos = secret.infos,\n        info = infos[line - 1],\n        c = column;\n    if (typeof info === \"undefined\" || c < 0) return \"\";\n    var indent = this.getIndentAt(line);\n    if (c < indent) return \" \";\n    c += info.sliceStart - indent;\n    if (c === info.sliceEnd && line < this.length) return \"\\n\";\n    if (c >= info.sliceEnd) return \"\";\n    return info.line.charAt(c);\n  };\n\n  Lines.prototype.stripMargin = function (width, skipFirstLine) {\n    if (width === 0) return this;\n    assert_1.default.ok(width > 0, \"negative margin: \" + width);\n    if (skipFirstLine && this.length === 1) return this;\n    var lines = new Lines(this.infos.map(function (info, i) {\n      if (info.line && (i > 0 || !skipFirstLine)) {\n        info = tslib_1.__assign(tslib_1.__assign({}, info), {\n          indent: Math.max(0, info.indent - width)\n        });\n      }\n\n      return info;\n    }));\n\n    if (this.mappings.length > 0) {\n      var newMappings_1 = lines.mappings;\n      assert_1.default.strictEqual(newMappings_1.length, 0);\n      this.mappings.forEach(function (mapping) {\n        newMappings_1.push(mapping.indent(width, skipFirstLine, true));\n      });\n    }\n\n    return lines;\n  };\n\n  Lines.prototype.indent = function (by) {\n    if (by === 0) {\n      return this;\n    }\n\n    var lines = new Lines(this.infos.map(function (info) {\n      if (info.line && !info.locked) {\n        info = tslib_1.__assign(tslib_1.__assign({}, info), {\n          indent: info.indent + by\n        });\n      }\n\n      return info;\n    }));\n\n    if (this.mappings.length > 0) {\n      var newMappings_2 = lines.mappings;\n      assert_1.default.strictEqual(newMappings_2.length, 0);\n      this.mappings.forEach(function (mapping) {\n        newMappings_2.push(mapping.indent(by));\n      });\n    }\n\n    return lines;\n  };\n\n  Lines.prototype.indentTail = function (by) {\n    if (by === 0) {\n      return this;\n    }\n\n    if (this.length < 2) {\n      return this;\n    }\n\n    var lines = new Lines(this.infos.map(function (info, i) {\n      if (i > 0 && info.line && !info.locked) {\n        info = tslib_1.__assign(tslib_1.__assign({}, info), {\n          indent: info.indent + by\n        });\n      }\n\n      return info;\n    }));\n\n    if (this.mappings.length > 0) {\n      var newMappings_3 = lines.mappings;\n      assert_1.default.strictEqual(newMappings_3.length, 0);\n      this.mappings.forEach(function (mapping) {\n        newMappings_3.push(mapping.indent(by, true));\n      });\n    }\n\n    return lines;\n  };\n\n  Lines.prototype.lockIndentTail = function () {\n    if (this.length < 2) {\n      return this;\n    }\n\n    return new Lines(this.infos.map(function (info, i) {\n      return tslib_1.__assign(tslib_1.__assign({}, info), {\n        locked: i > 0\n      });\n    }));\n  };\n\n  Lines.prototype.getIndentAt = function (line) {\n    assert_1.default.ok(line >= 1, \"no line \" + line + \" (line numbers start from 1)\");\n    return Math.max(this.infos[line - 1].indent, 0);\n  };\n\n  Lines.prototype.guessTabWidth = function () {\n    if (typeof this.cachedTabWidth === \"number\") {\n      return this.cachedTabWidth;\n    }\n\n    var counts = []; // Sparse array.\n\n    var lastIndent = 0;\n\n    for (var line = 1, last = this.length; line <= last; ++line) {\n      var info = this.infos[line - 1];\n      var sliced = info.line.slice(info.sliceStart, info.sliceEnd); // Whitespace-only lines don't tell us much about the likely tab\n      // width of this code.\n\n      if (isOnlyWhitespace(sliced)) {\n        continue;\n      }\n\n      var diff = Math.abs(info.indent - lastIndent);\n      counts[diff] = ~~counts[diff] + 1;\n      lastIndent = info.indent;\n    }\n\n    var maxCount = -1;\n    var result = 2;\n\n    for (var tabWidth = 1; tabWidth < counts.length; tabWidth += 1) {\n      if (hasOwn.call(counts, tabWidth) && counts[tabWidth] > maxCount) {\n        maxCount = counts[tabWidth];\n        result = tabWidth;\n      }\n    }\n\n    return this.cachedTabWidth = result;\n  }; // Determine if the list of lines has a first line that starts with a //\n  // or /* comment. If this is the case, the code may need to be wrapped in\n  // parens to avoid ASI issues.\n\n\n  Lines.prototype.startsWithComment = function () {\n    if (this.infos.length === 0) {\n      return false;\n    }\n\n    var firstLineInfo = this.infos[0],\n        sliceStart = firstLineInfo.sliceStart,\n        sliceEnd = firstLineInfo.sliceEnd,\n        firstLine = firstLineInfo.line.slice(sliceStart, sliceEnd).trim();\n    return firstLine.length === 0 || firstLine.slice(0, 2) === \"//\" || firstLine.slice(0, 2) === \"/*\";\n  };\n\n  Lines.prototype.isOnlyWhitespace = function () {\n    return isOnlyWhitespace(this.toString());\n  };\n\n  Lines.prototype.isPrecededOnlyByWhitespace = function (pos) {\n    var info = this.infos[pos.line - 1];\n    var indent = Math.max(info.indent, 0);\n    var diff = pos.column - indent;\n\n    if (diff <= 0) {\n      // If pos.column does not exceed the indentation amount, then\n      // there must be only whitespace before it.\n      return true;\n    }\n\n    var start = info.sliceStart;\n    var end = Math.min(start + diff, info.sliceEnd);\n    var prefix = info.line.slice(start, end);\n    return isOnlyWhitespace(prefix);\n  };\n\n  Lines.prototype.getLineLength = function (line) {\n    var info = this.infos[line - 1];\n    return this.getIndentAt(line) + info.sliceEnd - info.sliceStart;\n  };\n\n  Lines.prototype.nextPos = function (pos, skipSpaces) {\n    if (skipSpaces === void 0) {\n      skipSpaces = false;\n    }\n\n    var l = Math.max(pos.line, 0),\n        c = Math.max(pos.column, 0);\n\n    if (c < this.getLineLength(l)) {\n      pos.column += 1;\n      return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;\n    }\n\n    if (l < this.length) {\n      pos.line += 1;\n      pos.column = 0;\n      return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;\n    }\n\n    return false;\n  };\n\n  Lines.prototype.prevPos = function (pos, skipSpaces) {\n    if (skipSpaces === void 0) {\n      skipSpaces = false;\n    }\n\n    var l = pos.line,\n        c = pos.column;\n\n    if (c < 1) {\n      l -= 1;\n      if (l < 1) return false;\n      c = this.getLineLength(l);\n    } else {\n      c = Math.min(c - 1, this.getLineLength(l));\n    }\n\n    pos.line = l;\n    pos.column = c;\n    return skipSpaces ? !!this.skipSpaces(pos, true, true) : true;\n  };\n\n  Lines.prototype.firstPos = function () {\n    // Trivial, but provided for completeness.\n    return {\n      line: 1,\n      column: 0\n    };\n  };\n\n  Lines.prototype.lastPos = function () {\n    return {\n      line: this.length,\n      column: this.getLineLength(this.length)\n    };\n  };\n\n  Lines.prototype.skipSpaces = function (pos, backward, modifyInPlace) {\n    if (backward === void 0) {\n      backward = false;\n    }\n\n    if (modifyInPlace === void 0) {\n      modifyInPlace = false;\n    }\n\n    if (pos) {\n      pos = modifyInPlace ? pos : {\n        line: pos.line,\n        column: pos.column\n      };\n    } else if (backward) {\n      pos = this.lastPos();\n    } else {\n      pos = this.firstPos();\n    }\n\n    if (backward) {\n      while (this.prevPos(pos)) {\n        if (!isOnlyWhitespace(this.charAt(pos)) && this.nextPos(pos)) {\n          return pos;\n        }\n      }\n\n      return null;\n    } else {\n      while (isOnlyWhitespace(this.charAt(pos))) {\n        if (!this.nextPos(pos)) {\n          return null;\n        }\n      }\n\n      return pos;\n    }\n  };\n\n  Lines.prototype.trimLeft = function () {\n    var pos = this.skipSpaces(this.firstPos(), false, true);\n    return pos ? this.slice(pos) : emptyLines;\n  };\n\n  Lines.prototype.trimRight = function () {\n    var pos = this.skipSpaces(this.lastPos(), true, true);\n    return pos ? this.slice(this.firstPos(), pos) : emptyLines;\n  };\n\n  Lines.prototype.trim = function () {\n    var start = this.skipSpaces(this.firstPos(), false, true);\n\n    if (start === null) {\n      return emptyLines;\n    }\n\n    var end = this.skipSpaces(this.lastPos(), true, true);\n\n    if (end === null) {\n      return emptyLines;\n    }\n\n    return this.slice(start, end);\n  };\n\n  Lines.prototype.eachPos = function (callback, startPos, skipSpaces) {\n    if (startPos === void 0) {\n      startPos = this.firstPos();\n    }\n\n    if (skipSpaces === void 0) {\n      skipSpaces = false;\n    }\n\n    var pos = this.firstPos();\n\n    if (startPos) {\n      pos.line = startPos.line, pos.column = startPos.column;\n    }\n\n    if (skipSpaces && !this.skipSpaces(pos, false, true)) {\n      return; // Encountered nothing but spaces.\n    }\n\n    do callback.call(this, pos); while (this.nextPos(pos, skipSpaces));\n  };\n\n  Lines.prototype.bootstrapSlice = function (start, end) {\n    var strings = this.toString().split(lineTerminatorSeqExp).slice(start.line - 1, end.line);\n\n    if (strings.length > 0) {\n      strings.push(strings.pop().slice(0, end.column));\n      strings[0] = strings[0].slice(start.column);\n    }\n\n    return fromString(strings.join(\"\\n\"));\n  };\n\n  Lines.prototype.slice = function (start, end) {\n    if (!end) {\n      if (!start) {\n        // The client seems to want a copy of this Lines object, but\n        // Lines objects are immutable, so it's perfectly adequate to\n        // return the same object.\n        return this;\n      } // Slice to the end if no end position was provided.\n\n\n      end = this.lastPos();\n    }\n\n    if (!start) {\n      throw new Error(\"cannot slice with end but not start\");\n    }\n\n    var sliced = this.infos.slice(start.line - 1, end.line);\n\n    if (start.line === end.line) {\n      sliced[0] = sliceInfo(sliced[0], start.column, end.column);\n    } else {\n      assert_1.default.ok(start.line < end.line);\n      sliced[0] = sliceInfo(sliced[0], start.column);\n      sliced.push(sliceInfo(sliced.pop(), 0, end.column));\n    }\n\n    var lines = new Lines(sliced);\n\n    if (this.mappings.length > 0) {\n      var newMappings_4 = lines.mappings;\n      assert_1.default.strictEqual(newMappings_4.length, 0);\n      this.mappings.forEach(function (mapping) {\n        var sliced = mapping.slice(this, start, end);\n\n        if (sliced) {\n          newMappings_4.push(sliced);\n        }\n      }, this);\n    }\n\n    return lines;\n  };\n\n  Lines.prototype.bootstrapSliceString = function (start, end, options) {\n    return this.slice(start, end).toString(options);\n  };\n\n  Lines.prototype.sliceString = function (start, end, options) {\n    if (start === void 0) {\n      start = this.firstPos();\n    }\n\n    if (end === void 0) {\n      end = this.lastPos();\n    }\n\n    var _a = options_1.normalize(options),\n        tabWidth = _a.tabWidth,\n        useTabs = _a.useTabs,\n        reuseWhitespace = _a.reuseWhitespace,\n        lineTerminator = _a.lineTerminator;\n\n    var parts = [];\n\n    for (var line = start.line; line <= end.line; ++line) {\n      var info = this.infos[line - 1];\n\n      if (line === start.line) {\n        if (line === end.line) {\n          info = sliceInfo(info, start.column, end.column);\n        } else {\n          info = sliceInfo(info, start.column);\n        }\n      } else if (line === end.line) {\n        info = sliceInfo(info, 0, end.column);\n      }\n\n      var indent = Math.max(info.indent, 0);\n      var before_1 = info.line.slice(0, info.sliceStart);\n\n      if (reuseWhitespace && isOnlyWhitespace(before_1) && countSpaces(before_1, tabWidth) === indent) {\n        // Reuse original spaces if the indentation is correct.\n        parts.push(info.line.slice(0, info.sliceEnd));\n        continue;\n      }\n\n      var tabs = 0;\n      var spaces = indent;\n\n      if (useTabs) {\n        tabs = Math.floor(indent / tabWidth);\n        spaces -= tabs * tabWidth;\n      }\n\n      var result = \"\";\n\n      if (tabs > 0) {\n        result += new Array(tabs + 1).join(\"\\t\");\n      }\n\n      if (spaces > 0) {\n        result += new Array(spaces + 1).join(\" \");\n      }\n\n      result += info.line.slice(info.sliceStart, info.sliceEnd);\n      parts.push(result);\n    }\n\n    return parts.join(lineTerminator);\n  };\n\n  Lines.prototype.isEmpty = function () {\n    return this.length < 2 && this.getLineLength(1) < 1;\n  };\n\n  Lines.prototype.join = function (elements) {\n    var separator = this;\n    var infos = [];\n    var mappings = [];\n    var prevInfo;\n\n    function appendLines(linesOrNull) {\n      if (linesOrNull === null) {\n        return;\n      }\n\n      if (prevInfo) {\n        var info = linesOrNull.infos[0];\n        var indent = new Array(info.indent + 1).join(\" \");\n        var prevLine_1 = infos.length;\n        var prevColumn_1 = Math.max(prevInfo.indent, 0) + prevInfo.sliceEnd - prevInfo.sliceStart;\n        prevInfo.line = prevInfo.line.slice(0, prevInfo.sliceEnd) + indent + info.line.slice(info.sliceStart, info.sliceEnd); // If any part of a line is indentation-locked, the whole line\n        // will be indentation-locked.\n\n        prevInfo.locked = prevInfo.locked || info.locked;\n        prevInfo.sliceEnd = prevInfo.line.length;\n\n        if (linesOrNull.mappings.length > 0) {\n          linesOrNull.mappings.forEach(function (mapping) {\n            mappings.push(mapping.add(prevLine_1, prevColumn_1));\n          });\n        }\n      } else if (linesOrNull.mappings.length > 0) {\n        mappings.push.apply(mappings, linesOrNull.mappings);\n      }\n\n      linesOrNull.infos.forEach(function (info, i) {\n        if (!prevInfo || i > 0) {\n          prevInfo = tslib_1.__assign({}, info);\n          infos.push(prevInfo);\n        }\n      });\n    }\n\n    function appendWithSeparator(linesOrNull, i) {\n      if (i > 0) appendLines(separator);\n      appendLines(linesOrNull);\n    }\n\n    elements.map(function (elem) {\n      var lines = fromString(elem);\n      if (lines.isEmpty()) return null;\n      return lines;\n    }).forEach(function (linesOrNull, i) {\n      if (separator.isEmpty()) {\n        appendLines(linesOrNull);\n      } else {\n        appendWithSeparator(linesOrNull, i);\n      }\n    });\n    if (infos.length < 1) return emptyLines;\n    var lines = new Lines(infos);\n    lines.mappings = mappings;\n    return lines;\n  };\n\n  Lines.prototype.concat = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var list = [this];\n    list.push.apply(list, args);\n    assert_1.default.strictEqual(list.length, args.length + 1);\n    return emptyLines.join(list);\n  };\n\n  return Lines;\n}();\n\nexports.Lines = Lines;\nvar fromStringCache = {};\nvar hasOwn = fromStringCache.hasOwnProperty;\nvar maxCacheKeyLen = 10;\n\nfunction countSpaces(spaces, tabWidth) {\n  var count = 0;\n  var len = spaces.length;\n\n  for (var i = 0; i < len; ++i) {\n    switch (spaces.charCodeAt(i)) {\n      case 9:\n        {\n          // '\\t'\n          assert_1.default.strictEqual(typeof tabWidth, \"number\");\n          assert_1.default.ok(tabWidth > 0);\n          var next = Math.ceil(count / tabWidth) * tabWidth;\n\n          if (next === count) {\n            count += tabWidth;\n          } else {\n            count = next;\n          }\n\n          break;\n        }\n\n      case 11: // '\\v'\n\n      case 12: // '\\f'\n\n      case 13: // '\\r'\n\n      case 0xfeff:\n        // zero-width non-breaking space\n        // These characters contribute nothing to indentation.\n        break;\n\n      case 32: // ' '\n\n      default:\n        // Treat all other whitespace like ' '.\n        count += 1;\n        break;\n    }\n  }\n\n  return count;\n}\n\nexports.countSpaces = countSpaces;\nvar leadingSpaceExp = /^\\s*/; // As specified here: http://www.ecma-international.org/ecma-262/6.0/#sec-line-terminators\n\nvar lineTerminatorSeqExp = /\\u000D\\u000A|\\u000D(?!\\u000A)|\\u000A|\\u2028|\\u2029/;\n/**\n * @param {Object} options - Options object that configures printing.\n */\n\nfunction fromString(string, options) {\n  if (string instanceof Lines) return string;\n  string += \"\";\n  var tabWidth = options && options.tabWidth;\n  var tabless = string.indexOf(\"\\t\") < 0;\n  var cacheable = !options && tabless && string.length <= maxCacheKeyLen;\n  assert_1.default.ok(tabWidth || tabless, \"No tab width specified but encountered tabs in string\\n\" + string);\n  if (cacheable && hasOwn.call(fromStringCache, string)) return fromStringCache[string];\n  var lines = new Lines(string.split(lineTerminatorSeqExp).map(function (line) {\n    // TODO: handle null exec result\n    var spaces = leadingSpaceExp.exec(line)[0];\n    return {\n      line: line,\n      indent: countSpaces(spaces, tabWidth),\n      // Boolean indicating whether this line can be reindented.\n      locked: false,\n      sliceStart: spaces.length,\n      sliceEnd: line.length\n    };\n  }), options_1.normalize(options).sourceFileName);\n  if (cacheable) fromStringCache[string] = lines;\n  return lines;\n}\n\nexports.fromString = fromString;\n\nfunction isOnlyWhitespace(string) {\n  return !/\\S/.test(string);\n}\n\nfunction sliceInfo(info, startCol, endCol) {\n  var sliceStart = info.sliceStart;\n  var sliceEnd = info.sliceEnd;\n  var indent = Math.max(info.indent, 0);\n  var lineLength = indent + sliceEnd - sliceStart;\n\n  if (typeof endCol === \"undefined\") {\n    endCol = lineLength;\n  }\n\n  startCol = Math.max(startCol, 0);\n  endCol = Math.min(endCol, lineLength);\n  endCol = Math.max(endCol, startCol);\n\n  if (endCol < indent) {\n    indent = endCol;\n    sliceEnd = sliceStart;\n  } else {\n    sliceEnd -= lineLength - endCol;\n  }\n\n  lineLength = endCol;\n  lineLength -= startCol;\n\n  if (startCol < indent) {\n    indent -= startCol;\n  } else {\n    startCol -= indent;\n    indent = 0;\n    sliceStart += startCol;\n  }\n\n  assert_1.default.ok(indent >= 0);\n  assert_1.default.ok(sliceStart <= sliceEnd);\n  assert_1.default.strictEqual(lineLength, indent + sliceEnd - sliceStart);\n\n  if (info.indent === indent && info.sliceStart === sliceStart && info.sliceEnd === sliceEnd) {\n    return info;\n  }\n\n  return {\n    line: info.line,\n    indent: indent,\n    // A destructive slice always unlocks indentation.\n    locked: false,\n    sliceStart: sliceStart,\n    sliceEnd: sliceEnd\n  };\n}\n\nfunction concat(elements) {\n  return emptyLines.join(elements);\n}\n\nexports.concat = concat; // The emptyLines object needs to be created all the way down here so that\n// Lines.prototype will be fully populated.\n\nvar emptyLines = fromString(\"\");","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/github/react-snippy/node_modules/jscodeshift/node_modules/recast/lib/lines.js"],"names":["Object","defineProperty","exports","value","concat","fromString","countSpaces","Lines","tslib_1","require","assert_1","__importDefault","source_map_1","options_1","util_1","mapping_1","infos","sourceFileName","mappings","cachedSourceMap","cachedTabWidth","default","ok","length","name","push","start","firstPos","end","lastPos","prototype","toString","options","sliceString","getSourceMap","sourceMapName","sourceRoot","targetLines","updateJSON","json","file","toJSON","smg","SourceMapGenerator","sourcesToContents","forEach","mapping","sourceCursor","sourceLines","skipSpaces","sourceLoc","targetCursor","targetLoc","comparePos","sourceChar","charAt","targetChar","strictEqual","sourceName","addMapping","source","original","line","column","generated","hasOwn","call","sourceContent","setSourceContent","nextPos","bootstrapCharAt","pos","strings","split","lineTerminatorSeqExp","string","secret","info","c","indent","getIndentAt","sliceStart","sliceEnd","stripMargin","width","skipFirstLine","lines","map","i","__assign","Math","max","newMappings_1","by","locked","newMappings_2","indentTail","newMappings_3","lockIndentTail","guessTabWidth","counts","lastIndent","last","sliced","slice","isOnlyWhitespace","diff","abs","maxCount","result","tabWidth","startsWithComment","firstLineInfo","firstLine","trim","isPrecededOnlyByWhitespace","min","prefix","getLineLength","l","prevPos","backward","modifyInPlace","trimLeft","emptyLines","trimRight","eachPos","callback","startPos","bootstrapSlice","pop","join","Error","sliceInfo","newMappings_4","bootstrapSliceString","_a","normalize","useTabs","reuseWhitespace","lineTerminator","parts","before_1","tabs","spaces","floor","Array","isEmpty","elements","separator","prevInfo","appendLines","linesOrNull","prevLine_1","prevColumn_1","add","apply","appendWithSeparator","elem","args","_i","arguments","list","fromStringCache","hasOwnProperty","maxCacheKeyLen","count","len","charCodeAt","next","ceil","leadingSpaceExp","tabless","indexOf","cacheable","exec","test","startCol","endCol","lineLength"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,MAAR,GAAiBF,OAAO,CAACG,UAAR,GAAqBH,OAAO,CAACI,WAAR,GAAsBJ,OAAO,CAACK,KAAR,GAAgB,KAAK,CAAjF;;AACA,IAAIC,OAAO,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,IAAIC,QAAQ,GAAGF,OAAO,CAACG,eAAR,CAAwBF,OAAO,CAAC,QAAD,CAA/B,CAAf;;AACA,IAAIG,YAAY,GAAGJ,OAAO,CAACG,eAAR,CAAwBF,OAAO,CAAC,YAAD,CAA/B,CAAnB;;AACA,IAAII,SAAS,GAAGJ,OAAO,CAAC,WAAD,CAAvB;;AACA,IAAIK,MAAM,GAAGL,OAAO,CAAC,QAAD,CAApB;;AACA,IAAIM,SAAS,GAAGP,OAAO,CAACG,eAAR,CAAwBF,OAAO,CAAC,WAAD,CAA/B,CAAhB;;AACA,IAAIF,KAAK;AAAG;AAAe,YAAY;AACnC,WAASA,KAAT,CAAeS,KAAf,EAAsBC,cAAtB,EAAsC;AAClC,QAAIA,cAAc,KAAK,KAAK,CAA5B,EAA+B;AAAEA,MAAAA,cAAc,GAAG,IAAjB;AAAwB;;AACzD,SAAKD,KAAL,GAAaA,KAAb;AACA,SAAKE,QAAL,GAAgB,EAAhB;AACA,SAAKC,eAAL,GAAuB,IAAvB;AACA,SAAKC,cAAL,GAAsB,KAAK,CAA3B;AACAV,IAAAA,QAAQ,CAACW,OAAT,CAAiBC,EAAjB,CAAoBN,KAAK,CAACO,MAAN,GAAe,CAAnC;AACA,SAAKA,MAAL,GAAcP,KAAK,CAACO,MAApB;AACA,SAAKC,IAAL,GAAYP,cAAc,IAAI,IAA9B;;AACA,QAAI,KAAKO,IAAT,EAAe;AACX,WAAKN,QAAL,CAAcO,IAAd,CAAmB,IAAIV,SAAS,CAACM,OAAd,CAAsB,IAAtB,EAA4B;AAC3CK,QAAAA,KAAK,EAAE,KAAKC,QAAL,EADoC;AAE3CC,QAAAA,GAAG,EAAE,KAAKC,OAAL;AAFsC,OAA5B,CAAnB;AAIH;AACJ;;AACDtB,EAAAA,KAAK,CAACuB,SAAN,CAAgBC,QAAhB,GAA2B,UAAUC,OAAV,EAAmB;AAC1C,WAAO,KAAKC,WAAL,CAAiB,KAAKN,QAAL,EAAjB,EAAkC,KAAKE,OAAL,EAAlC,EAAkDG,OAAlD,CAAP;AACH,GAFD;;AAGAzB,EAAAA,KAAK,CAACuB,SAAN,CAAgBI,YAAhB,GAA+B,UAAUC,aAAV,EAAyBC,UAAzB,EAAqC;AAChE,QAAI,CAACD,aAAL,EAAoB;AAChB;AACA;AACA;AACA,aAAO,IAAP;AACH;;AACD,QAAIE,WAAW,GAAG,IAAlB;;AACA,aAASC,UAAT,CAAoBC,IAApB,EAA0B;AACtBA,MAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AACAA,MAAAA,IAAI,CAACC,IAAL,GAAYL,aAAZ;;AACA,UAAIC,UAAJ,EAAgB;AACZG,QAAAA,IAAI,CAACH,UAAL,GAAkBA,UAAlB;AACH;;AACD,aAAOG,IAAP;AACH;;AACD,QAAIF,WAAW,CAAClB,eAAhB,EAAiC;AAC7B;AACA;AACA;AACA;AACA,aAAOmB,UAAU,CAACD,WAAW,CAAClB,eAAZ,CAA4BsB,MAA5B,EAAD,CAAjB;AACH;;AACD,QAAIC,GAAG,GAAG,IAAI9B,YAAY,CAACS,OAAb,CAAqBsB,kBAAzB,CAA4CL,UAAU,EAAtD,CAAV;AACA,QAAIM,iBAAiB,GAAG,EAAxB;AACAP,IAAAA,WAAW,CAACnB,QAAZ,CAAqB2B,OAArB,CAA6B,UAAUC,OAAV,EAAmB;AAC5C,UAAIC,YAAY,GAAGD,OAAO,CAACE,WAAR,CAAoBC,UAApB,CAA+BH,OAAO,CAACI,SAAR,CAAkBxB,KAAjD,KACfoB,OAAO,CAACE,WAAR,CAAoBnB,OAApB,EADJ;AAEA,UAAIsB,YAAY,GAAGd,WAAW,CAACY,UAAZ,CAAuBH,OAAO,CAACM,SAAR,CAAkB1B,KAAzC,KACfW,WAAW,CAACR,OAAZ,EADJ;;AAEA,aAAOf,MAAM,CAACuC,UAAP,CAAkBN,YAAlB,EAAgCD,OAAO,CAACI,SAAR,CAAkBtB,GAAlD,IAAyD,CAAzD,IACHd,MAAM,CAACuC,UAAP,CAAkBF,YAAlB,EAAgCL,OAAO,CAACM,SAAR,CAAkBxB,GAAlD,IAAyD,CAD7D,EACgE;AAC5D,YAAI0B,UAAU,GAAGR,OAAO,CAACE,WAAR,CAAoBO,MAApB,CAA2BR,YAA3B,CAAjB;AACA,YAAIS,UAAU,GAAGnB,WAAW,CAACkB,MAAZ,CAAmBJ,YAAnB,CAAjB;AACAzC,QAAAA,QAAQ,CAACW,OAAT,CAAiBoC,WAAjB,CAA6BH,UAA7B,EAAyCE,UAAzC;AACA,YAAIE,UAAU,GAAGZ,OAAO,CAACE,WAAR,CAAoBxB,IAArC,CAJ4D,CAK5D;;AACAkB,QAAAA,GAAG,CAACiB,UAAJ,CAAe;AACXC,UAAAA,MAAM,EAAEF,UADG;AAEXG,UAAAA,QAAQ,EAAE;AAAEC,YAAAA,IAAI,EAAEf,YAAY,CAACe,IAArB;AAA2BC,YAAAA,MAAM,EAAEhB,YAAY,CAACgB;AAAhD,WAFC;AAGXC,UAAAA,SAAS,EAAE;AAAEF,YAAAA,IAAI,EAAEX,YAAY,CAACW,IAArB;AAA2BC,YAAAA,MAAM,EAAEZ,YAAY,CAACY;AAAhD;AAHA,SAAf;;AAKA,YAAI,CAACE,MAAM,CAACC,IAAP,CAAYtB,iBAAZ,EAA+Bc,UAA/B,CAAL,EAAiD;AAC7C,cAAIS,aAAa,GAAGrB,OAAO,CAACE,WAAR,CAAoBjB,QAApB,EAApB;AACAW,UAAAA,GAAG,CAAC0B,gBAAJ,CAAqBV,UAArB,EAAiCS,aAAjC;AACAvB,UAAAA,iBAAiB,CAACc,UAAD,CAAjB,GAAgCS,aAAhC;AACH;;AACD9B,QAAAA,WAAW,CAACgC,OAAZ,CAAoBlB,YAApB,EAAkC,IAAlC;AACAL,QAAAA,OAAO,CAACE,WAAR,CAAoBqB,OAApB,CAA4BtB,YAA5B,EAA0C,IAA1C;AACH;AACJ,KAzBD;AA0BAV,IAAAA,WAAW,CAAClB,eAAZ,GAA8BuB,GAA9B;AACA,WAAOA,GAAG,CAACD,MAAJ,EAAP;AACH,GArDD;;AAsDAlC,EAAAA,KAAK,CAACuB,SAAN,CAAgBwC,eAAhB,GAAkC,UAAUC,GAAV,EAAe;AAC7C7D,IAAAA,QAAQ,CAACW,OAAT,CAAiBoC,WAAjB,CAA6B,OAAOc,GAApC,EAAyC,QAAzC;AACA7D,IAAAA,QAAQ,CAACW,OAAT,CAAiBoC,WAAjB,CAA6B,OAAOc,GAAG,CAACT,IAAxC,EAA8C,QAA9C;AACApD,IAAAA,QAAQ,CAACW,OAAT,CAAiBoC,WAAjB,CAA6B,OAAOc,GAAG,CAACR,MAAxC,EAAgD,QAAhD;AACA,QAAID,IAAI,GAAGS,GAAG,CAACT,IAAf;AAAA,QAAqBC,MAAM,GAAGQ,GAAG,CAACR,MAAlC;AAAA,QAA0CS,OAAO,GAAG,KAAKzC,QAAL,GAAgB0C,KAAhB,CAAsBC,oBAAtB,CAApD;AAAA,QAAiGC,MAAM,GAAGH,OAAO,CAACV,IAAI,GAAG,CAAR,CAAjH;AACA,QAAI,OAAOa,MAAP,KAAkB,WAAtB,EACI,OAAO,EAAP;AACJ,QAAIZ,MAAM,KAAKY,MAAM,CAACpD,MAAlB,IAA4BuC,IAAI,GAAGU,OAAO,CAACjD,MAA/C,EACI,OAAO,IAAP;AACJ,QAAIwC,MAAM,IAAIY,MAAM,CAACpD,MAArB,EACI,OAAO,EAAP;AACJ,WAAOoD,MAAM,CAACpB,MAAP,CAAcQ,MAAd,CAAP;AACH,GAZD;;AAaAxD,EAAAA,KAAK,CAACuB,SAAN,CAAgByB,MAAhB,GAAyB,UAAUgB,GAAV,EAAe;AACpC7D,IAAAA,QAAQ,CAACW,OAAT,CAAiBoC,WAAjB,CAA6B,OAAOc,GAApC,EAAyC,QAAzC;AACA7D,IAAAA,QAAQ,CAACW,OAAT,CAAiBoC,WAAjB,CAA6B,OAAOc,GAAG,CAACT,IAAxC,EAA8C,QAA9C;AACApD,IAAAA,QAAQ,CAACW,OAAT,CAAiBoC,WAAjB,CAA6B,OAAOc,GAAG,CAACR,MAAxC,EAAgD,QAAhD;AACA,QAAID,IAAI,GAAGS,GAAG,CAACT,IAAf;AAAA,QAAqBC,MAAM,GAAGQ,GAAG,CAACR,MAAlC;AAAA,QAA0Ca,MAAM,GAAG,IAAnD;AAAA,QAAyD5D,KAAK,GAAG4D,MAAM,CAAC5D,KAAxE;AAAA,QAA+E6D,IAAI,GAAG7D,KAAK,CAAC8C,IAAI,GAAG,CAAR,CAA3F;AAAA,QAAuGgB,CAAC,GAAGf,MAA3G;AACA,QAAI,OAAOc,IAAP,KAAgB,WAAhB,IAA+BC,CAAC,GAAG,CAAvC,EACI,OAAO,EAAP;AACJ,QAAIC,MAAM,GAAG,KAAKC,WAAL,CAAiBlB,IAAjB,CAAb;AACA,QAAIgB,CAAC,GAAGC,MAAR,EACI,OAAO,GAAP;AACJD,IAAAA,CAAC,IAAID,IAAI,CAACI,UAAL,GAAkBF,MAAvB;AACA,QAAID,CAAC,KAAKD,IAAI,CAACK,QAAX,IAAuBpB,IAAI,GAAG,KAAKvC,MAAvC,EACI,OAAO,IAAP;AACJ,QAAIuD,CAAC,IAAID,IAAI,CAACK,QAAd,EACI,OAAO,EAAP;AACJ,WAAOL,IAAI,CAACf,IAAL,CAAUP,MAAV,CAAiBuB,CAAjB,CAAP;AACH,GAhBD;;AAiBAvE,EAAAA,KAAK,CAACuB,SAAN,CAAgBqD,WAAhB,GAA8B,UAAUC,KAAV,EAAiBC,aAAjB,EAAgC;AAC1D,QAAID,KAAK,KAAK,CAAd,EACI,OAAO,IAAP;AACJ1E,IAAAA,QAAQ,CAACW,OAAT,CAAiBC,EAAjB,CAAoB8D,KAAK,GAAG,CAA5B,EAA+B,sBAAsBA,KAArD;AACA,QAAIC,aAAa,IAAI,KAAK9D,MAAL,KAAgB,CAArC,EACI,OAAO,IAAP;AACJ,QAAI+D,KAAK,GAAG,IAAI/E,KAAJ,CAAU,KAAKS,KAAL,CAAWuE,GAAX,CAAe,UAAUV,IAAV,EAAgBW,CAAhB,EAAmB;AACpD,UAAIX,IAAI,CAACf,IAAL,KAAc0B,CAAC,GAAG,CAAJ,IAAS,CAACH,aAAxB,CAAJ,EAA4C;AACxCR,QAAAA,IAAI,GAAGrE,OAAO,CAACiF,QAAR,CAAiBjF,OAAO,CAACiF,QAAR,CAAiB,EAAjB,EAAqBZ,IAArB,CAAjB,EAA6C;AAAEE,UAAAA,MAAM,EAAEW,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYd,IAAI,CAACE,MAAL,GAAcK,KAA1B;AAAV,SAA7C,CAAP;AACH;;AACD,aAAOP,IAAP;AACH,KALqB,CAAV,CAAZ;;AAMA,QAAI,KAAK3D,QAAL,CAAcK,MAAd,GAAuB,CAA3B,EAA8B;AAC1B,UAAIqE,aAAa,GAAGN,KAAK,CAACpE,QAA1B;AACAR,MAAAA,QAAQ,CAACW,OAAT,CAAiBoC,WAAjB,CAA6BmC,aAAa,CAACrE,MAA3C,EAAmD,CAAnD;AACA,WAAKL,QAAL,CAAc2B,OAAd,CAAsB,UAAUC,OAAV,EAAmB;AACrC8C,QAAAA,aAAa,CAACnE,IAAd,CAAmBqB,OAAO,CAACiC,MAAR,CAAeK,KAAf,EAAsBC,aAAtB,EAAqC,IAArC,CAAnB;AACH,OAFD;AAGH;;AACD,WAAOC,KAAP;AACH,GApBD;;AAqBA/E,EAAAA,KAAK,CAACuB,SAAN,CAAgBiD,MAAhB,GAAyB,UAAUc,EAAV,EAAc;AACnC,QAAIA,EAAE,KAAK,CAAX,EAAc;AACV,aAAO,IAAP;AACH;;AACD,QAAIP,KAAK,GAAG,IAAI/E,KAAJ,CAAU,KAAKS,KAAL,CAAWuE,GAAX,CAAe,UAAUV,IAAV,EAAgB;AACjD,UAAIA,IAAI,CAACf,IAAL,IAAa,CAACe,IAAI,CAACiB,MAAvB,EAA+B;AAC3BjB,QAAAA,IAAI,GAAGrE,OAAO,CAACiF,QAAR,CAAiBjF,OAAO,CAACiF,QAAR,CAAiB,EAAjB,EAAqBZ,IAArB,CAAjB,EAA6C;AAAEE,UAAAA,MAAM,EAAEF,IAAI,CAACE,MAAL,GAAcc;AAAxB,SAA7C,CAAP;AACH;;AACD,aAAOhB,IAAP;AACH,KALqB,CAAV,CAAZ;;AAMA,QAAI,KAAK3D,QAAL,CAAcK,MAAd,GAAuB,CAA3B,EAA8B;AAC1B,UAAIwE,aAAa,GAAGT,KAAK,CAACpE,QAA1B;AACAR,MAAAA,QAAQ,CAACW,OAAT,CAAiBoC,WAAjB,CAA6BsC,aAAa,CAACxE,MAA3C,EAAmD,CAAnD;AACA,WAAKL,QAAL,CAAc2B,OAAd,CAAsB,UAAUC,OAAV,EAAmB;AACrCiD,QAAAA,aAAa,CAACtE,IAAd,CAAmBqB,OAAO,CAACiC,MAAR,CAAec,EAAf,CAAnB;AACH,OAFD;AAGH;;AACD,WAAOP,KAAP;AACH,GAlBD;;AAmBA/E,EAAAA,KAAK,CAACuB,SAAN,CAAgBkE,UAAhB,GAA6B,UAAUH,EAAV,EAAc;AACvC,QAAIA,EAAE,KAAK,CAAX,EAAc;AACV,aAAO,IAAP;AACH;;AACD,QAAI,KAAKtE,MAAL,GAAc,CAAlB,EAAqB;AACjB,aAAO,IAAP;AACH;;AACD,QAAI+D,KAAK,GAAG,IAAI/E,KAAJ,CAAU,KAAKS,KAAL,CAAWuE,GAAX,CAAe,UAAUV,IAAV,EAAgBW,CAAhB,EAAmB;AACpD,UAAIA,CAAC,GAAG,CAAJ,IAASX,IAAI,CAACf,IAAd,IAAsB,CAACe,IAAI,CAACiB,MAAhC,EAAwC;AACpCjB,QAAAA,IAAI,GAAGrE,OAAO,CAACiF,QAAR,CAAiBjF,OAAO,CAACiF,QAAR,CAAiB,EAAjB,EAAqBZ,IAArB,CAAjB,EAA6C;AAAEE,UAAAA,MAAM,EAAEF,IAAI,CAACE,MAAL,GAAcc;AAAxB,SAA7C,CAAP;AACH;;AACD,aAAOhB,IAAP;AACH,KALqB,CAAV,CAAZ;;AAMA,QAAI,KAAK3D,QAAL,CAAcK,MAAd,GAAuB,CAA3B,EAA8B;AAC1B,UAAI0E,aAAa,GAAGX,KAAK,CAACpE,QAA1B;AACAR,MAAAA,QAAQ,CAACW,OAAT,CAAiBoC,WAAjB,CAA6BwC,aAAa,CAAC1E,MAA3C,EAAmD,CAAnD;AACA,WAAKL,QAAL,CAAc2B,OAAd,CAAsB,UAAUC,OAAV,EAAmB;AACrCmD,QAAAA,aAAa,CAACxE,IAAd,CAAmBqB,OAAO,CAACiC,MAAR,CAAec,EAAf,EAAmB,IAAnB,CAAnB;AACH,OAFD;AAGH;;AACD,WAAOP,KAAP;AACH,GArBD;;AAsBA/E,EAAAA,KAAK,CAACuB,SAAN,CAAgBoE,cAAhB,GAAiC,YAAY;AACzC,QAAI,KAAK3E,MAAL,GAAc,CAAlB,EAAqB;AACjB,aAAO,IAAP;AACH;;AACD,WAAO,IAAIhB,KAAJ,CAAU,KAAKS,KAAL,CAAWuE,GAAX,CAAe,UAAUV,IAAV,EAAgBW,CAAhB,EAAmB;AAAE,aAAQhF,OAAO,CAACiF,QAAR,CAAiBjF,OAAO,CAACiF,QAAR,CAAiB,EAAjB,EAAqBZ,IAArB,CAAjB,EAA6C;AAAEiB,QAAAA,MAAM,EAAEN,CAAC,GAAG;AAAd,OAA7C,CAAR;AAA2E,KAA/G,CAAV,CAAP;AACH,GALD;;AAMAjF,EAAAA,KAAK,CAACuB,SAAN,CAAgBkD,WAAhB,GAA8B,UAAUlB,IAAV,EAAgB;AAC1CpD,IAAAA,QAAQ,CAACW,OAAT,CAAiBC,EAAjB,CAAoBwC,IAAI,IAAI,CAA5B,EAA+B,aAAaA,IAAb,GAAoB,8BAAnD;AACA,WAAO4B,IAAI,CAACC,GAAL,CAAS,KAAK3E,KAAL,CAAW8C,IAAI,GAAG,CAAlB,EAAqBiB,MAA9B,EAAsC,CAAtC,CAAP;AACH,GAHD;;AAIAxE,EAAAA,KAAK,CAACuB,SAAN,CAAgBqE,aAAhB,GAAgC,YAAY;AACxC,QAAI,OAAO,KAAK/E,cAAZ,KAA+B,QAAnC,EAA6C;AACzC,aAAO,KAAKA,cAAZ;AACH;;AACD,QAAIgF,MAAM,GAAG,EAAb,CAJwC,CAIvB;;AACjB,QAAIC,UAAU,GAAG,CAAjB;;AACA,SAAK,IAAIvC,IAAI,GAAG,CAAX,EAAcwC,IAAI,GAAG,KAAK/E,MAA/B,EAAuCuC,IAAI,IAAIwC,IAA/C,EAAqD,EAAExC,IAAvD,EAA6D;AACzD,UAAIe,IAAI,GAAG,KAAK7D,KAAL,CAAW8C,IAAI,GAAG,CAAlB,CAAX;AACA,UAAIyC,MAAM,GAAG1B,IAAI,CAACf,IAAL,CAAU0C,KAAV,CAAgB3B,IAAI,CAACI,UAArB,EAAiCJ,IAAI,CAACK,QAAtC,CAAb,CAFyD,CAGzD;AACA;;AACA,UAAIuB,gBAAgB,CAACF,MAAD,CAApB,EAA8B;AAC1B;AACH;;AACD,UAAIG,IAAI,GAAGhB,IAAI,CAACiB,GAAL,CAAS9B,IAAI,CAACE,MAAL,GAAcsB,UAAvB,CAAX;AACAD,MAAAA,MAAM,CAACM,IAAD,CAAN,GAAe,CAAC,CAACN,MAAM,CAACM,IAAD,CAAR,GAAiB,CAAhC;AACAL,MAAAA,UAAU,GAAGxB,IAAI,CAACE,MAAlB;AACH;;AACD,QAAI6B,QAAQ,GAAG,CAAC,CAAhB;AACA,QAAIC,MAAM,GAAG,CAAb;;AACA,SAAK,IAAIC,QAAQ,GAAG,CAApB,EAAuBA,QAAQ,GAAGV,MAAM,CAAC7E,MAAzC,EAAiDuF,QAAQ,IAAI,CAA7D,EAAgE;AAC5D,UAAI7C,MAAM,CAACC,IAAP,CAAYkC,MAAZ,EAAoBU,QAApB,KAAiCV,MAAM,CAACU,QAAD,CAAN,GAAmBF,QAAxD,EAAkE;AAC9DA,QAAAA,QAAQ,GAAGR,MAAM,CAACU,QAAD,CAAjB;AACAD,QAAAA,MAAM,GAAGC,QAAT;AACH;AACJ;;AACD,WAAQ,KAAK1F,cAAL,GAAsByF,MAA9B;AACH,GA3BD,CAhLmC,CA4MnC;AACA;AACA;;;AACAtG,EAAAA,KAAK,CAACuB,SAAN,CAAgBiF,iBAAhB,GAAoC,YAAY;AAC5C,QAAI,KAAK/F,KAAL,CAAWO,MAAX,KAAsB,CAA1B,EAA6B;AACzB,aAAO,KAAP;AACH;;AACD,QAAIyF,aAAa,GAAG,KAAKhG,KAAL,CAAW,CAAX,CAApB;AAAA,QAAmCiE,UAAU,GAAG+B,aAAa,CAAC/B,UAA9D;AAAA,QAA0EC,QAAQ,GAAG8B,aAAa,CAAC9B,QAAnG;AAAA,QAA6G+B,SAAS,GAAGD,aAAa,CAAClD,IAAd,CAAmB0C,KAAnB,CAAyBvB,UAAzB,EAAqCC,QAArC,EAA+CgC,IAA/C,EAAzH;AACA,WAAQD,SAAS,CAAC1F,MAAV,KAAqB,CAArB,IACJ0F,SAAS,CAACT,KAAV,CAAgB,CAAhB,EAAmB,CAAnB,MAA0B,IADtB,IAEJS,SAAS,CAACT,KAAV,CAAgB,CAAhB,EAAmB,CAAnB,MAA0B,IAF9B;AAGH,GARD;;AASAjG,EAAAA,KAAK,CAACuB,SAAN,CAAgB2E,gBAAhB,GAAmC,YAAY;AAC3C,WAAOA,gBAAgB,CAAC,KAAK1E,QAAL,EAAD,CAAvB;AACH,GAFD;;AAGAxB,EAAAA,KAAK,CAACuB,SAAN,CAAgBqF,0BAAhB,GAA6C,UAAU5C,GAAV,EAAe;AACxD,QAAIM,IAAI,GAAG,KAAK7D,KAAL,CAAWuD,GAAG,CAACT,IAAJ,GAAW,CAAtB,CAAX;AACA,QAAIiB,MAAM,GAAGW,IAAI,CAACC,GAAL,CAASd,IAAI,CAACE,MAAd,EAAsB,CAAtB,CAAb;AACA,QAAI2B,IAAI,GAAGnC,GAAG,CAACR,MAAJ,GAAagB,MAAxB;;AACA,QAAI2B,IAAI,IAAI,CAAZ,EAAe;AACX;AACA;AACA,aAAO,IAAP;AACH;;AACD,QAAIhF,KAAK,GAAGmD,IAAI,CAACI,UAAjB;AACA,QAAIrD,GAAG,GAAG8D,IAAI,CAAC0B,GAAL,CAAS1F,KAAK,GAAGgF,IAAjB,EAAuB7B,IAAI,CAACK,QAA5B,CAAV;AACA,QAAImC,MAAM,GAAGxC,IAAI,CAACf,IAAL,CAAU0C,KAAV,CAAgB9E,KAAhB,EAAuBE,GAAvB,CAAb;AACA,WAAO6E,gBAAgB,CAACY,MAAD,CAAvB;AACH,GAbD;;AAcA9G,EAAAA,KAAK,CAACuB,SAAN,CAAgBwF,aAAhB,GAAgC,UAAUxD,IAAV,EAAgB;AAC5C,QAAIe,IAAI,GAAG,KAAK7D,KAAL,CAAW8C,IAAI,GAAG,CAAlB,CAAX;AACA,WAAO,KAAKkB,WAAL,CAAiBlB,IAAjB,IAAyBe,IAAI,CAACK,QAA9B,GAAyCL,IAAI,CAACI,UAArD;AACH,GAHD;;AAIA1E,EAAAA,KAAK,CAACuB,SAAN,CAAgBuC,OAAhB,GAA0B,UAAUE,GAAV,EAAetB,UAAf,EAA2B;AACjD,QAAIA,UAAU,KAAK,KAAK,CAAxB,EAA2B;AAAEA,MAAAA,UAAU,GAAG,KAAb;AAAqB;;AAClD,QAAIsE,CAAC,GAAG7B,IAAI,CAACC,GAAL,CAASpB,GAAG,CAACT,IAAb,EAAmB,CAAnB,CAAR;AAAA,QAA+BgB,CAAC,GAAGY,IAAI,CAACC,GAAL,CAASpB,GAAG,CAACR,MAAb,EAAqB,CAArB,CAAnC;;AACA,QAAIe,CAAC,GAAG,KAAKwC,aAAL,CAAmBC,CAAnB,CAAR,EAA+B;AAC3BhD,MAAAA,GAAG,CAACR,MAAJ,IAAc,CAAd;AACA,aAAOd,UAAU,GAAG,CAAC,CAAC,KAAKA,UAAL,CAAgBsB,GAAhB,EAAqB,KAArB,EAA4B,IAA5B,CAAL,GAAyC,IAA1D;AACH;;AACD,QAAIgD,CAAC,GAAG,KAAKhG,MAAb,EAAqB;AACjBgD,MAAAA,GAAG,CAACT,IAAJ,IAAY,CAAZ;AACAS,MAAAA,GAAG,CAACR,MAAJ,GAAa,CAAb;AACA,aAAOd,UAAU,GAAG,CAAC,CAAC,KAAKA,UAAL,CAAgBsB,GAAhB,EAAqB,KAArB,EAA4B,IAA5B,CAAL,GAAyC,IAA1D;AACH;;AACD,WAAO,KAAP;AACH,GAbD;;AAcAhE,EAAAA,KAAK,CAACuB,SAAN,CAAgB0F,OAAhB,GAA0B,UAAUjD,GAAV,EAAetB,UAAf,EAA2B;AACjD,QAAIA,UAAU,KAAK,KAAK,CAAxB,EAA2B;AAAEA,MAAAA,UAAU,GAAG,KAAb;AAAqB;;AAClD,QAAIsE,CAAC,GAAGhD,GAAG,CAACT,IAAZ;AAAA,QAAkBgB,CAAC,GAAGP,GAAG,CAACR,MAA1B;;AACA,QAAIe,CAAC,GAAG,CAAR,EAAW;AACPyC,MAAAA,CAAC,IAAI,CAAL;AACA,UAAIA,CAAC,GAAG,CAAR,EACI,OAAO,KAAP;AACJzC,MAAAA,CAAC,GAAG,KAAKwC,aAAL,CAAmBC,CAAnB,CAAJ;AACH,KALD,MAMK;AACDzC,MAAAA,CAAC,GAAGY,IAAI,CAAC0B,GAAL,CAAStC,CAAC,GAAG,CAAb,EAAgB,KAAKwC,aAAL,CAAmBC,CAAnB,CAAhB,CAAJ;AACH;;AACDhD,IAAAA,GAAG,CAACT,IAAJ,GAAWyD,CAAX;AACAhD,IAAAA,GAAG,CAACR,MAAJ,GAAae,CAAb;AACA,WAAO7B,UAAU,GAAG,CAAC,CAAC,KAAKA,UAAL,CAAgBsB,GAAhB,EAAqB,IAArB,EAA2B,IAA3B,CAAL,GAAwC,IAAzD;AACH,GAfD;;AAgBAhE,EAAAA,KAAK,CAACuB,SAAN,CAAgBH,QAAhB,GAA2B,YAAY;AACnC;AACA,WAAO;AAAEmC,MAAAA,IAAI,EAAE,CAAR;AAAWC,MAAAA,MAAM,EAAE;AAAnB,KAAP;AACH,GAHD;;AAIAxD,EAAAA,KAAK,CAACuB,SAAN,CAAgBD,OAAhB,GAA0B,YAAY;AAClC,WAAO;AACHiC,MAAAA,IAAI,EAAE,KAAKvC,MADR;AAEHwC,MAAAA,MAAM,EAAE,KAAKuD,aAAL,CAAmB,KAAK/F,MAAxB;AAFL,KAAP;AAIH,GALD;;AAMAhB,EAAAA,KAAK,CAACuB,SAAN,CAAgBmB,UAAhB,GAA6B,UAAUsB,GAAV,EAAekD,QAAf,EAAyBC,aAAzB,EAAwC;AACjE,QAAID,QAAQ,KAAK,KAAK,CAAtB,EAAyB;AAAEA,MAAAA,QAAQ,GAAG,KAAX;AAAmB;;AAC9C,QAAIC,aAAa,KAAK,KAAK,CAA3B,EAA8B;AAAEA,MAAAA,aAAa,GAAG,KAAhB;AAAwB;;AACxD,QAAInD,GAAJ,EAAS;AACLA,MAAAA,GAAG,GAAGmD,aAAa,GACbnD,GADa,GAEb;AACET,QAAAA,IAAI,EAAES,GAAG,CAACT,IADZ;AAEEC,QAAAA,MAAM,EAAEQ,GAAG,CAACR;AAFd,OAFN;AAMH,KAPD,MAQK,IAAI0D,QAAJ,EAAc;AACflD,MAAAA,GAAG,GAAG,KAAK1C,OAAL,EAAN;AACH,KAFI,MAGA;AACD0C,MAAAA,GAAG,GAAG,KAAK5C,QAAL,EAAN;AACH;;AACD,QAAI8F,QAAJ,EAAc;AACV,aAAO,KAAKD,OAAL,CAAajD,GAAb,CAAP,EAA0B;AACtB,YAAI,CAACkC,gBAAgB,CAAC,KAAKlD,MAAL,CAAYgB,GAAZ,CAAD,CAAjB,IAAuC,KAAKF,OAAL,CAAaE,GAAb,CAA3C,EAA8D;AAC1D,iBAAOA,GAAP;AACH;AACJ;;AACD,aAAO,IAAP;AACH,KAPD,MAQK;AACD,aAAOkC,gBAAgB,CAAC,KAAKlD,MAAL,CAAYgB,GAAZ,CAAD,CAAvB,EAA2C;AACvC,YAAI,CAAC,KAAKF,OAAL,CAAaE,GAAb,CAAL,EAAwB;AACpB,iBAAO,IAAP;AACH;AACJ;;AACD,aAAOA,GAAP;AACH;AACJ,GAjCD;;AAkCAhE,EAAAA,KAAK,CAACuB,SAAN,CAAgB6F,QAAhB,GAA2B,YAAY;AACnC,QAAIpD,GAAG,GAAG,KAAKtB,UAAL,CAAgB,KAAKtB,QAAL,EAAhB,EAAiC,KAAjC,EAAwC,IAAxC,CAAV;AACA,WAAO4C,GAAG,GAAG,KAAKiC,KAAL,CAAWjC,GAAX,CAAH,GAAqBqD,UAA/B;AACH,GAHD;;AAIArH,EAAAA,KAAK,CAACuB,SAAN,CAAgB+F,SAAhB,GAA4B,YAAY;AACpC,QAAItD,GAAG,GAAG,KAAKtB,UAAL,CAAgB,KAAKpB,OAAL,EAAhB,EAAgC,IAAhC,EAAsC,IAAtC,CAAV;AACA,WAAO0C,GAAG,GAAG,KAAKiC,KAAL,CAAW,KAAK7E,QAAL,EAAX,EAA4B4C,GAA5B,CAAH,GAAsCqD,UAAhD;AACH,GAHD;;AAIArH,EAAAA,KAAK,CAACuB,SAAN,CAAgBoF,IAAhB,GAAuB,YAAY;AAC/B,QAAIxF,KAAK,GAAG,KAAKuB,UAAL,CAAgB,KAAKtB,QAAL,EAAhB,EAAiC,KAAjC,EAAwC,IAAxC,CAAZ;;AACA,QAAID,KAAK,KAAK,IAAd,EAAoB;AAChB,aAAOkG,UAAP;AACH;;AACD,QAAIhG,GAAG,GAAG,KAAKqB,UAAL,CAAgB,KAAKpB,OAAL,EAAhB,EAAgC,IAAhC,EAAsC,IAAtC,CAAV;;AACA,QAAID,GAAG,KAAK,IAAZ,EAAkB;AACd,aAAOgG,UAAP;AACH;;AACD,WAAO,KAAKpB,KAAL,CAAW9E,KAAX,EAAkBE,GAAlB,CAAP;AACH,GAVD;;AAWArB,EAAAA,KAAK,CAACuB,SAAN,CAAgBgG,OAAhB,GAA0B,UAAUC,QAAV,EAAoBC,QAApB,EAA8B/E,UAA9B,EAA0C;AAChE,QAAI+E,QAAQ,KAAK,KAAK,CAAtB,EAAyB;AAAEA,MAAAA,QAAQ,GAAG,KAAKrG,QAAL,EAAX;AAA6B;;AACxD,QAAIsB,UAAU,KAAK,KAAK,CAAxB,EAA2B;AAAEA,MAAAA,UAAU,GAAG,KAAb;AAAqB;;AAClD,QAAIsB,GAAG,GAAG,KAAK5C,QAAL,EAAV;;AACA,QAAIqG,QAAJ,EAAc;AACTzD,MAAAA,GAAG,CAACT,IAAJ,GAAWkE,QAAQ,CAAClE,IAArB,EAA6BS,GAAG,CAACR,MAAJ,GAAaiE,QAAQ,CAACjE,MAAnD;AACH;;AACD,QAAId,UAAU,IAAI,CAAC,KAAKA,UAAL,CAAgBsB,GAAhB,EAAqB,KAArB,EAA4B,IAA5B,CAAnB,EAAsD;AAClD,aADkD,CAC1C;AACX;;AACD,OACIwD,QAAQ,CAAC7D,IAAT,CAAc,IAAd,EAAoBK,GAApB,EADJ,QAEO,KAAKF,OAAL,CAAaE,GAAb,EAAkBtB,UAAlB,CAFP;AAGH,GAbD;;AAcA1C,EAAAA,KAAK,CAACuB,SAAN,CAAgBmG,cAAhB,GAAiC,UAAUvG,KAAV,EAAiBE,GAAjB,EAAsB;AACnD,QAAI4C,OAAO,GAAG,KAAKzC,QAAL,GACT0C,KADS,CACHC,oBADG,EAET8B,KAFS,CAEH9E,KAAK,CAACoC,IAAN,GAAa,CAFV,EAEalC,GAAG,CAACkC,IAFjB,CAAd;;AAGA,QAAIU,OAAO,CAACjD,MAAR,GAAiB,CAArB,EAAwB;AACpBiD,MAAAA,OAAO,CAAC/C,IAAR,CAAa+C,OAAO,CAAC0D,GAAR,GAAc1B,KAAd,CAAoB,CAApB,EAAuB5E,GAAG,CAACmC,MAA3B,CAAb;AACAS,MAAAA,OAAO,CAAC,CAAD,CAAP,GAAaA,OAAO,CAAC,CAAD,CAAP,CAAWgC,KAAX,CAAiB9E,KAAK,CAACqC,MAAvB,CAAb;AACH;;AACD,WAAO1D,UAAU,CAACmE,OAAO,CAAC2D,IAAR,CAAa,IAAb,CAAD,CAAjB;AACH,GATD;;AAUA5H,EAAAA,KAAK,CAACuB,SAAN,CAAgB0E,KAAhB,GAAwB,UAAU9E,KAAV,EAAiBE,GAAjB,EAAsB;AAC1C,QAAI,CAACA,GAAL,EAAU;AACN,UAAI,CAACF,KAAL,EAAY;AACR;AACA;AACA;AACA,eAAO,IAAP;AACH,OANK,CAON;;;AACAE,MAAAA,GAAG,GAAG,KAAKC,OAAL,EAAN;AACH;;AACD,QAAI,CAACH,KAAL,EAAY;AACR,YAAM,IAAI0G,KAAJ,CAAU,qCAAV,CAAN;AACH;;AACD,QAAI7B,MAAM,GAAG,KAAKvF,KAAL,CAAWwF,KAAX,CAAiB9E,KAAK,CAACoC,IAAN,GAAa,CAA9B,EAAiClC,GAAG,CAACkC,IAArC,CAAb;;AACA,QAAIpC,KAAK,CAACoC,IAAN,KAAelC,GAAG,CAACkC,IAAvB,EAA6B;AACzByC,MAAAA,MAAM,CAAC,CAAD,CAAN,GAAY8B,SAAS,CAAC9B,MAAM,CAAC,CAAD,CAAP,EAAY7E,KAAK,CAACqC,MAAlB,EAA0BnC,GAAG,CAACmC,MAA9B,CAArB;AACH,KAFD,MAGK;AACDrD,MAAAA,QAAQ,CAACW,OAAT,CAAiBC,EAAjB,CAAoBI,KAAK,CAACoC,IAAN,GAAalC,GAAG,CAACkC,IAArC;AACAyC,MAAAA,MAAM,CAAC,CAAD,CAAN,GAAY8B,SAAS,CAAC9B,MAAM,CAAC,CAAD,CAAP,EAAY7E,KAAK,CAACqC,MAAlB,CAArB;AACAwC,MAAAA,MAAM,CAAC9E,IAAP,CAAY4G,SAAS,CAAC9B,MAAM,CAAC2B,GAAP,EAAD,EAAe,CAAf,EAAkBtG,GAAG,CAACmC,MAAtB,CAArB;AACH;;AACD,QAAIuB,KAAK,GAAG,IAAI/E,KAAJ,CAAUgG,MAAV,CAAZ;;AACA,QAAI,KAAKrF,QAAL,CAAcK,MAAd,GAAuB,CAA3B,EAA8B;AAC1B,UAAI+G,aAAa,GAAGhD,KAAK,CAACpE,QAA1B;AACAR,MAAAA,QAAQ,CAACW,OAAT,CAAiBoC,WAAjB,CAA6B6E,aAAa,CAAC/G,MAA3C,EAAmD,CAAnD;AACA,WAAKL,QAAL,CAAc2B,OAAd,CAAsB,UAAUC,OAAV,EAAmB;AACrC,YAAIyD,MAAM,GAAGzD,OAAO,CAAC0D,KAAR,CAAc,IAAd,EAAoB9E,KAApB,EAA2BE,GAA3B,CAAb;;AACA,YAAI2E,MAAJ,EAAY;AACR+B,UAAAA,aAAa,CAAC7G,IAAd,CAAmB8E,MAAnB;AACH;AACJ,OALD,EAKG,IALH;AAMH;;AACD,WAAOjB,KAAP;AACH,GAnCD;;AAoCA/E,EAAAA,KAAK,CAACuB,SAAN,CAAgByG,oBAAhB,GAAuC,UAAU7G,KAAV,EAAiBE,GAAjB,EAAsBI,OAAtB,EAA+B;AAClE,WAAO,KAAKwE,KAAL,CAAW9E,KAAX,EAAkBE,GAAlB,EAAuBG,QAAvB,CAAgCC,OAAhC,CAAP;AACH,GAFD;;AAGAzB,EAAAA,KAAK,CAACuB,SAAN,CAAgBG,WAAhB,GAA8B,UAAUP,KAAV,EAAiBE,GAAjB,EAAsBI,OAAtB,EAA+B;AACzD,QAAIN,KAAK,KAAK,KAAK,CAAnB,EAAsB;AAAEA,MAAAA,KAAK,GAAG,KAAKC,QAAL,EAAR;AAA0B;;AAClD,QAAIC,GAAG,KAAK,KAAK,CAAjB,EAAoB;AAAEA,MAAAA,GAAG,GAAG,KAAKC,OAAL,EAAN;AAAuB;;AAC7C,QAAI2G,EAAE,GAAG3H,SAAS,CAAC4H,SAAV,CAAoBzG,OAApB,CAAT;AAAA,QAAuC8E,QAAQ,GAAG0B,EAAE,CAAC1B,QAArD;AAAA,QAA+D4B,OAAO,GAAGF,EAAE,CAACE,OAA5E;AAAA,QAAqFC,eAAe,GAAGH,EAAE,CAACG,eAA1G;AAAA,QAA2HC,cAAc,GAAGJ,EAAE,CAACI,cAA/I;;AACA,QAAIC,KAAK,GAAG,EAAZ;;AACA,SAAK,IAAI/E,IAAI,GAAGpC,KAAK,CAACoC,IAAtB,EAA4BA,IAAI,IAAIlC,GAAG,CAACkC,IAAxC,EAA8C,EAAEA,IAAhD,EAAsD;AAClD,UAAIe,IAAI,GAAG,KAAK7D,KAAL,CAAW8C,IAAI,GAAG,CAAlB,CAAX;;AACA,UAAIA,IAAI,KAAKpC,KAAK,CAACoC,IAAnB,EAAyB;AACrB,YAAIA,IAAI,KAAKlC,GAAG,CAACkC,IAAjB,EAAuB;AACnBe,UAAAA,IAAI,GAAGwD,SAAS,CAACxD,IAAD,EAAOnD,KAAK,CAACqC,MAAb,EAAqBnC,GAAG,CAACmC,MAAzB,CAAhB;AACH,SAFD,MAGK;AACDc,UAAAA,IAAI,GAAGwD,SAAS,CAACxD,IAAD,EAAOnD,KAAK,CAACqC,MAAb,CAAhB;AACH;AACJ,OAPD,MAQK,IAAID,IAAI,KAAKlC,GAAG,CAACkC,IAAjB,EAAuB;AACxBe,QAAAA,IAAI,GAAGwD,SAAS,CAACxD,IAAD,EAAO,CAAP,EAAUjD,GAAG,CAACmC,MAAd,CAAhB;AACH;;AACD,UAAIgB,MAAM,GAAGW,IAAI,CAACC,GAAL,CAASd,IAAI,CAACE,MAAd,EAAsB,CAAtB,CAAb;AACA,UAAI+D,QAAQ,GAAGjE,IAAI,CAACf,IAAL,CAAU0C,KAAV,CAAgB,CAAhB,EAAmB3B,IAAI,CAACI,UAAxB,CAAf;;AACA,UAAI0D,eAAe,IACflC,gBAAgB,CAACqC,QAAD,CADhB,IAEAxI,WAAW,CAACwI,QAAD,EAAWhC,QAAX,CAAX,KAAoC/B,MAFxC,EAEgD;AAC5C;AACA8D,QAAAA,KAAK,CAACpH,IAAN,CAAWoD,IAAI,CAACf,IAAL,CAAU0C,KAAV,CAAgB,CAAhB,EAAmB3B,IAAI,CAACK,QAAxB,CAAX;AACA;AACH;;AACD,UAAI6D,IAAI,GAAG,CAAX;AACA,UAAIC,MAAM,GAAGjE,MAAb;;AACA,UAAI2D,OAAJ,EAAa;AACTK,QAAAA,IAAI,GAAGrD,IAAI,CAACuD,KAAL,CAAWlE,MAAM,GAAG+B,QAApB,CAAP;AACAkC,QAAAA,MAAM,IAAID,IAAI,GAAGjC,QAAjB;AACH;;AACD,UAAID,MAAM,GAAG,EAAb;;AACA,UAAIkC,IAAI,GAAG,CAAX,EAAc;AACVlC,QAAAA,MAAM,IAAI,IAAIqC,KAAJ,CAAUH,IAAI,GAAG,CAAjB,EAAoBZ,IAApB,CAAyB,IAAzB,CAAV;AACH;;AACD,UAAIa,MAAM,GAAG,CAAb,EAAgB;AACZnC,QAAAA,MAAM,IAAI,IAAIqC,KAAJ,CAAUF,MAAM,GAAG,CAAnB,EAAsBb,IAAtB,CAA2B,GAA3B,CAAV;AACH;;AACDtB,MAAAA,MAAM,IAAIhC,IAAI,CAACf,IAAL,CAAU0C,KAAV,CAAgB3B,IAAI,CAACI,UAArB,EAAiCJ,IAAI,CAACK,QAAtC,CAAV;AACA2D,MAAAA,KAAK,CAACpH,IAAN,CAAWoF,MAAX;AACH;;AACD,WAAOgC,KAAK,CAACV,IAAN,CAAWS,cAAX,CAAP;AACH,GA5CD;;AA6CArI,EAAAA,KAAK,CAACuB,SAAN,CAAgBqH,OAAhB,GAA0B,YAAY;AAClC,WAAO,KAAK5H,MAAL,GAAc,CAAd,IAAmB,KAAK+F,aAAL,CAAmB,CAAnB,IAAwB,CAAlD;AACH,GAFD;;AAGA/G,EAAAA,KAAK,CAACuB,SAAN,CAAgBqG,IAAhB,GAAuB,UAAUiB,QAAV,EAAoB;AACvC,QAAIC,SAAS,GAAG,IAAhB;AACA,QAAIrI,KAAK,GAAG,EAAZ;AACA,QAAIE,QAAQ,GAAG,EAAf;AACA,QAAIoI,QAAJ;;AACA,aAASC,WAAT,CAAqBC,WAArB,EAAkC;AAC9B,UAAIA,WAAW,KAAK,IAApB,EAA0B;AACtB;AACH;;AACD,UAAIF,QAAJ,EAAc;AACV,YAAIzE,IAAI,GAAG2E,WAAW,CAACxI,KAAZ,CAAkB,CAAlB,CAAX;AACA,YAAI+D,MAAM,GAAG,IAAImE,KAAJ,CAAUrE,IAAI,CAACE,MAAL,GAAc,CAAxB,EAA2BoD,IAA3B,CAAgC,GAAhC,CAAb;AACA,YAAIsB,UAAU,GAAGzI,KAAK,CAACO,MAAvB;AACA,YAAImI,YAAY,GAAGhE,IAAI,CAACC,GAAL,CAAS2D,QAAQ,CAACvE,MAAlB,EAA0B,CAA1B,IACfuE,QAAQ,CAACpE,QADM,GAEfoE,QAAQ,CAACrE,UAFb;AAGAqE,QAAAA,QAAQ,CAACxF,IAAT,GACIwF,QAAQ,CAACxF,IAAT,CAAc0C,KAAd,CAAoB,CAApB,EAAuB8C,QAAQ,CAACpE,QAAhC,IACIH,MADJ,GAEIF,IAAI,CAACf,IAAL,CAAU0C,KAAV,CAAgB3B,IAAI,CAACI,UAArB,EAAiCJ,IAAI,CAACK,QAAtC,CAHR,CAPU,CAWV;AACA;;AACAoE,QAAAA,QAAQ,CAACxD,MAAT,GAAkBwD,QAAQ,CAACxD,MAAT,IAAmBjB,IAAI,CAACiB,MAA1C;AACAwD,QAAAA,QAAQ,CAACpE,QAAT,GAAoBoE,QAAQ,CAACxF,IAAT,CAAcvC,MAAlC;;AACA,YAAIiI,WAAW,CAACtI,QAAZ,CAAqBK,MAArB,GAA8B,CAAlC,EAAqC;AACjCiI,UAAAA,WAAW,CAACtI,QAAZ,CAAqB2B,OAArB,CAA6B,UAAUC,OAAV,EAAmB;AAC5C5B,YAAAA,QAAQ,CAACO,IAAT,CAAcqB,OAAO,CAAC6G,GAAR,CAAYF,UAAZ,EAAwBC,YAAxB,CAAd;AACH,WAFD;AAGH;AACJ,OApBD,MAqBK,IAAIF,WAAW,CAACtI,QAAZ,CAAqBK,MAArB,GAA8B,CAAlC,EAAqC;AACtCL,QAAAA,QAAQ,CAACO,IAAT,CAAcmI,KAAd,CAAoB1I,QAApB,EAA8BsI,WAAW,CAACtI,QAA1C;AACH;;AACDsI,MAAAA,WAAW,CAACxI,KAAZ,CAAkB6B,OAAlB,CAA0B,UAAUgC,IAAV,EAAgBW,CAAhB,EAAmB;AACzC,YAAI,CAAC8D,QAAD,IAAa9D,CAAC,GAAG,CAArB,EAAwB;AACpB8D,UAAAA,QAAQ,GAAG9I,OAAO,CAACiF,QAAR,CAAiB,EAAjB,EAAqBZ,IAArB,CAAX;AACA7D,UAAAA,KAAK,CAACS,IAAN,CAAW6H,QAAX;AACH;AACJ,OALD;AAMH;;AACD,aAASO,mBAAT,CAA6BL,WAA7B,EAA0ChE,CAA1C,EAA6C;AACzC,UAAIA,CAAC,GAAG,CAAR,EACI+D,WAAW,CAACF,SAAD,CAAX;AACJE,MAAAA,WAAW,CAACC,WAAD,CAAX;AACH;;AACDJ,IAAAA,QAAQ,CACH7D,GADL,CACS,UAAUuE,IAAV,EAAgB;AACrB,UAAIxE,KAAK,GAAGjF,UAAU,CAACyJ,IAAD,CAAtB;AACA,UAAIxE,KAAK,CAAC6D,OAAN,EAAJ,EACI,OAAO,IAAP;AACJ,aAAO7D,KAAP;AACH,KAND,EAOKzC,OAPL,CAOa,UAAU2G,WAAV,EAAuBhE,CAAvB,EAA0B;AACnC,UAAI6D,SAAS,CAACF,OAAV,EAAJ,EAAyB;AACrBI,QAAAA,WAAW,CAACC,WAAD,CAAX;AACH,OAFD,MAGK;AACDK,QAAAA,mBAAmB,CAACL,WAAD,EAAchE,CAAd,CAAnB;AACH;AACJ,KAdD;AAeA,QAAIxE,KAAK,CAACO,MAAN,GAAe,CAAnB,EACI,OAAOqG,UAAP;AACJ,QAAItC,KAAK,GAAG,IAAI/E,KAAJ,CAAUS,KAAV,CAAZ;AACAsE,IAAAA,KAAK,CAACpE,QAAN,GAAiBA,QAAjB;AACA,WAAOoE,KAAP;AACH,GAjED;;AAkEA/E,EAAAA,KAAK,CAACuB,SAAN,CAAgB1B,MAAhB,GAAyB,YAAY;AACjC,QAAI2J,IAAI,GAAG,EAAX;;AACA,SAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGC,SAAS,CAAC1I,MAAhC,EAAwCyI,EAAE,EAA1C,EAA8C;AAC1CD,MAAAA,IAAI,CAACC,EAAD,CAAJ,GAAWC,SAAS,CAACD,EAAD,CAApB;AACH;;AACD,QAAIE,IAAI,GAAG,CAAC,IAAD,CAAX;AACAA,IAAAA,IAAI,CAACzI,IAAL,CAAUmI,KAAV,CAAgBM,IAAhB,EAAsBH,IAAtB;AACArJ,IAAAA,QAAQ,CAACW,OAAT,CAAiBoC,WAAjB,CAA6ByG,IAAI,CAAC3I,MAAlC,EAA0CwI,IAAI,CAACxI,MAAL,GAAc,CAAxD;AACA,WAAOqG,UAAU,CAACO,IAAX,CAAgB+B,IAAhB,CAAP;AACH,GATD;;AAUA,SAAO3J,KAAP;AACH,CAtgB0B,EAA3B;;AAugBAL,OAAO,CAACK,KAAR,GAAgBA,KAAhB;AACA,IAAI4J,eAAe,GAAG,EAAtB;AACA,IAAIlG,MAAM,GAAGkG,eAAe,CAACC,cAA7B;AACA,IAAIC,cAAc,GAAG,EAArB;;AACA,SAAS/J,WAAT,CAAqB0I,MAArB,EAA6BlC,QAA7B,EAAuC;AACnC,MAAIwD,KAAK,GAAG,CAAZ;AACA,MAAIC,GAAG,GAAGvB,MAAM,CAACzH,MAAjB;;AACA,OAAK,IAAIiE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+E,GAApB,EAAyB,EAAE/E,CAA3B,EAA8B;AAC1B,YAAQwD,MAAM,CAACwB,UAAP,CAAkBhF,CAAlB,CAAR;AACI,WAAK,CAAL;AAAQ;AACJ;AACA9E,UAAAA,QAAQ,CAACW,OAAT,CAAiBoC,WAAjB,CAA6B,OAAOqD,QAApC,EAA8C,QAA9C;AACApG,UAAAA,QAAQ,CAACW,OAAT,CAAiBC,EAAjB,CAAoBwF,QAAQ,GAAG,CAA/B;AACA,cAAI2D,IAAI,GAAG/E,IAAI,CAACgF,IAAL,CAAUJ,KAAK,GAAGxD,QAAlB,IAA8BA,QAAzC;;AACA,cAAI2D,IAAI,KAAKH,KAAb,EAAoB;AAChBA,YAAAA,KAAK,IAAIxD,QAAT;AACH,WAFD,MAGK;AACDwD,YAAAA,KAAK,GAAGG,IAAR;AACH;;AACD;AACH;;AACD,WAAK,EAAL,CAdJ,CAca;;AACT,WAAK,EAAL,CAfJ,CAea;;AACT,WAAK,EAAL,CAhBJ,CAgBa;;AACT,WAAK,MAAL;AAAa;AACT;AACA;;AACJ,WAAK,EAAL,CApBJ,CAoBa;;AACT;AACI;AACAH,QAAAA,KAAK,IAAI,CAAT;AACA;AAxBR;AA0BH;;AACD,SAAOA,KAAP;AACH;;AACDpK,OAAO,CAACI,WAAR,GAAsBA,WAAtB;AACA,IAAIqK,eAAe,GAAG,MAAtB,C,CACA;;AACA,IAAIjG,oBAAoB,GAAG,oDAA3B;AACA;AACA;AACA;;AACA,SAASrE,UAAT,CAAoBsE,MAApB,EAA4B3C,OAA5B,EAAqC;AACjC,MAAI2C,MAAM,YAAYpE,KAAtB,EACI,OAAOoE,MAAP;AACJA,EAAAA,MAAM,IAAI,EAAV;AACA,MAAImC,QAAQ,GAAG9E,OAAO,IAAIA,OAAO,CAAC8E,QAAlC;AACA,MAAI8D,OAAO,GAAGjG,MAAM,CAACkG,OAAP,CAAe,IAAf,IAAuB,CAArC;AACA,MAAIC,SAAS,GAAG,CAAC9I,OAAD,IAAY4I,OAAZ,IAAuBjG,MAAM,CAACpD,MAAP,IAAiB8I,cAAxD;AACA3J,EAAAA,QAAQ,CAACW,OAAT,CAAiBC,EAAjB,CAAoBwF,QAAQ,IAAI8D,OAAhC,EAAyC,4DAA4DjG,MAArG;AACA,MAAImG,SAAS,IAAI7G,MAAM,CAACC,IAAP,CAAYiG,eAAZ,EAA6BxF,MAA7B,CAAjB,EACI,OAAOwF,eAAe,CAACxF,MAAD,CAAtB;AACJ,MAAIW,KAAK,GAAG,IAAI/E,KAAJ,CAAUoE,MAAM,CAACF,KAAP,CAAaC,oBAAb,EAAmCa,GAAnC,CAAuC,UAAUzB,IAAV,EAAgB;AACzE;AACA,QAAIkF,MAAM,GAAG2B,eAAe,CAACI,IAAhB,CAAqBjH,IAArB,EAA2B,CAA3B,CAAb;AACA,WAAO;AACHA,MAAAA,IAAI,EAAEA,IADH;AAEHiB,MAAAA,MAAM,EAAEzE,WAAW,CAAC0I,MAAD,EAASlC,QAAT,CAFhB;AAGH;AACAhB,MAAAA,MAAM,EAAE,KAJL;AAKHb,MAAAA,UAAU,EAAE+D,MAAM,CAACzH,MALhB;AAMH2D,MAAAA,QAAQ,EAAEpB,IAAI,CAACvC;AANZ,KAAP;AAQH,GAXqB,CAAV,EAWRV,SAAS,CAAC4H,SAAV,CAAoBzG,OAApB,EAA6Bf,cAXrB,CAAZ;AAYA,MAAI6J,SAAJ,EACIX,eAAe,CAACxF,MAAD,CAAf,GAA0BW,KAA1B;AACJ,SAAOA,KAAP;AACH;;AACDpF,OAAO,CAACG,UAAR,GAAqBA,UAArB;;AACA,SAASoG,gBAAT,CAA0B9B,MAA1B,EAAkC;AAC9B,SAAO,CAAC,KAAKqG,IAAL,CAAUrG,MAAV,CAAR;AACH;;AACD,SAAS0D,SAAT,CAAmBxD,IAAnB,EAAyBoG,QAAzB,EAAmCC,MAAnC,EAA2C;AACvC,MAAIjG,UAAU,GAAGJ,IAAI,CAACI,UAAtB;AACA,MAAIC,QAAQ,GAAGL,IAAI,CAACK,QAApB;AACA,MAAIH,MAAM,GAAGW,IAAI,CAACC,GAAL,CAASd,IAAI,CAACE,MAAd,EAAsB,CAAtB,CAAb;AACA,MAAIoG,UAAU,GAAGpG,MAAM,GAAGG,QAAT,GAAoBD,UAArC;;AACA,MAAI,OAAOiG,MAAP,KAAkB,WAAtB,EAAmC;AAC/BA,IAAAA,MAAM,GAAGC,UAAT;AACH;;AACDF,EAAAA,QAAQ,GAAGvF,IAAI,CAACC,GAAL,CAASsF,QAAT,EAAmB,CAAnB,CAAX;AACAC,EAAAA,MAAM,GAAGxF,IAAI,CAAC0B,GAAL,CAAS8D,MAAT,EAAiBC,UAAjB,CAAT;AACAD,EAAAA,MAAM,GAAGxF,IAAI,CAACC,GAAL,CAASuF,MAAT,EAAiBD,QAAjB,CAAT;;AACA,MAAIC,MAAM,GAAGnG,MAAb,EAAqB;AACjBA,IAAAA,MAAM,GAAGmG,MAAT;AACAhG,IAAAA,QAAQ,GAAGD,UAAX;AACH,GAHD,MAIK;AACDC,IAAAA,QAAQ,IAAIiG,UAAU,GAAGD,MAAzB;AACH;;AACDC,EAAAA,UAAU,GAAGD,MAAb;AACAC,EAAAA,UAAU,IAAIF,QAAd;;AACA,MAAIA,QAAQ,GAAGlG,MAAf,EAAuB;AACnBA,IAAAA,MAAM,IAAIkG,QAAV;AACH,GAFD,MAGK;AACDA,IAAAA,QAAQ,IAAIlG,MAAZ;AACAA,IAAAA,MAAM,GAAG,CAAT;AACAE,IAAAA,UAAU,IAAIgG,QAAd;AACH;;AACDvK,EAAAA,QAAQ,CAACW,OAAT,CAAiBC,EAAjB,CAAoByD,MAAM,IAAI,CAA9B;AACArE,EAAAA,QAAQ,CAACW,OAAT,CAAiBC,EAAjB,CAAoB2D,UAAU,IAAIC,QAAlC;AACAxE,EAAAA,QAAQ,CAACW,OAAT,CAAiBoC,WAAjB,CAA6B0H,UAA7B,EAAyCpG,MAAM,GAAGG,QAAT,GAAoBD,UAA7D;;AACA,MAAIJ,IAAI,CAACE,MAAL,KAAgBA,MAAhB,IACAF,IAAI,CAACI,UAAL,KAAoBA,UADpB,IAEAJ,IAAI,CAACK,QAAL,KAAkBA,QAFtB,EAEgC;AAC5B,WAAOL,IAAP;AACH;;AACD,SAAO;AACHf,IAAAA,IAAI,EAAEe,IAAI,CAACf,IADR;AAEHiB,IAAAA,MAAM,EAAEA,MAFL;AAGH;AACAe,IAAAA,MAAM,EAAE,KAJL;AAKHb,IAAAA,UAAU,EAAEA,UALT;AAMHC,IAAAA,QAAQ,EAAEA;AANP,GAAP;AAQH;;AACD,SAAS9E,MAAT,CAAgBgJ,QAAhB,EAA0B;AACtB,SAAOxB,UAAU,CAACO,IAAX,CAAgBiB,QAAhB,CAAP;AACH;;AACDlJ,OAAO,CAACE,MAAR,GAAiBA,MAAjB,C,CACA;AACA;;AACA,IAAIwH,UAAU,GAAGvH,UAAU,CAAC,EAAD,CAA3B","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.concat = exports.fromString = exports.countSpaces = exports.Lines = void 0;\nvar tslib_1 = require(\"tslib\");\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\nvar source_map_1 = tslib_1.__importDefault(require(\"source-map\"));\nvar options_1 = require(\"./options\");\nvar util_1 = require(\"./util\");\nvar mapping_1 = tslib_1.__importDefault(require(\"./mapping\"));\nvar Lines = /** @class */ (function () {\n    function Lines(infos, sourceFileName) {\n        if (sourceFileName === void 0) { sourceFileName = null; }\n        this.infos = infos;\n        this.mappings = [];\n        this.cachedSourceMap = null;\n        this.cachedTabWidth = void 0;\n        assert_1.default.ok(infos.length > 0);\n        this.length = infos.length;\n        this.name = sourceFileName || null;\n        if (this.name) {\n            this.mappings.push(new mapping_1.default(this, {\n                start: this.firstPos(),\n                end: this.lastPos(),\n            }));\n        }\n    }\n    Lines.prototype.toString = function (options) {\n        return this.sliceString(this.firstPos(), this.lastPos(), options);\n    };\n    Lines.prototype.getSourceMap = function (sourceMapName, sourceRoot) {\n        if (!sourceMapName) {\n            // Although we could make up a name or generate an anonymous\n            // source map, instead we assume that any consumer who does not\n            // provide a name does not actually want a source map.\n            return null;\n        }\n        var targetLines = this;\n        function updateJSON(json) {\n            json = json || {};\n            json.file = sourceMapName;\n            if (sourceRoot) {\n                json.sourceRoot = sourceRoot;\n            }\n            return json;\n        }\n        if (targetLines.cachedSourceMap) {\n            // Since Lines objects are immutable, we can reuse any source map\n            // that was previously generated. Nevertheless, we return a new\n            // JSON object here to protect the cached source map from outside\n            // modification.\n            return updateJSON(targetLines.cachedSourceMap.toJSON());\n        }\n        var smg = new source_map_1.default.SourceMapGenerator(updateJSON());\n        var sourcesToContents = {};\n        targetLines.mappings.forEach(function (mapping) {\n            var sourceCursor = mapping.sourceLines.skipSpaces(mapping.sourceLoc.start) ||\n                mapping.sourceLines.lastPos();\n            var targetCursor = targetLines.skipSpaces(mapping.targetLoc.start) ||\n                targetLines.lastPos();\n            while (util_1.comparePos(sourceCursor, mapping.sourceLoc.end) < 0 &&\n                util_1.comparePos(targetCursor, mapping.targetLoc.end) < 0) {\n                var sourceChar = mapping.sourceLines.charAt(sourceCursor);\n                var targetChar = targetLines.charAt(targetCursor);\n                assert_1.default.strictEqual(sourceChar, targetChar);\n                var sourceName = mapping.sourceLines.name;\n                // Add mappings one character at a time for maximum resolution.\n                smg.addMapping({\n                    source: sourceName,\n                    original: { line: sourceCursor.line, column: sourceCursor.column },\n                    generated: { line: targetCursor.line, column: targetCursor.column },\n                });\n                if (!hasOwn.call(sourcesToContents, sourceName)) {\n                    var sourceContent = mapping.sourceLines.toString();\n                    smg.setSourceContent(sourceName, sourceContent);\n                    sourcesToContents[sourceName] = sourceContent;\n                }\n                targetLines.nextPos(targetCursor, true);\n                mapping.sourceLines.nextPos(sourceCursor, true);\n            }\n        });\n        targetLines.cachedSourceMap = smg;\n        return smg.toJSON();\n    };\n    Lines.prototype.bootstrapCharAt = function (pos) {\n        assert_1.default.strictEqual(typeof pos, \"object\");\n        assert_1.default.strictEqual(typeof pos.line, \"number\");\n        assert_1.default.strictEqual(typeof pos.column, \"number\");\n        var line = pos.line, column = pos.column, strings = this.toString().split(lineTerminatorSeqExp), string = strings[line - 1];\n        if (typeof string === \"undefined\")\n            return \"\";\n        if (column === string.length && line < strings.length)\n            return \"\\n\";\n        if (column >= string.length)\n            return \"\";\n        return string.charAt(column);\n    };\n    Lines.prototype.charAt = function (pos) {\n        assert_1.default.strictEqual(typeof pos, \"object\");\n        assert_1.default.strictEqual(typeof pos.line, \"number\");\n        assert_1.default.strictEqual(typeof pos.column, \"number\");\n        var line = pos.line, column = pos.column, secret = this, infos = secret.infos, info = infos[line - 1], c = column;\n        if (typeof info === \"undefined\" || c < 0)\n            return \"\";\n        var indent = this.getIndentAt(line);\n        if (c < indent)\n            return \" \";\n        c += info.sliceStart - indent;\n        if (c === info.sliceEnd && line < this.length)\n            return \"\\n\";\n        if (c >= info.sliceEnd)\n            return \"\";\n        return info.line.charAt(c);\n    };\n    Lines.prototype.stripMargin = function (width, skipFirstLine) {\n        if (width === 0)\n            return this;\n        assert_1.default.ok(width > 0, \"negative margin: \" + width);\n        if (skipFirstLine && this.length === 1)\n            return this;\n        var lines = new Lines(this.infos.map(function (info, i) {\n            if (info.line && (i > 0 || !skipFirstLine)) {\n                info = tslib_1.__assign(tslib_1.__assign({}, info), { indent: Math.max(0, info.indent - width) });\n            }\n            return info;\n        }));\n        if (this.mappings.length > 0) {\n            var newMappings_1 = lines.mappings;\n            assert_1.default.strictEqual(newMappings_1.length, 0);\n            this.mappings.forEach(function (mapping) {\n                newMappings_1.push(mapping.indent(width, skipFirstLine, true));\n            });\n        }\n        return lines;\n    };\n    Lines.prototype.indent = function (by) {\n        if (by === 0) {\n            return this;\n        }\n        var lines = new Lines(this.infos.map(function (info) {\n            if (info.line && !info.locked) {\n                info = tslib_1.__assign(tslib_1.__assign({}, info), { indent: info.indent + by });\n            }\n            return info;\n        }));\n        if (this.mappings.length > 0) {\n            var newMappings_2 = lines.mappings;\n            assert_1.default.strictEqual(newMappings_2.length, 0);\n            this.mappings.forEach(function (mapping) {\n                newMappings_2.push(mapping.indent(by));\n            });\n        }\n        return lines;\n    };\n    Lines.prototype.indentTail = function (by) {\n        if (by === 0) {\n            return this;\n        }\n        if (this.length < 2) {\n            return this;\n        }\n        var lines = new Lines(this.infos.map(function (info, i) {\n            if (i > 0 && info.line && !info.locked) {\n                info = tslib_1.__assign(tslib_1.__assign({}, info), { indent: info.indent + by });\n            }\n            return info;\n        }));\n        if (this.mappings.length > 0) {\n            var newMappings_3 = lines.mappings;\n            assert_1.default.strictEqual(newMappings_3.length, 0);\n            this.mappings.forEach(function (mapping) {\n                newMappings_3.push(mapping.indent(by, true));\n            });\n        }\n        return lines;\n    };\n    Lines.prototype.lockIndentTail = function () {\n        if (this.length < 2) {\n            return this;\n        }\n        return new Lines(this.infos.map(function (info, i) { return (tslib_1.__assign(tslib_1.__assign({}, info), { locked: i > 0 })); }));\n    };\n    Lines.prototype.getIndentAt = function (line) {\n        assert_1.default.ok(line >= 1, \"no line \" + line + \" (line numbers start from 1)\");\n        return Math.max(this.infos[line - 1].indent, 0);\n    };\n    Lines.prototype.guessTabWidth = function () {\n        if (typeof this.cachedTabWidth === \"number\") {\n            return this.cachedTabWidth;\n        }\n        var counts = []; // Sparse array.\n        var lastIndent = 0;\n        for (var line = 1, last = this.length; line <= last; ++line) {\n            var info = this.infos[line - 1];\n            var sliced = info.line.slice(info.sliceStart, info.sliceEnd);\n            // Whitespace-only lines don't tell us much about the likely tab\n            // width of this code.\n            if (isOnlyWhitespace(sliced)) {\n                continue;\n            }\n            var diff = Math.abs(info.indent - lastIndent);\n            counts[diff] = ~~counts[diff] + 1;\n            lastIndent = info.indent;\n        }\n        var maxCount = -1;\n        var result = 2;\n        for (var tabWidth = 1; tabWidth < counts.length; tabWidth += 1) {\n            if (hasOwn.call(counts, tabWidth) && counts[tabWidth] > maxCount) {\n                maxCount = counts[tabWidth];\n                result = tabWidth;\n            }\n        }\n        return (this.cachedTabWidth = result);\n    };\n    // Determine if the list of lines has a first line that starts with a //\n    // or /* comment. If this is the case, the code may need to be wrapped in\n    // parens to avoid ASI issues.\n    Lines.prototype.startsWithComment = function () {\n        if (this.infos.length === 0) {\n            return false;\n        }\n        var firstLineInfo = this.infos[0], sliceStart = firstLineInfo.sliceStart, sliceEnd = firstLineInfo.sliceEnd, firstLine = firstLineInfo.line.slice(sliceStart, sliceEnd).trim();\n        return (firstLine.length === 0 ||\n            firstLine.slice(0, 2) === \"//\" ||\n            firstLine.slice(0, 2) === \"/*\");\n    };\n    Lines.prototype.isOnlyWhitespace = function () {\n        return isOnlyWhitespace(this.toString());\n    };\n    Lines.prototype.isPrecededOnlyByWhitespace = function (pos) {\n        var info = this.infos[pos.line - 1];\n        var indent = Math.max(info.indent, 0);\n        var diff = pos.column - indent;\n        if (diff <= 0) {\n            // If pos.column does not exceed the indentation amount, then\n            // there must be only whitespace before it.\n            return true;\n        }\n        var start = info.sliceStart;\n        var end = Math.min(start + diff, info.sliceEnd);\n        var prefix = info.line.slice(start, end);\n        return isOnlyWhitespace(prefix);\n    };\n    Lines.prototype.getLineLength = function (line) {\n        var info = this.infos[line - 1];\n        return this.getIndentAt(line) + info.sliceEnd - info.sliceStart;\n    };\n    Lines.prototype.nextPos = function (pos, skipSpaces) {\n        if (skipSpaces === void 0) { skipSpaces = false; }\n        var l = Math.max(pos.line, 0), c = Math.max(pos.column, 0);\n        if (c < this.getLineLength(l)) {\n            pos.column += 1;\n            return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;\n        }\n        if (l < this.length) {\n            pos.line += 1;\n            pos.column = 0;\n            return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;\n        }\n        return false;\n    };\n    Lines.prototype.prevPos = function (pos, skipSpaces) {\n        if (skipSpaces === void 0) { skipSpaces = false; }\n        var l = pos.line, c = pos.column;\n        if (c < 1) {\n            l -= 1;\n            if (l < 1)\n                return false;\n            c = this.getLineLength(l);\n        }\n        else {\n            c = Math.min(c - 1, this.getLineLength(l));\n        }\n        pos.line = l;\n        pos.column = c;\n        return skipSpaces ? !!this.skipSpaces(pos, true, true) : true;\n    };\n    Lines.prototype.firstPos = function () {\n        // Trivial, but provided for completeness.\n        return { line: 1, column: 0 };\n    };\n    Lines.prototype.lastPos = function () {\n        return {\n            line: this.length,\n            column: this.getLineLength(this.length),\n        };\n    };\n    Lines.prototype.skipSpaces = function (pos, backward, modifyInPlace) {\n        if (backward === void 0) { backward = false; }\n        if (modifyInPlace === void 0) { modifyInPlace = false; }\n        if (pos) {\n            pos = modifyInPlace\n                ? pos\n                : {\n                    line: pos.line,\n                    column: pos.column,\n                };\n        }\n        else if (backward) {\n            pos = this.lastPos();\n        }\n        else {\n            pos = this.firstPos();\n        }\n        if (backward) {\n            while (this.prevPos(pos)) {\n                if (!isOnlyWhitespace(this.charAt(pos)) && this.nextPos(pos)) {\n                    return pos;\n                }\n            }\n            return null;\n        }\n        else {\n            while (isOnlyWhitespace(this.charAt(pos))) {\n                if (!this.nextPos(pos)) {\n                    return null;\n                }\n            }\n            return pos;\n        }\n    };\n    Lines.prototype.trimLeft = function () {\n        var pos = this.skipSpaces(this.firstPos(), false, true);\n        return pos ? this.slice(pos) : emptyLines;\n    };\n    Lines.prototype.trimRight = function () {\n        var pos = this.skipSpaces(this.lastPos(), true, true);\n        return pos ? this.slice(this.firstPos(), pos) : emptyLines;\n    };\n    Lines.prototype.trim = function () {\n        var start = this.skipSpaces(this.firstPos(), false, true);\n        if (start === null) {\n            return emptyLines;\n        }\n        var end = this.skipSpaces(this.lastPos(), true, true);\n        if (end === null) {\n            return emptyLines;\n        }\n        return this.slice(start, end);\n    };\n    Lines.prototype.eachPos = function (callback, startPos, skipSpaces) {\n        if (startPos === void 0) { startPos = this.firstPos(); }\n        if (skipSpaces === void 0) { skipSpaces = false; }\n        var pos = this.firstPos();\n        if (startPos) {\n            (pos.line = startPos.line), (pos.column = startPos.column);\n        }\n        if (skipSpaces && !this.skipSpaces(pos, false, true)) {\n            return; // Encountered nothing but spaces.\n        }\n        do\n            callback.call(this, pos);\n        while (this.nextPos(pos, skipSpaces));\n    };\n    Lines.prototype.bootstrapSlice = function (start, end) {\n        var strings = this.toString()\n            .split(lineTerminatorSeqExp)\n            .slice(start.line - 1, end.line);\n        if (strings.length > 0) {\n            strings.push(strings.pop().slice(0, end.column));\n            strings[0] = strings[0].slice(start.column);\n        }\n        return fromString(strings.join(\"\\n\"));\n    };\n    Lines.prototype.slice = function (start, end) {\n        if (!end) {\n            if (!start) {\n                // The client seems to want a copy of this Lines object, but\n                // Lines objects are immutable, so it's perfectly adequate to\n                // return the same object.\n                return this;\n            }\n            // Slice to the end if no end position was provided.\n            end = this.lastPos();\n        }\n        if (!start) {\n            throw new Error(\"cannot slice with end but not start\");\n        }\n        var sliced = this.infos.slice(start.line - 1, end.line);\n        if (start.line === end.line) {\n            sliced[0] = sliceInfo(sliced[0], start.column, end.column);\n        }\n        else {\n            assert_1.default.ok(start.line < end.line);\n            sliced[0] = sliceInfo(sliced[0], start.column);\n            sliced.push(sliceInfo(sliced.pop(), 0, end.column));\n        }\n        var lines = new Lines(sliced);\n        if (this.mappings.length > 0) {\n            var newMappings_4 = lines.mappings;\n            assert_1.default.strictEqual(newMappings_4.length, 0);\n            this.mappings.forEach(function (mapping) {\n                var sliced = mapping.slice(this, start, end);\n                if (sliced) {\n                    newMappings_4.push(sliced);\n                }\n            }, this);\n        }\n        return lines;\n    };\n    Lines.prototype.bootstrapSliceString = function (start, end, options) {\n        return this.slice(start, end).toString(options);\n    };\n    Lines.prototype.sliceString = function (start, end, options) {\n        if (start === void 0) { start = this.firstPos(); }\n        if (end === void 0) { end = this.lastPos(); }\n        var _a = options_1.normalize(options), tabWidth = _a.tabWidth, useTabs = _a.useTabs, reuseWhitespace = _a.reuseWhitespace, lineTerminator = _a.lineTerminator;\n        var parts = [];\n        for (var line = start.line; line <= end.line; ++line) {\n            var info = this.infos[line - 1];\n            if (line === start.line) {\n                if (line === end.line) {\n                    info = sliceInfo(info, start.column, end.column);\n                }\n                else {\n                    info = sliceInfo(info, start.column);\n                }\n            }\n            else if (line === end.line) {\n                info = sliceInfo(info, 0, end.column);\n            }\n            var indent = Math.max(info.indent, 0);\n            var before_1 = info.line.slice(0, info.sliceStart);\n            if (reuseWhitespace &&\n                isOnlyWhitespace(before_1) &&\n                countSpaces(before_1, tabWidth) === indent) {\n                // Reuse original spaces if the indentation is correct.\n                parts.push(info.line.slice(0, info.sliceEnd));\n                continue;\n            }\n            var tabs = 0;\n            var spaces = indent;\n            if (useTabs) {\n                tabs = Math.floor(indent / tabWidth);\n                spaces -= tabs * tabWidth;\n            }\n            var result = \"\";\n            if (tabs > 0) {\n                result += new Array(tabs + 1).join(\"\\t\");\n            }\n            if (spaces > 0) {\n                result += new Array(spaces + 1).join(\" \");\n            }\n            result += info.line.slice(info.sliceStart, info.sliceEnd);\n            parts.push(result);\n        }\n        return parts.join(lineTerminator);\n    };\n    Lines.prototype.isEmpty = function () {\n        return this.length < 2 && this.getLineLength(1) < 1;\n    };\n    Lines.prototype.join = function (elements) {\n        var separator = this;\n        var infos = [];\n        var mappings = [];\n        var prevInfo;\n        function appendLines(linesOrNull) {\n            if (linesOrNull === null) {\n                return;\n            }\n            if (prevInfo) {\n                var info = linesOrNull.infos[0];\n                var indent = new Array(info.indent + 1).join(\" \");\n                var prevLine_1 = infos.length;\n                var prevColumn_1 = Math.max(prevInfo.indent, 0) +\n                    prevInfo.sliceEnd -\n                    prevInfo.sliceStart;\n                prevInfo.line =\n                    prevInfo.line.slice(0, prevInfo.sliceEnd) +\n                        indent +\n                        info.line.slice(info.sliceStart, info.sliceEnd);\n                // If any part of a line is indentation-locked, the whole line\n                // will be indentation-locked.\n                prevInfo.locked = prevInfo.locked || info.locked;\n                prevInfo.sliceEnd = prevInfo.line.length;\n                if (linesOrNull.mappings.length > 0) {\n                    linesOrNull.mappings.forEach(function (mapping) {\n                        mappings.push(mapping.add(prevLine_1, prevColumn_1));\n                    });\n                }\n            }\n            else if (linesOrNull.mappings.length > 0) {\n                mappings.push.apply(mappings, linesOrNull.mappings);\n            }\n            linesOrNull.infos.forEach(function (info, i) {\n                if (!prevInfo || i > 0) {\n                    prevInfo = tslib_1.__assign({}, info);\n                    infos.push(prevInfo);\n                }\n            });\n        }\n        function appendWithSeparator(linesOrNull, i) {\n            if (i > 0)\n                appendLines(separator);\n            appendLines(linesOrNull);\n        }\n        elements\n            .map(function (elem) {\n            var lines = fromString(elem);\n            if (lines.isEmpty())\n                return null;\n            return lines;\n        })\n            .forEach(function (linesOrNull, i) {\n            if (separator.isEmpty()) {\n                appendLines(linesOrNull);\n            }\n            else {\n                appendWithSeparator(linesOrNull, i);\n            }\n        });\n        if (infos.length < 1)\n            return emptyLines;\n        var lines = new Lines(infos);\n        lines.mappings = mappings;\n        return lines;\n    };\n    Lines.prototype.concat = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var list = [this];\n        list.push.apply(list, args);\n        assert_1.default.strictEqual(list.length, args.length + 1);\n        return emptyLines.join(list);\n    };\n    return Lines;\n}());\nexports.Lines = Lines;\nvar fromStringCache = {};\nvar hasOwn = fromStringCache.hasOwnProperty;\nvar maxCacheKeyLen = 10;\nfunction countSpaces(spaces, tabWidth) {\n    var count = 0;\n    var len = spaces.length;\n    for (var i = 0; i < len; ++i) {\n        switch (spaces.charCodeAt(i)) {\n            case 9: {\n                // '\\t'\n                assert_1.default.strictEqual(typeof tabWidth, \"number\");\n                assert_1.default.ok(tabWidth > 0);\n                var next = Math.ceil(count / tabWidth) * tabWidth;\n                if (next === count) {\n                    count += tabWidth;\n                }\n                else {\n                    count = next;\n                }\n                break;\n            }\n            case 11: // '\\v'\n            case 12: // '\\f'\n            case 13: // '\\r'\n            case 0xfeff: // zero-width non-breaking space\n                // These characters contribute nothing to indentation.\n                break;\n            case 32: // ' '\n            default:\n                // Treat all other whitespace like ' '.\n                count += 1;\n                break;\n        }\n    }\n    return count;\n}\nexports.countSpaces = countSpaces;\nvar leadingSpaceExp = /^\\s*/;\n// As specified here: http://www.ecma-international.org/ecma-262/6.0/#sec-line-terminators\nvar lineTerminatorSeqExp = /\\u000D\\u000A|\\u000D(?!\\u000A)|\\u000A|\\u2028|\\u2029/;\n/**\n * @param {Object} options - Options object that configures printing.\n */\nfunction fromString(string, options) {\n    if (string instanceof Lines)\n        return string;\n    string += \"\";\n    var tabWidth = options && options.tabWidth;\n    var tabless = string.indexOf(\"\\t\") < 0;\n    var cacheable = !options && tabless && string.length <= maxCacheKeyLen;\n    assert_1.default.ok(tabWidth || tabless, \"No tab width specified but encountered tabs in string\\n\" + string);\n    if (cacheable && hasOwn.call(fromStringCache, string))\n        return fromStringCache[string];\n    var lines = new Lines(string.split(lineTerminatorSeqExp).map(function (line) {\n        // TODO: handle null exec result\n        var spaces = leadingSpaceExp.exec(line)[0];\n        return {\n            line: line,\n            indent: countSpaces(spaces, tabWidth),\n            // Boolean indicating whether this line can be reindented.\n            locked: false,\n            sliceStart: spaces.length,\n            sliceEnd: line.length,\n        };\n    }), options_1.normalize(options).sourceFileName);\n    if (cacheable)\n        fromStringCache[string] = lines;\n    return lines;\n}\nexports.fromString = fromString;\nfunction isOnlyWhitespace(string) {\n    return !/\\S/.test(string);\n}\nfunction sliceInfo(info, startCol, endCol) {\n    var sliceStart = info.sliceStart;\n    var sliceEnd = info.sliceEnd;\n    var indent = Math.max(info.indent, 0);\n    var lineLength = indent + sliceEnd - sliceStart;\n    if (typeof endCol === \"undefined\") {\n        endCol = lineLength;\n    }\n    startCol = Math.max(startCol, 0);\n    endCol = Math.min(endCol, lineLength);\n    endCol = Math.max(endCol, startCol);\n    if (endCol < indent) {\n        indent = endCol;\n        sliceEnd = sliceStart;\n    }\n    else {\n        sliceEnd -= lineLength - endCol;\n    }\n    lineLength = endCol;\n    lineLength -= startCol;\n    if (startCol < indent) {\n        indent -= startCol;\n    }\n    else {\n        startCol -= indent;\n        indent = 0;\n        sliceStart += startCol;\n    }\n    assert_1.default.ok(indent >= 0);\n    assert_1.default.ok(sliceStart <= sliceEnd);\n    assert_1.default.strictEqual(lineLength, indent + sliceEnd - sliceStart);\n    if (info.indent === indent &&\n        info.sliceStart === sliceStart &&\n        info.sliceEnd === sliceEnd) {\n        return info;\n    }\n    return {\n        line: info.line,\n        indent: indent,\n        // A destructive slice always unlocks indentation.\n        locked: false,\n        sliceStart: sliceStart,\n        sliceEnd: sliceEnd,\n    };\n}\nfunction concat(elements) {\n    return emptyLines.join(elements);\n}\nexports.concat = concat;\n// The emptyLines object needs to be created all the way down here so that\n// Lines.prototype will be fully populated.\nvar emptyLines = fromString(\"\");\n"]},"metadata":{},"sourceType":"script"}