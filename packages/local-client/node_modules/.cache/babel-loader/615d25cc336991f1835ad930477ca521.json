{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Def = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar Op = Object.prototype;\nvar objToStr = Op.toString;\nvar hasOwn = Op.hasOwnProperty;\n\nvar BaseType =\n/** @class */\nfunction () {\n  function BaseType() {}\n\n  BaseType.prototype.assert = function (value, deep) {\n    if (!this.check(value, deep)) {\n      var str = shallowStringify(value);\n      throw new Error(str + \" does not match type \" + this);\n    }\n\n    return true;\n  };\n\n  BaseType.prototype.arrayOf = function () {\n    var elemType = this;\n    return new ArrayType(elemType);\n  };\n\n  return BaseType;\n}();\n\nvar ArrayType =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ArrayType, _super);\n\n  function ArrayType(elemType) {\n    var _this = _super.call(this) || this;\n\n    _this.elemType = elemType;\n    _this.kind = \"ArrayType\";\n    return _this;\n  }\n\n  ArrayType.prototype.toString = function () {\n    return \"[\" + this.elemType + \"]\";\n  };\n\n  ArrayType.prototype.check = function (value, deep) {\n    var _this = this;\n\n    return Array.isArray(value) && value.every(function (elem) {\n      return _this.elemType.check(elem, deep);\n    });\n  };\n\n  return ArrayType;\n}(BaseType);\n\nvar IdentityType =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(IdentityType, _super);\n\n  function IdentityType(value) {\n    var _this = _super.call(this) || this;\n\n    _this.value = value;\n    _this.kind = \"IdentityType\";\n    return _this;\n  }\n\n  IdentityType.prototype.toString = function () {\n    return String(this.value);\n  };\n\n  IdentityType.prototype.check = function (value, deep) {\n    var result = value === this.value;\n\n    if (!result && typeof deep === \"function\") {\n      deep(this, value);\n    }\n\n    return result;\n  };\n\n  return IdentityType;\n}(BaseType);\n\nvar ObjectType =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ObjectType, _super);\n\n  function ObjectType(fields) {\n    var _this = _super.call(this) || this;\n\n    _this.fields = fields;\n    _this.kind = \"ObjectType\";\n    return _this;\n  }\n\n  ObjectType.prototype.toString = function () {\n    return \"{ \" + this.fields.join(\", \") + \" }\";\n  };\n\n  ObjectType.prototype.check = function (value, deep) {\n    return objToStr.call(value) === objToStr.call({}) && this.fields.every(function (field) {\n      return field.type.check(value[field.name], deep);\n    });\n  };\n\n  return ObjectType;\n}(BaseType);\n\nvar OrType =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(OrType, _super);\n\n  function OrType(types) {\n    var _this = _super.call(this) || this;\n\n    _this.types = types;\n    _this.kind = \"OrType\";\n    return _this;\n  }\n\n  OrType.prototype.toString = function () {\n    return this.types.join(\" | \");\n  };\n\n  OrType.prototype.check = function (value, deep) {\n    return this.types.some(function (type) {\n      return type.check(value, deep);\n    });\n  };\n\n  return OrType;\n}(BaseType);\n\nvar PredicateType =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(PredicateType, _super);\n\n  function PredicateType(name, predicate) {\n    var _this = _super.call(this) || this;\n\n    _this.name = name;\n    _this.predicate = predicate;\n    _this.kind = \"PredicateType\";\n    return _this;\n  }\n\n  PredicateType.prototype.toString = function () {\n    return this.name;\n  };\n\n  PredicateType.prototype.check = function (value, deep) {\n    var result = this.predicate(value, deep);\n\n    if (!result && typeof deep === \"function\") {\n      deep(this, value);\n    }\n\n    return result;\n  };\n\n  return PredicateType;\n}(BaseType);\n\nvar Def =\n/** @class */\nfunction () {\n  function Def(type, typeName) {\n    this.type = type;\n    this.typeName = typeName;\n    this.baseNames = [];\n    this.ownFields = Object.create(null); // Includes own typeName. Populated during finalization.\n\n    this.allSupertypes = Object.create(null); // Linear inheritance hierarchy. Populated during finalization.\n\n    this.supertypeList = []; // Includes inherited fields.\n\n    this.allFields = Object.create(null); // Non-hidden keys of allFields.\n\n    this.fieldNames = []; // This property will be overridden as true by individual Def instances\n    // when they are finalized.\n\n    this.finalized = false; // False by default until .build(...) is called on an instance.\n\n    this.buildable = false;\n    this.buildParams = [];\n  }\n\n  Def.prototype.isSupertypeOf = function (that) {\n    if (that instanceof Def) {\n      if (this.finalized !== true || that.finalized !== true) {\n        throw new Error(\"\");\n      }\n\n      return hasOwn.call(that.allSupertypes, this.typeName);\n    } else {\n      throw new Error(that + \" is not a Def\");\n    }\n  };\n\n  Def.prototype.checkAllFields = function (value, deep) {\n    var allFields = this.allFields;\n\n    if (this.finalized !== true) {\n      throw new Error(\"\" + this.typeName);\n    }\n\n    function checkFieldByName(name) {\n      var field = allFields[name];\n      var type = field.type;\n      var child = field.getValue(value);\n      return type.check(child, deep);\n    }\n\n    return value !== null && typeof value === \"object\" && Object.keys(allFields).every(checkFieldByName);\n  };\n\n  Def.prototype.bases = function () {\n    var supertypeNames = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      supertypeNames[_i] = arguments[_i];\n    }\n\n    var bases = this.baseNames;\n\n    if (this.finalized) {\n      if (supertypeNames.length !== bases.length) {\n        throw new Error(\"\");\n      }\n\n      for (var i = 0; i < supertypeNames.length; i++) {\n        if (supertypeNames[i] !== bases[i]) {\n          throw new Error(\"\");\n        }\n      }\n\n      return this;\n    }\n\n    supertypeNames.forEach(function (baseName) {\n      // This indexOf lookup may be O(n), but the typical number of base\n      // names is very small, and indexOf is a native Array method.\n      if (bases.indexOf(baseName) < 0) {\n        bases.push(baseName);\n      }\n    });\n    return this; // For chaining.\n  };\n\n  return Def;\n}();\n\nexports.Def = Def;\n\nvar Field =\n/** @class */\nfunction () {\n  function Field(name, type, defaultFn, hidden) {\n    this.name = name;\n    this.type = type;\n    this.defaultFn = defaultFn;\n    this.hidden = !!hidden;\n  }\n\n  Field.prototype.toString = function () {\n    return JSON.stringify(this.name) + \": \" + this.type;\n  };\n\n  Field.prototype.getValue = function (obj) {\n    var value = obj[this.name];\n\n    if (typeof value !== \"undefined\") {\n      return value;\n    }\n\n    if (typeof this.defaultFn === \"function\") {\n      value = this.defaultFn.call(obj);\n    }\n\n    return value;\n  };\n\n  return Field;\n}();\n\nfunction shallowStringify(value) {\n  if (Array.isArray(value)) {\n    return \"[\" + value.map(shallowStringify).join(\", \") + \"]\";\n  }\n\n  if (value && typeof value === \"object\") {\n    return \"{ \" + Object.keys(value).map(function (key) {\n      return key + \": \" + value[key];\n    }).join(\", \") + \" }\";\n  }\n\n  return JSON.stringify(value);\n}\n\nfunction typesPlugin(_fork) {\n  var Type = {\n    or: function () {\n      var types = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        types[_i] = arguments[_i];\n      }\n\n      return new OrType(types.map(function (type) {\n        return Type.from(type);\n      }));\n    },\n    from: function (value, name) {\n      if (value instanceof ArrayType || value instanceof IdentityType || value instanceof ObjectType || value instanceof OrType || value instanceof PredicateType) {\n        return value;\n      } // The Def type is used as a helper for constructing compound\n      // interface types for AST nodes.\n\n\n      if (value instanceof Def) {\n        return value.type;\n      } // Support [ElemType] syntax.\n\n\n      if (isArray.check(value)) {\n        if (value.length !== 1) {\n          throw new Error(\"only one element type is permitted for typed arrays\");\n        }\n\n        return new ArrayType(Type.from(value[0]));\n      } // Support { someField: FieldType, ... } syntax.\n\n\n      if (isObject.check(value)) {\n        return new ObjectType(Object.keys(value).map(function (name) {\n          return new Field(name, Type.from(value[name], name));\n        }));\n      }\n\n      if (typeof value === \"function\") {\n        var bicfIndex = builtInCtorFns.indexOf(value);\n\n        if (bicfIndex >= 0) {\n          return builtInCtorTypes[bicfIndex];\n        }\n\n        if (typeof name !== \"string\") {\n          throw new Error(\"missing name\");\n        }\n\n        return new PredicateType(name, value);\n      } // As a last resort, toType returns a type that matches any value that\n      // is === from. This is primarily useful for literal values like\n      // toType(null), but it has the additional advantage of allowing\n      // toType to be a total function.\n\n\n      return new IdentityType(value);\n    },\n    // Define a type whose name is registered in a namespace (the defCache) so\n    // that future definitions will return the same type given the same name.\n    // In particular, this system allows for circular and forward definitions.\n    // The Def object d returned from Type.def may be used to configure the\n    // type d.type by calling methods such as d.bases, d.build, and d.field.\n    def: function (typeName) {\n      return hasOwn.call(defCache, typeName) ? defCache[typeName] : defCache[typeName] = new DefImpl(typeName);\n    },\n    hasDef: function (typeName) {\n      return hasOwn.call(defCache, typeName);\n    }\n  };\n  var builtInCtorFns = [];\n  var builtInCtorTypes = [];\n\n  function defBuiltInType(name, example) {\n    var objStr = objToStr.call(example);\n    var type = new PredicateType(name, function (value) {\n      return objToStr.call(value) === objStr;\n    });\n\n    if (example && typeof example.constructor === \"function\") {\n      builtInCtorFns.push(example.constructor);\n      builtInCtorTypes.push(type);\n    }\n\n    return type;\n  } // These types check the underlying [[Class]] attribute of the given\n  // value, rather than using the problematic typeof operator. Note however\n  // that no subtyping is considered; so, for instance, isObject.check\n  // returns false for [], /./, new Date, and null.\n\n\n  var isString = defBuiltInType(\"string\", \"truthy\");\n  var isFunction = defBuiltInType(\"function\", function () {});\n  var isArray = defBuiltInType(\"array\", []);\n  var isObject = defBuiltInType(\"object\", {});\n  var isRegExp = defBuiltInType(\"RegExp\", /./);\n  var isDate = defBuiltInType(\"Date\", new Date());\n  var isNumber = defBuiltInType(\"number\", 3);\n  var isBoolean = defBuiltInType(\"boolean\", true);\n  var isNull = defBuiltInType(\"null\", null);\n  var isUndefined = defBuiltInType(\"undefined\", undefined);\n  var builtInTypes = {\n    string: isString,\n    function: isFunction,\n    array: isArray,\n    object: isObject,\n    RegExp: isRegExp,\n    Date: isDate,\n    number: isNumber,\n    boolean: isBoolean,\n    null: isNull,\n    undefined: isUndefined\n  }; // In order to return the same Def instance every time Type.def is called\n  // with a particular name, those instances need to be stored in a cache.\n\n  var defCache = Object.create(null);\n\n  function defFromValue(value) {\n    if (value && typeof value === \"object\") {\n      var type = value.type;\n\n      if (typeof type === \"string\" && hasOwn.call(defCache, type)) {\n        var d = defCache[type];\n\n        if (d.finalized) {\n          return d;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  var DefImpl =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(DefImpl, _super);\n\n    function DefImpl(typeName) {\n      var _this = _super.call(this, new PredicateType(typeName, function (value, deep) {\n        return _this.check(value, deep);\n      }), typeName) || this;\n\n      return _this;\n    }\n\n    DefImpl.prototype.check = function (value, deep) {\n      if (this.finalized !== true) {\n        throw new Error(\"prematurely checking unfinalized type \" + this.typeName);\n      } // A Def type can only match an object value.\n\n\n      if (value === null || typeof value !== \"object\") {\n        return false;\n      }\n\n      var vDef = defFromValue(value);\n\n      if (!vDef) {\n        // If we couldn't infer the Def associated with the given value,\n        // and we expected it to be a SourceLocation or a Position, it was\n        // probably just missing a \"type\" field (because Esprima does not\n        // assign a type property to such nodes). Be optimistic and let\n        // this.checkAllFields make the final decision.\n        if (this.typeName === \"SourceLocation\" || this.typeName === \"Position\") {\n          return this.checkAllFields(value, deep);\n        } // Calling this.checkAllFields for any other type of node is both\n        // bad for performance and way too forgiving.\n\n\n        return false;\n      } // If checking deeply and vDef === this, then we only need to call\n      // checkAllFields once. Calling checkAllFields is too strict when deep\n      // is false, because then we only care about this.isSupertypeOf(vDef).\n\n\n      if (deep && vDef === this) {\n        return this.checkAllFields(value, deep);\n      } // In most cases we rely exclusively on isSupertypeOf to make O(1)\n      // subtyping determinations. This suffices in most situations outside\n      // of unit tests, since interface conformance is checked whenever new\n      // instances are created using builder functions.\n\n\n      if (!this.isSupertypeOf(vDef)) {\n        return false;\n      } // The exception is when deep is true; then, we recursively check all\n      // fields.\n\n\n      if (!deep) {\n        return true;\n      } // Use the more specific Def (vDef) to perform the deep check, but\n      // shallow-check fields defined by the less specific Def (this).\n\n\n      return vDef.checkAllFields(value, deep) && this.checkAllFields(value, false);\n    };\n\n    DefImpl.prototype.build = function () {\n      var _this = this;\n\n      var buildParams = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        buildParams[_i] = arguments[_i];\n      } // Calling Def.prototype.build multiple times has the effect of merely\n      // redefining this property.\n\n\n      this.buildParams = buildParams;\n\n      if (this.buildable) {\n        // If this Def is already buildable, update self.buildParams and\n        // continue using the old builder function.\n        return this;\n      } // Every buildable type will have its \"type\" field filled in\n      // automatically. This includes types that are not subtypes of Node,\n      // like SourceLocation, but that seems harmless (TODO?).\n\n\n      this.field(\"type\", String, function () {\n        return _this.typeName;\n      }); // Override Dp.buildable for this Def instance.\n\n      this.buildable = true;\n\n      var addParam = function (built, param, arg, isArgAvailable) {\n        if (hasOwn.call(built, param)) return;\n        var all = _this.allFields;\n\n        if (!hasOwn.call(all, param)) {\n          throw new Error(\"\" + param);\n        }\n\n        var field = all[param];\n        var type = field.type;\n        var value;\n\n        if (isArgAvailable) {\n          value = arg;\n        } else if (field.defaultFn) {\n          // Expose the partially-built object to the default\n          // function as its `this` object.\n          value = field.defaultFn.call(built);\n        } else {\n          var message = \"no value or default function given for field \" + JSON.stringify(param) + \" of \" + _this.typeName + \"(\" + _this.buildParams.map(function (name) {\n            return all[name];\n          }).join(\", \") + \")\";\n          throw new Error(message);\n        }\n\n        if (!type.check(value)) {\n          throw new Error(shallowStringify(value) + \" does not match field \" + field + \" of type \" + _this.typeName);\n        }\n\n        built[param] = value;\n      }; // Calling the builder function will construct an instance of the Def,\n      // with positional arguments mapped to the fields original passed to .build.\n      // If not enough arguments are provided, the default value for the remaining fields\n      // will be used.\n\n\n      var builder = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        var argc = args.length;\n\n        if (!_this.finalized) {\n          throw new Error(\"attempting to instantiate unfinalized type \" + _this.typeName);\n        }\n\n        var built = Object.create(nodePrototype);\n\n        _this.buildParams.forEach(function (param, i) {\n          if (i < argc) {\n            addParam(built, param, args[i], true);\n          } else {\n            addParam(built, param, null, false);\n          }\n        });\n\n        Object.keys(_this.allFields).forEach(function (param) {\n          // Use the default value.\n          addParam(built, param, null, false);\n        }); // Make sure that the \"type\" field was filled automatically.\n\n        if (built.type !== _this.typeName) {\n          throw new Error(\"\");\n        }\n\n        return built;\n      }; // Calling .from on the builder function will construct an instance of the Def,\n      // using field values from the passed object. For fields missing from the passed object,\n      // their default value will be used.\n\n\n      builder.from = function (obj) {\n        if (!_this.finalized) {\n          throw new Error(\"attempting to instantiate unfinalized type \" + _this.typeName);\n        }\n\n        var built = Object.create(nodePrototype);\n        Object.keys(_this.allFields).forEach(function (param) {\n          if (hasOwn.call(obj, param)) {\n            addParam(built, param, obj[param], true);\n          } else {\n            addParam(built, param, null, false);\n          }\n        }); // Make sure that the \"type\" field was filled automatically.\n\n        if (built.type !== _this.typeName) {\n          throw new Error(\"\");\n        }\n\n        return built;\n      };\n\n      Object.defineProperty(builders, getBuilderName(this.typeName), {\n        enumerable: true,\n        value: builder\n      });\n      return this;\n    }; // The reason fields are specified using .field(...) instead of an object\n    // literal syntax is somewhat subtle: the object literal syntax would\n    // support only one key and one value, but with .field(...) we can pass\n    // any number of arguments to specify the field.\n\n\n    DefImpl.prototype.field = function (name, type, defaultFn, hidden) {\n      if (this.finalized) {\n        console.error(\"Ignoring attempt to redefine field \" + JSON.stringify(name) + \" of finalized type \" + JSON.stringify(this.typeName));\n        return this;\n      }\n\n      this.ownFields[name] = new Field(name, Type.from(type), defaultFn, hidden);\n      return this; // For chaining.\n    };\n\n    DefImpl.prototype.finalize = function () {\n      var _this = this; // It's not an error to finalize a type more than once, but only the\n      // first call to .finalize does anything.\n\n\n      if (!this.finalized) {\n        var allFields = this.allFields;\n        var allSupertypes = this.allSupertypes;\n        this.baseNames.forEach(function (name) {\n          var def = defCache[name];\n\n          if (def instanceof Def) {\n            def.finalize();\n            extend(allFields, def.allFields);\n            extend(allSupertypes, def.allSupertypes);\n          } else {\n            var message = \"unknown supertype name \" + JSON.stringify(name) + \" for subtype \" + JSON.stringify(_this.typeName);\n            throw new Error(message);\n          }\n        }); // TODO Warn if fields are overridden with incompatible types.\n\n        extend(allFields, this.ownFields);\n        allSupertypes[this.typeName] = this;\n        this.fieldNames.length = 0;\n\n        for (var fieldName in allFields) {\n          if (hasOwn.call(allFields, fieldName) && !allFields[fieldName].hidden) {\n            this.fieldNames.push(fieldName);\n          }\n        } // Types are exported only once they have been finalized.\n\n\n        Object.defineProperty(namedTypes, this.typeName, {\n          enumerable: true,\n          value: this.type\n        });\n        this.finalized = true; // A linearization of the inheritance hierarchy.\n\n        populateSupertypeList(this.typeName, this.supertypeList);\n\n        if (this.buildable && this.supertypeList.lastIndexOf(\"Expression\") >= 0) {\n          wrapExpressionBuilderWithStatement(this.typeName);\n        }\n      }\n    };\n\n    return DefImpl;\n  }(Def); // Note that the list returned by this function is a copy of the internal\n  // supertypeList, *without* the typeName itself as the first element.\n\n\n  function getSupertypeNames(typeName) {\n    if (!hasOwn.call(defCache, typeName)) {\n      throw new Error(\"\");\n    }\n\n    var d = defCache[typeName];\n\n    if (d.finalized !== true) {\n      throw new Error(\"\");\n    }\n\n    return d.supertypeList.slice(1);\n  } // Returns an object mapping from every known type in the defCache to the\n  // most specific supertype whose name is an own property of the candidates\n  // object.\n\n\n  function computeSupertypeLookupTable(candidates) {\n    var table = {};\n    var typeNames = Object.keys(defCache);\n    var typeNameCount = typeNames.length;\n\n    for (var i = 0; i < typeNameCount; ++i) {\n      var typeName = typeNames[i];\n      var d = defCache[typeName];\n\n      if (d.finalized !== true) {\n        throw new Error(\"\" + typeName);\n      }\n\n      for (var j = 0; j < d.supertypeList.length; ++j) {\n        var superTypeName = d.supertypeList[j];\n\n        if (hasOwn.call(candidates, superTypeName)) {\n          table[typeName] = superTypeName;\n          break;\n        }\n      }\n    }\n\n    return table;\n  }\n\n  var builders = Object.create(null); // This object is used as prototype for any node created by a builder.\n\n  var nodePrototype = {}; // Call this function to define a new method to be shared by all AST\n  // nodes. The replaced method (if any) is returned for easy wrapping.\n\n  function defineMethod(name, func) {\n    var old = nodePrototype[name]; // Pass undefined as func to delete nodePrototype[name].\n\n    if (isUndefined.check(func)) {\n      delete nodePrototype[name];\n    } else {\n      isFunction.assert(func);\n      Object.defineProperty(nodePrototype, name, {\n        enumerable: true,\n        configurable: true,\n        value: func\n      });\n    }\n\n    return old;\n  }\n\n  function getBuilderName(typeName) {\n    return typeName.replace(/^[A-Z]+/, function (upperCasePrefix) {\n      var len = upperCasePrefix.length;\n\n      switch (len) {\n        case 0:\n          return \"\";\n        // If there's only one initial capital letter, just lower-case it.\n\n        case 1:\n          return upperCasePrefix.toLowerCase();\n\n        default:\n          // If there's more than one initial capital letter, lower-case\n          // all but the last one, so that XMLDefaultDeclaration (for\n          // example) becomes xmlDefaultDeclaration.\n          return upperCasePrefix.slice(0, len - 1).toLowerCase() + upperCasePrefix.charAt(len - 1);\n      }\n    });\n  }\n\n  function getStatementBuilderName(typeName) {\n    typeName = getBuilderName(typeName);\n    return typeName.replace(/(Expression)?$/, \"Statement\");\n  }\n\n  var namedTypes = {}; // Like Object.keys, but aware of what fields each AST type should have.\n\n  function getFieldNames(object) {\n    var d = defFromValue(object);\n\n    if (d) {\n      return d.fieldNames.slice(0);\n    }\n\n    if (\"type\" in object) {\n      throw new Error(\"did not recognize object of type \" + JSON.stringify(object.type));\n    }\n\n    return Object.keys(object);\n  } // Get the value of an object property, taking object.type and default\n  // functions into account.\n\n\n  function getFieldValue(object, fieldName) {\n    var d = defFromValue(object);\n\n    if (d) {\n      var field = d.allFields[fieldName];\n\n      if (field) {\n        return field.getValue(object);\n      }\n    }\n\n    return object && object[fieldName];\n  } // Iterate over all defined fields of an object, including those missing\n  // or undefined, passing each field name and effective value (as returned\n  // by getFieldValue) to the callback. If the object has no corresponding\n  // Def, the callback will never be called.\n\n\n  function eachField(object, callback, context) {\n    getFieldNames(object).forEach(function (name) {\n      callback.call(this, name, getFieldValue(object, name));\n    }, context);\n  } // Similar to eachField, except that iteration stops as soon as the\n  // callback returns a truthy value. Like Array.prototype.some, the final\n  // result is either true or false to indicates whether the callback\n  // returned true for any element or not.\n\n\n  function someField(object, callback, context) {\n    return getFieldNames(object).some(function (name) {\n      return callback.call(this, name, getFieldValue(object, name));\n    }, context);\n  } // Adds an additional builder for Expression subtypes\n  // that wraps the built Expression in an ExpressionStatements.\n\n\n  function wrapExpressionBuilderWithStatement(typeName) {\n    var wrapperName = getStatementBuilderName(typeName); // skip if the builder already exists\n\n    if (builders[wrapperName]) return; // the builder function to wrap with builders.ExpressionStatement\n\n    var wrapped = builders[getBuilderName(typeName)]; // skip if there is nothing to wrap\n\n    if (!wrapped) return;\n\n    var builder = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return builders.expressionStatement(wrapped.apply(builders, args));\n    };\n\n    builder.from = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return builders.expressionStatement(wrapped.from.apply(builders, args));\n    };\n\n    builders[wrapperName] = builder;\n  }\n\n  function populateSupertypeList(typeName, list) {\n    list.length = 0;\n    list.push(typeName);\n    var lastSeen = Object.create(null);\n\n    for (var pos = 0; pos < list.length; ++pos) {\n      typeName = list[pos];\n      var d = defCache[typeName];\n\n      if (d.finalized !== true) {\n        throw new Error(\"\");\n      } // If we saw typeName earlier in the breadth-first traversal,\n      // delete the last-seen occurrence.\n\n\n      if (hasOwn.call(lastSeen, typeName)) {\n        delete list[lastSeen[typeName]];\n      } // Record the new index of the last-seen occurrence of typeName.\n\n\n      lastSeen[typeName] = pos; // Enqueue the base names of this type.\n\n      list.push.apply(list, d.baseNames);\n    } // Compaction loop to remove array holes.\n\n\n    for (var to = 0, from = to, len = list.length; from < len; ++from) {\n      if (hasOwn.call(list, from)) {\n        list[to++] = list[from];\n      }\n    }\n\n    list.length = to;\n  }\n\n  function extend(into, from) {\n    Object.keys(from).forEach(function (name) {\n      into[name] = from[name];\n    });\n    return into;\n  }\n\n  function finalize() {\n    Object.keys(defCache).forEach(function (name) {\n      defCache[name].finalize();\n    });\n  }\n\n  return {\n    Type: Type,\n    builtInTypes: builtInTypes,\n    getSupertypeNames: getSupertypeNames,\n    computeSupertypeLookupTable: computeSupertypeLookupTable,\n    builders: builders,\n    defineMethod: defineMethod,\n    getBuilderName: getBuilderName,\n    getStatementBuilderName: getStatementBuilderName,\n    namedTypes: namedTypes,\n    getFieldNames: getFieldNames,\n    getFieldValue: getFieldValue,\n    eachField: eachField,\n    someField: someField,\n    finalize: finalize\n  };\n}\n\nexports.default = typesPlugin;\n;","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/github/react-snippy/node_modules/jscodeshift/node_modules/ast-types/lib/types.js"],"names":["Object","defineProperty","exports","value","Def","tslib_1","require","Op","prototype","objToStr","toString","hasOwn","hasOwnProperty","BaseType","assert","deep","check","str","shallowStringify","Error","arrayOf","elemType","ArrayType","_super","__extends","_this","call","kind","Array","isArray","every","elem","IdentityType","String","result","ObjectType","fields","join","field","type","name","OrType","types","some","PredicateType","predicate","typeName","baseNames","ownFields","create","allSupertypes","supertypeList","allFields","fieldNames","finalized","buildable","buildParams","isSupertypeOf","that","checkAllFields","checkFieldByName","child","getValue","keys","bases","supertypeNames","_i","arguments","length","i","forEach","baseName","indexOf","push","Field","defaultFn","hidden","JSON","stringify","obj","map","key","typesPlugin","_fork","Type","or","from","isObject","bicfIndex","builtInCtorFns","builtInCtorTypes","def","defCache","DefImpl","hasDef","defBuiltInType","example","objStr","constructor","isString","isFunction","isRegExp","isDate","Date","isNumber","isBoolean","isNull","isUndefined","undefined","builtInTypes","string","function","array","object","RegExp","number","boolean","null","defFromValue","d","vDef","build","addParam","built","param","arg","isArgAvailable","all","message","builder","args","argc","nodePrototype","builders","getBuilderName","enumerable","console","error","finalize","extend","fieldName","namedTypes","populateSupertypeList","lastIndexOf","wrapExpressionBuilderWithStatement","getSupertypeNames","slice","computeSupertypeLookupTable","candidates","table","typeNames","typeNameCount","j","superTypeName","defineMethod","func","old","configurable","replace","upperCasePrefix","len","toLowerCase","charAt","getStatementBuilderName","getFieldNames","getFieldValue","eachField","callback","context","someField","wrapperName","wrapped","expressionStatement","apply","list","lastSeen","pos","to","into","default"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Def = void 0;\nvar tslib_1 = require(\"tslib\");\nvar Op = Object.prototype;\nvar objToStr = Op.toString;\nvar hasOwn = Op.hasOwnProperty;\nvar BaseType = /** @class */ (function () {\n    function BaseType() {\n    }\n    BaseType.prototype.assert = function (value, deep) {\n        if (!this.check(value, deep)) {\n            var str = shallowStringify(value);\n            throw new Error(str + \" does not match type \" + this);\n        }\n        return true;\n    };\n    BaseType.prototype.arrayOf = function () {\n        var elemType = this;\n        return new ArrayType(elemType);\n    };\n    return BaseType;\n}());\nvar ArrayType = /** @class */ (function (_super) {\n    tslib_1.__extends(ArrayType, _super);\n    function ArrayType(elemType) {\n        var _this = _super.call(this) || this;\n        _this.elemType = elemType;\n        _this.kind = \"ArrayType\";\n        return _this;\n    }\n    ArrayType.prototype.toString = function () {\n        return \"[\" + this.elemType + \"]\";\n    };\n    ArrayType.prototype.check = function (value, deep) {\n        var _this = this;\n        return Array.isArray(value) && value.every(function (elem) { return _this.elemType.check(elem, deep); });\n    };\n    return ArrayType;\n}(BaseType));\nvar IdentityType = /** @class */ (function (_super) {\n    tslib_1.__extends(IdentityType, _super);\n    function IdentityType(value) {\n        var _this = _super.call(this) || this;\n        _this.value = value;\n        _this.kind = \"IdentityType\";\n        return _this;\n    }\n    IdentityType.prototype.toString = function () {\n        return String(this.value);\n    };\n    IdentityType.prototype.check = function (value, deep) {\n        var result = value === this.value;\n        if (!result && typeof deep === \"function\") {\n            deep(this, value);\n        }\n        return result;\n    };\n    return IdentityType;\n}(BaseType));\nvar ObjectType = /** @class */ (function (_super) {\n    tslib_1.__extends(ObjectType, _super);\n    function ObjectType(fields) {\n        var _this = _super.call(this) || this;\n        _this.fields = fields;\n        _this.kind = \"ObjectType\";\n        return _this;\n    }\n    ObjectType.prototype.toString = function () {\n        return \"{ \" + this.fields.join(\", \") + \" }\";\n    };\n    ObjectType.prototype.check = function (value, deep) {\n        return (objToStr.call(value) === objToStr.call({}) &&\n            this.fields.every(function (field) {\n                return field.type.check(value[field.name], deep);\n            }));\n    };\n    return ObjectType;\n}(BaseType));\nvar OrType = /** @class */ (function (_super) {\n    tslib_1.__extends(OrType, _super);\n    function OrType(types) {\n        var _this = _super.call(this) || this;\n        _this.types = types;\n        _this.kind = \"OrType\";\n        return _this;\n    }\n    OrType.prototype.toString = function () {\n        return this.types.join(\" | \");\n    };\n    OrType.prototype.check = function (value, deep) {\n        return this.types.some(function (type) {\n            return type.check(value, deep);\n        });\n    };\n    return OrType;\n}(BaseType));\nvar PredicateType = /** @class */ (function (_super) {\n    tslib_1.__extends(PredicateType, _super);\n    function PredicateType(name, predicate) {\n        var _this = _super.call(this) || this;\n        _this.name = name;\n        _this.predicate = predicate;\n        _this.kind = \"PredicateType\";\n        return _this;\n    }\n    PredicateType.prototype.toString = function () {\n        return this.name;\n    };\n    PredicateType.prototype.check = function (value, deep) {\n        var result = this.predicate(value, deep);\n        if (!result && typeof deep === \"function\") {\n            deep(this, value);\n        }\n        return result;\n    };\n    return PredicateType;\n}(BaseType));\nvar Def = /** @class */ (function () {\n    function Def(type, typeName) {\n        this.type = type;\n        this.typeName = typeName;\n        this.baseNames = [];\n        this.ownFields = Object.create(null);\n        // Includes own typeName. Populated during finalization.\n        this.allSupertypes = Object.create(null);\n        // Linear inheritance hierarchy. Populated during finalization.\n        this.supertypeList = [];\n        // Includes inherited fields.\n        this.allFields = Object.create(null);\n        // Non-hidden keys of allFields.\n        this.fieldNames = [];\n        // This property will be overridden as true by individual Def instances\n        // when they are finalized.\n        this.finalized = false;\n        // False by default until .build(...) is called on an instance.\n        this.buildable = false;\n        this.buildParams = [];\n    }\n    Def.prototype.isSupertypeOf = function (that) {\n        if (that instanceof Def) {\n            if (this.finalized !== true ||\n                that.finalized !== true) {\n                throw new Error(\"\");\n            }\n            return hasOwn.call(that.allSupertypes, this.typeName);\n        }\n        else {\n            throw new Error(that + \" is not a Def\");\n        }\n    };\n    Def.prototype.checkAllFields = function (value, deep) {\n        var allFields = this.allFields;\n        if (this.finalized !== true) {\n            throw new Error(\"\" + this.typeName);\n        }\n        function checkFieldByName(name) {\n            var field = allFields[name];\n            var type = field.type;\n            var child = field.getValue(value);\n            return type.check(child, deep);\n        }\n        return value !== null &&\n            typeof value === \"object\" &&\n            Object.keys(allFields).every(checkFieldByName);\n    };\n    Def.prototype.bases = function () {\n        var supertypeNames = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            supertypeNames[_i] = arguments[_i];\n        }\n        var bases = this.baseNames;\n        if (this.finalized) {\n            if (supertypeNames.length !== bases.length) {\n                throw new Error(\"\");\n            }\n            for (var i = 0; i < supertypeNames.length; i++) {\n                if (supertypeNames[i] !== bases[i]) {\n                    throw new Error(\"\");\n                }\n            }\n            return this;\n        }\n        supertypeNames.forEach(function (baseName) {\n            // This indexOf lookup may be O(n), but the typical number of base\n            // names is very small, and indexOf is a native Array method.\n            if (bases.indexOf(baseName) < 0) {\n                bases.push(baseName);\n            }\n        });\n        return this; // For chaining.\n    };\n    return Def;\n}());\nexports.Def = Def;\nvar Field = /** @class */ (function () {\n    function Field(name, type, defaultFn, hidden) {\n        this.name = name;\n        this.type = type;\n        this.defaultFn = defaultFn;\n        this.hidden = !!hidden;\n    }\n    Field.prototype.toString = function () {\n        return JSON.stringify(this.name) + \": \" + this.type;\n    };\n    Field.prototype.getValue = function (obj) {\n        var value = obj[this.name];\n        if (typeof value !== \"undefined\") {\n            return value;\n        }\n        if (typeof this.defaultFn === \"function\") {\n            value = this.defaultFn.call(obj);\n        }\n        return value;\n    };\n    return Field;\n}());\nfunction shallowStringify(value) {\n    if (Array.isArray(value)) {\n        return \"[\" + value.map(shallowStringify).join(\", \") + \"]\";\n    }\n    if (value && typeof value === \"object\") {\n        return \"{ \" + Object.keys(value).map(function (key) {\n            return key + \": \" + value[key];\n        }).join(\", \") + \" }\";\n    }\n    return JSON.stringify(value);\n}\nfunction typesPlugin(_fork) {\n    var Type = {\n        or: function () {\n            var types = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                types[_i] = arguments[_i];\n            }\n            return new OrType(types.map(function (type) { return Type.from(type); }));\n        },\n        from: function (value, name) {\n            if (value instanceof ArrayType ||\n                value instanceof IdentityType ||\n                value instanceof ObjectType ||\n                value instanceof OrType ||\n                value instanceof PredicateType) {\n                return value;\n            }\n            // The Def type is used as a helper for constructing compound\n            // interface types for AST nodes.\n            if (value instanceof Def) {\n                return value.type;\n            }\n            // Support [ElemType] syntax.\n            if (isArray.check(value)) {\n                if (value.length !== 1) {\n                    throw new Error(\"only one element type is permitted for typed arrays\");\n                }\n                return new ArrayType(Type.from(value[0]));\n            }\n            // Support { someField: FieldType, ... } syntax.\n            if (isObject.check(value)) {\n                return new ObjectType(Object.keys(value).map(function (name) {\n                    return new Field(name, Type.from(value[name], name));\n                }));\n            }\n            if (typeof value === \"function\") {\n                var bicfIndex = builtInCtorFns.indexOf(value);\n                if (bicfIndex >= 0) {\n                    return builtInCtorTypes[bicfIndex];\n                }\n                if (typeof name !== \"string\") {\n                    throw new Error(\"missing name\");\n                }\n                return new PredicateType(name, value);\n            }\n            // As a last resort, toType returns a type that matches any value that\n            // is === from. This is primarily useful for literal values like\n            // toType(null), but it has the additional advantage of allowing\n            // toType to be a total function.\n            return new IdentityType(value);\n        },\n        // Define a type whose name is registered in a namespace (the defCache) so\n        // that future definitions will return the same type given the same name.\n        // In particular, this system allows for circular and forward definitions.\n        // The Def object d returned from Type.def may be used to configure the\n        // type d.type by calling methods such as d.bases, d.build, and d.field.\n        def: function (typeName) {\n            return hasOwn.call(defCache, typeName)\n                ? defCache[typeName]\n                : defCache[typeName] = new DefImpl(typeName);\n        },\n        hasDef: function (typeName) {\n            return hasOwn.call(defCache, typeName);\n        }\n    };\n    var builtInCtorFns = [];\n    var builtInCtorTypes = [];\n    function defBuiltInType(name, example) {\n        var objStr = objToStr.call(example);\n        var type = new PredicateType(name, function (value) { return objToStr.call(value) === objStr; });\n        if (example && typeof example.constructor === \"function\") {\n            builtInCtorFns.push(example.constructor);\n            builtInCtorTypes.push(type);\n        }\n        return type;\n    }\n    // These types check the underlying [[Class]] attribute of the given\n    // value, rather than using the problematic typeof operator. Note however\n    // that no subtyping is considered; so, for instance, isObject.check\n    // returns false for [], /./, new Date, and null.\n    var isString = defBuiltInType(\"string\", \"truthy\");\n    var isFunction = defBuiltInType(\"function\", function () { });\n    var isArray = defBuiltInType(\"array\", []);\n    var isObject = defBuiltInType(\"object\", {});\n    var isRegExp = defBuiltInType(\"RegExp\", /./);\n    var isDate = defBuiltInType(\"Date\", new Date());\n    var isNumber = defBuiltInType(\"number\", 3);\n    var isBoolean = defBuiltInType(\"boolean\", true);\n    var isNull = defBuiltInType(\"null\", null);\n    var isUndefined = defBuiltInType(\"undefined\", undefined);\n    var builtInTypes = {\n        string: isString,\n        function: isFunction,\n        array: isArray,\n        object: isObject,\n        RegExp: isRegExp,\n        Date: isDate,\n        number: isNumber,\n        boolean: isBoolean,\n        null: isNull,\n        undefined: isUndefined,\n    };\n    // In order to return the same Def instance every time Type.def is called\n    // with a particular name, those instances need to be stored in a cache.\n    var defCache = Object.create(null);\n    function defFromValue(value) {\n        if (value && typeof value === \"object\") {\n            var type = value.type;\n            if (typeof type === \"string\" &&\n                hasOwn.call(defCache, type)) {\n                var d = defCache[type];\n                if (d.finalized) {\n                    return d;\n                }\n            }\n        }\n        return null;\n    }\n    var DefImpl = /** @class */ (function (_super) {\n        tslib_1.__extends(DefImpl, _super);\n        function DefImpl(typeName) {\n            var _this = _super.call(this, new PredicateType(typeName, function (value, deep) { return _this.check(value, deep); }), typeName) || this;\n            return _this;\n        }\n        DefImpl.prototype.check = function (value, deep) {\n            if (this.finalized !== true) {\n                throw new Error(\"prematurely checking unfinalized type \" + this.typeName);\n            }\n            // A Def type can only match an object value.\n            if (value === null || typeof value !== \"object\") {\n                return false;\n            }\n            var vDef = defFromValue(value);\n            if (!vDef) {\n                // If we couldn't infer the Def associated with the given value,\n                // and we expected it to be a SourceLocation or a Position, it was\n                // probably just missing a \"type\" field (because Esprima does not\n                // assign a type property to such nodes). Be optimistic and let\n                // this.checkAllFields make the final decision.\n                if (this.typeName === \"SourceLocation\" ||\n                    this.typeName === \"Position\") {\n                    return this.checkAllFields(value, deep);\n                }\n                // Calling this.checkAllFields for any other type of node is both\n                // bad for performance and way too forgiving.\n                return false;\n            }\n            // If checking deeply and vDef === this, then we only need to call\n            // checkAllFields once. Calling checkAllFields is too strict when deep\n            // is false, because then we only care about this.isSupertypeOf(vDef).\n            if (deep && vDef === this) {\n                return this.checkAllFields(value, deep);\n            }\n            // In most cases we rely exclusively on isSupertypeOf to make O(1)\n            // subtyping determinations. This suffices in most situations outside\n            // of unit tests, since interface conformance is checked whenever new\n            // instances are created using builder functions.\n            if (!this.isSupertypeOf(vDef)) {\n                return false;\n            }\n            // The exception is when deep is true; then, we recursively check all\n            // fields.\n            if (!deep) {\n                return true;\n            }\n            // Use the more specific Def (vDef) to perform the deep check, but\n            // shallow-check fields defined by the less specific Def (this).\n            return vDef.checkAllFields(value, deep)\n                && this.checkAllFields(value, false);\n        };\n        DefImpl.prototype.build = function () {\n            var _this = this;\n            var buildParams = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                buildParams[_i] = arguments[_i];\n            }\n            // Calling Def.prototype.build multiple times has the effect of merely\n            // redefining this property.\n            this.buildParams = buildParams;\n            if (this.buildable) {\n                // If this Def is already buildable, update self.buildParams and\n                // continue using the old builder function.\n                return this;\n            }\n            // Every buildable type will have its \"type\" field filled in\n            // automatically. This includes types that are not subtypes of Node,\n            // like SourceLocation, but that seems harmless (TODO?).\n            this.field(\"type\", String, function () { return _this.typeName; });\n            // Override Dp.buildable for this Def instance.\n            this.buildable = true;\n            var addParam = function (built, param, arg, isArgAvailable) {\n                if (hasOwn.call(built, param))\n                    return;\n                var all = _this.allFields;\n                if (!hasOwn.call(all, param)) {\n                    throw new Error(\"\" + param);\n                }\n                var field = all[param];\n                var type = field.type;\n                var value;\n                if (isArgAvailable) {\n                    value = arg;\n                }\n                else if (field.defaultFn) {\n                    // Expose the partially-built object to the default\n                    // function as its `this` object.\n                    value = field.defaultFn.call(built);\n                }\n                else {\n                    var message = \"no value or default function given for field \" +\n                        JSON.stringify(param) + \" of \" + _this.typeName + \"(\" +\n                        _this.buildParams.map(function (name) {\n                            return all[name];\n                        }).join(\", \") + \")\";\n                    throw new Error(message);\n                }\n                if (!type.check(value)) {\n                    throw new Error(shallowStringify(value) +\n                        \" does not match field \" + field +\n                        \" of type \" + _this.typeName);\n                }\n                built[param] = value;\n            };\n            // Calling the builder function will construct an instance of the Def,\n            // with positional arguments mapped to the fields original passed to .build.\n            // If not enough arguments are provided, the default value for the remaining fields\n            // will be used.\n            var builder = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var argc = args.length;\n                if (!_this.finalized) {\n                    throw new Error(\"attempting to instantiate unfinalized type \" +\n                        _this.typeName);\n                }\n                var built = Object.create(nodePrototype);\n                _this.buildParams.forEach(function (param, i) {\n                    if (i < argc) {\n                        addParam(built, param, args[i], true);\n                    }\n                    else {\n                        addParam(built, param, null, false);\n                    }\n                });\n                Object.keys(_this.allFields).forEach(function (param) {\n                    // Use the default value.\n                    addParam(built, param, null, false);\n                });\n                // Make sure that the \"type\" field was filled automatically.\n                if (built.type !== _this.typeName) {\n                    throw new Error(\"\");\n                }\n                return built;\n            };\n            // Calling .from on the builder function will construct an instance of the Def,\n            // using field values from the passed object. For fields missing from the passed object,\n            // their default value will be used.\n            builder.from = function (obj) {\n                if (!_this.finalized) {\n                    throw new Error(\"attempting to instantiate unfinalized type \" +\n                        _this.typeName);\n                }\n                var built = Object.create(nodePrototype);\n                Object.keys(_this.allFields).forEach(function (param) {\n                    if (hasOwn.call(obj, param)) {\n                        addParam(built, param, obj[param], true);\n                    }\n                    else {\n                        addParam(built, param, null, false);\n                    }\n                });\n                // Make sure that the \"type\" field was filled automatically.\n                if (built.type !== _this.typeName) {\n                    throw new Error(\"\");\n                }\n                return built;\n            };\n            Object.defineProperty(builders, getBuilderName(this.typeName), {\n                enumerable: true,\n                value: builder\n            });\n            return this;\n        };\n        // The reason fields are specified using .field(...) instead of an object\n        // literal syntax is somewhat subtle: the object literal syntax would\n        // support only one key and one value, but with .field(...) we can pass\n        // any number of arguments to specify the field.\n        DefImpl.prototype.field = function (name, type, defaultFn, hidden) {\n            if (this.finalized) {\n                console.error(\"Ignoring attempt to redefine field \" +\n                    JSON.stringify(name) + \" of finalized type \" +\n                    JSON.stringify(this.typeName));\n                return this;\n            }\n            this.ownFields[name] = new Field(name, Type.from(type), defaultFn, hidden);\n            return this; // For chaining.\n        };\n        DefImpl.prototype.finalize = function () {\n            var _this = this;\n            // It's not an error to finalize a type more than once, but only the\n            // first call to .finalize does anything.\n            if (!this.finalized) {\n                var allFields = this.allFields;\n                var allSupertypes = this.allSupertypes;\n                this.baseNames.forEach(function (name) {\n                    var def = defCache[name];\n                    if (def instanceof Def) {\n                        def.finalize();\n                        extend(allFields, def.allFields);\n                        extend(allSupertypes, def.allSupertypes);\n                    }\n                    else {\n                        var message = \"unknown supertype name \" +\n                            JSON.stringify(name) +\n                            \" for subtype \" +\n                            JSON.stringify(_this.typeName);\n                        throw new Error(message);\n                    }\n                });\n                // TODO Warn if fields are overridden with incompatible types.\n                extend(allFields, this.ownFields);\n                allSupertypes[this.typeName] = this;\n                this.fieldNames.length = 0;\n                for (var fieldName in allFields) {\n                    if (hasOwn.call(allFields, fieldName) &&\n                        !allFields[fieldName].hidden) {\n                        this.fieldNames.push(fieldName);\n                    }\n                }\n                // Types are exported only once they have been finalized.\n                Object.defineProperty(namedTypes, this.typeName, {\n                    enumerable: true,\n                    value: this.type\n                });\n                this.finalized = true;\n                // A linearization of the inheritance hierarchy.\n                populateSupertypeList(this.typeName, this.supertypeList);\n                if (this.buildable &&\n                    this.supertypeList.lastIndexOf(\"Expression\") >= 0) {\n                    wrapExpressionBuilderWithStatement(this.typeName);\n                }\n            }\n        };\n        return DefImpl;\n    }(Def));\n    // Note that the list returned by this function is a copy of the internal\n    // supertypeList, *without* the typeName itself as the first element.\n    function getSupertypeNames(typeName) {\n        if (!hasOwn.call(defCache, typeName)) {\n            throw new Error(\"\");\n        }\n        var d = defCache[typeName];\n        if (d.finalized !== true) {\n            throw new Error(\"\");\n        }\n        return d.supertypeList.slice(1);\n    }\n    // Returns an object mapping from every known type in the defCache to the\n    // most specific supertype whose name is an own property of the candidates\n    // object.\n    function computeSupertypeLookupTable(candidates) {\n        var table = {};\n        var typeNames = Object.keys(defCache);\n        var typeNameCount = typeNames.length;\n        for (var i = 0; i < typeNameCount; ++i) {\n            var typeName = typeNames[i];\n            var d = defCache[typeName];\n            if (d.finalized !== true) {\n                throw new Error(\"\" + typeName);\n            }\n            for (var j = 0; j < d.supertypeList.length; ++j) {\n                var superTypeName = d.supertypeList[j];\n                if (hasOwn.call(candidates, superTypeName)) {\n                    table[typeName] = superTypeName;\n                    break;\n                }\n            }\n        }\n        return table;\n    }\n    var builders = Object.create(null);\n    // This object is used as prototype for any node created by a builder.\n    var nodePrototype = {};\n    // Call this function to define a new method to be shared by all AST\n    // nodes. The replaced method (if any) is returned for easy wrapping.\n    function defineMethod(name, func) {\n        var old = nodePrototype[name];\n        // Pass undefined as func to delete nodePrototype[name].\n        if (isUndefined.check(func)) {\n            delete nodePrototype[name];\n        }\n        else {\n            isFunction.assert(func);\n            Object.defineProperty(nodePrototype, name, {\n                enumerable: true,\n                configurable: true,\n                value: func\n            });\n        }\n        return old;\n    }\n    function getBuilderName(typeName) {\n        return typeName.replace(/^[A-Z]+/, function (upperCasePrefix) {\n            var len = upperCasePrefix.length;\n            switch (len) {\n                case 0: return \"\";\n                // If there's only one initial capital letter, just lower-case it.\n                case 1: return upperCasePrefix.toLowerCase();\n                default:\n                    // If there's more than one initial capital letter, lower-case\n                    // all but the last one, so that XMLDefaultDeclaration (for\n                    // example) becomes xmlDefaultDeclaration.\n                    return upperCasePrefix.slice(0, len - 1).toLowerCase() +\n                        upperCasePrefix.charAt(len - 1);\n            }\n        });\n    }\n    function getStatementBuilderName(typeName) {\n        typeName = getBuilderName(typeName);\n        return typeName.replace(/(Expression)?$/, \"Statement\");\n    }\n    var namedTypes = {};\n    // Like Object.keys, but aware of what fields each AST type should have.\n    function getFieldNames(object) {\n        var d = defFromValue(object);\n        if (d) {\n            return d.fieldNames.slice(0);\n        }\n        if (\"type\" in object) {\n            throw new Error(\"did not recognize object of type \" +\n                JSON.stringify(object.type));\n        }\n        return Object.keys(object);\n    }\n    // Get the value of an object property, taking object.type and default\n    // functions into account.\n    function getFieldValue(object, fieldName) {\n        var d = defFromValue(object);\n        if (d) {\n            var field = d.allFields[fieldName];\n            if (field) {\n                return field.getValue(object);\n            }\n        }\n        return object && object[fieldName];\n    }\n    // Iterate over all defined fields of an object, including those missing\n    // or undefined, passing each field name and effective value (as returned\n    // by getFieldValue) to the callback. If the object has no corresponding\n    // Def, the callback will never be called.\n    function eachField(object, callback, context) {\n        getFieldNames(object).forEach(function (name) {\n            callback.call(this, name, getFieldValue(object, name));\n        }, context);\n    }\n    // Similar to eachField, except that iteration stops as soon as the\n    // callback returns a truthy value. Like Array.prototype.some, the final\n    // result is either true or false to indicates whether the callback\n    // returned true for any element or not.\n    function someField(object, callback, context) {\n        return getFieldNames(object).some(function (name) {\n            return callback.call(this, name, getFieldValue(object, name));\n        }, context);\n    }\n    // Adds an additional builder for Expression subtypes\n    // that wraps the built Expression in an ExpressionStatements.\n    function wrapExpressionBuilderWithStatement(typeName) {\n        var wrapperName = getStatementBuilderName(typeName);\n        // skip if the builder already exists\n        if (builders[wrapperName])\n            return;\n        // the builder function to wrap with builders.ExpressionStatement\n        var wrapped = builders[getBuilderName(typeName)];\n        // skip if there is nothing to wrap\n        if (!wrapped)\n            return;\n        var builder = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return builders.expressionStatement(wrapped.apply(builders, args));\n        };\n        builder.from = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return builders.expressionStatement(wrapped.from.apply(builders, args));\n        };\n        builders[wrapperName] = builder;\n    }\n    function populateSupertypeList(typeName, list) {\n        list.length = 0;\n        list.push(typeName);\n        var lastSeen = Object.create(null);\n        for (var pos = 0; pos < list.length; ++pos) {\n            typeName = list[pos];\n            var d = defCache[typeName];\n            if (d.finalized !== true) {\n                throw new Error(\"\");\n            }\n            // If we saw typeName earlier in the breadth-first traversal,\n            // delete the last-seen occurrence.\n            if (hasOwn.call(lastSeen, typeName)) {\n                delete list[lastSeen[typeName]];\n            }\n            // Record the new index of the last-seen occurrence of typeName.\n            lastSeen[typeName] = pos;\n            // Enqueue the base names of this type.\n            list.push.apply(list, d.baseNames);\n        }\n        // Compaction loop to remove array holes.\n        for (var to = 0, from = to, len = list.length; from < len; ++from) {\n            if (hasOwn.call(list, from)) {\n                list[to++] = list[from];\n            }\n        }\n        list.length = to;\n    }\n    function extend(into, from) {\n        Object.keys(from).forEach(function (name) {\n            into[name] = from[name];\n        });\n        return into;\n    }\n    function finalize() {\n        Object.keys(defCache).forEach(function (name) {\n            defCache[name].finalize();\n        });\n    }\n    return {\n        Type: Type,\n        builtInTypes: builtInTypes,\n        getSupertypeNames: getSupertypeNames,\n        computeSupertypeLookupTable: computeSupertypeLookupTable,\n        builders: builders,\n        defineMethod: defineMethod,\n        getBuilderName: getBuilderName,\n        getStatementBuilderName: getStatementBuilderName,\n        namedTypes: namedTypes,\n        getFieldNames: getFieldNames,\n        getFieldValue: getFieldValue,\n        eachField: eachField,\n        someField: someField,\n        finalize: finalize,\n    };\n}\nexports.default = typesPlugin;\n;\n"]},"metadata":{},"sourceType":"script"}