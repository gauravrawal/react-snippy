{"ast":null,"code":"module.exports = inlineCode;\ninlineCode.peek = inlineCodePeek;\n\nvar patternCompile = require('../util/pattern-compile');\n\nfunction inlineCode(node, parent, context) {\n  var value = node.value || '';\n  var sequence = '`';\n  var index = -1;\n  var pattern;\n  var expression;\n  var match;\n  var position; // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`';\n  } // If this is not just spaces or eols (tabs don’t count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n\n\n  if (/[^ \\r\\n]/.test(value) && (/[ \\r\\n`]/.test(value.charAt(0)) || /[ \\r\\n`]/.test(value.charAt(value.length - 1)))) {\n    value = ' ' + value + ' ';\n  } // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We can’t escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n\n\n  while (++index < context.unsafe.length) {\n    pattern = context.unsafe[index]; // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n\n    if (!pattern.atBreak) continue;\n    expression = patternCompile(pattern);\n\n    while (match = expression.exec(value)) {\n      position = match.index; // Support CRLF (patterns only look for one of the characters).\n\n      if (value.charCodeAt(position) === 10\n      /* `\\n` */\n      && value.charCodeAt(position - 1) === 13\n      /* `\\r` */\n      ) {\n          position--;\n        }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1);\n    }\n  }\n\n  return sequence + value + sequence;\n}\n\nfunction inlineCodePeek() {\n  return '`';\n}","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/jbook/node_modules/mdast-util-to-markdown/lib/handle/inline-code.js"],"names":["module","exports","inlineCode","peek","inlineCodePeek","patternCompile","require","node","parent","context","value","sequence","index","pattern","expression","match","position","RegExp","test","charAt","length","unsafe","atBreak","exec","charCodeAt","slice"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiBC,UAAjB;AACAA,UAAU,CAACC,IAAX,GAAkBC,cAAlB;;AAEA,IAAIC,cAAc,GAAGC,OAAO,CAAC,yBAAD,CAA5B;;AAEA,SAASJ,UAAT,CAAoBK,IAApB,EAA0BC,MAA1B,EAAkCC,OAAlC,EAA2C;AACzC,MAAIC,KAAK,GAAGH,IAAI,CAACG,KAAL,IAAc,EAA1B;AACA,MAAIC,QAAQ,GAAG,GAAf;AACA,MAAIC,KAAK,GAAG,CAAC,CAAb;AACA,MAAIC,OAAJ;AACA,MAAIC,UAAJ;AACA,MAAIC,KAAJ;AACA,MAAIC,QAAJ,CAPyC,CASzC;AACA;AACA;;AACA,SAAO,IAAIC,MAAJ,CAAW,aAAaN,QAAb,GAAwB,UAAnC,EAA+CO,IAA/C,CAAoDR,KAApD,CAAP,EAAmE;AACjEC,IAAAA,QAAQ,IAAI,GAAZ;AACD,GAdwC,CAgBzC;AACA;;;AACA,MACE,WAAWO,IAAX,CAAgBR,KAAhB,MACC,WAAWQ,IAAX,CAAgBR,KAAK,CAACS,MAAN,CAAa,CAAb,CAAhB,KACC,WAAWD,IAAX,CAAgBR,KAAK,CAACS,MAAN,CAAaT,KAAK,CAACU,MAAN,GAAe,CAA5B,CAAhB,CAFF,CADF,EAIE;AACAV,IAAAA,KAAK,GAAG,MAAMA,KAAN,GAAc,GAAtB;AACD,GAxBwC,CA0BzC;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAO,EAAEE,KAAF,GAAUH,OAAO,CAACY,MAAR,CAAeD,MAAhC,EAAwC;AACtCP,IAAAA,OAAO,GAAGJ,OAAO,CAACY,MAAR,CAAeT,KAAf,CAAV,CADsC,CAGtC;AACA;AACA;;AACA,QAAI,CAACC,OAAO,CAACS,OAAb,EAAsB;AAEtBR,IAAAA,UAAU,GAAGT,cAAc,CAACQ,OAAD,CAA3B;;AAEA,WAAQE,KAAK,GAAGD,UAAU,CAACS,IAAX,CAAgBb,KAAhB,CAAhB,EAAyC;AACvCM,MAAAA,QAAQ,GAAGD,KAAK,CAACH,KAAjB,CADuC,CAGvC;;AACA,UACEF,KAAK,CAACc,UAAN,CAAiBR,QAAjB,MAA+B;AAAG;AAAlC,SACAN,KAAK,CAACc,UAAN,CAAiBR,QAAQ,GAAG,CAA5B,MAAmC;AAAG;AAFxC,QAGE;AACAA,UAAAA,QAAQ;AACT;;AAEDN,MAAAA,KAAK,GAAGA,KAAK,CAACe,KAAN,CAAY,CAAZ,EAAeT,QAAf,IAA2B,GAA3B,GAAiCN,KAAK,CAACe,KAAN,CAAYV,KAAK,CAACH,KAAN,GAAc,CAA1B,CAAzC;AACD;AACF;;AAED,SAAOD,QAAQ,GAAGD,KAAX,GAAmBC,QAA1B;AACD;;AAED,SAASP,cAAT,GAA0B;AACxB,SAAO,GAAP;AACD","sourcesContent":["module.exports = inlineCode\ninlineCode.peek = inlineCodePeek\n\nvar patternCompile = require('../util/pattern-compile')\n\nfunction inlineCode(node, parent, context) {\n  var value = node.value || ''\n  var sequence = '`'\n  var index = -1\n  var pattern\n  var expression\n  var match\n  var position\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs don’t count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    (/[ \\r\\n`]/.test(value.charAt(0)) ||\n      /[ \\r\\n`]/.test(value.charAt(value.length - 1)))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We can’t escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < context.unsafe.length) {\n    pattern = context.unsafe[index]\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    expression = patternCompile(pattern)\n\n    while ((match = expression.exec(value))) {\n      position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\nfunction inlineCodePeek() {\n  return '`'\n}\n"]},"metadata":{},"sourceType":"script"}