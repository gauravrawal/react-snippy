{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nconst Collection = require('./Collection');\n\nconst collections = require('./collections');\n\nconst getParser = require('./getParser');\n\nconst matchNode = require('./matchNode');\n\nconst recast = require('recast');\n\nconst template = require('./template');\n\nconst Node = recast.types.namedTypes.Node;\nconst NodePath = recast.types.NodePath; // Register all built-in collections\n\nfor (var name in collections) {\n  collections[name].register();\n}\n/**\n * Main entry point to the tool. The function accepts multiple different kinds\n * of arguments as a convenience. In particular the function accepts either\n *\n * - a string containing source code\n *   The string is parsed with Recast\n * - a single AST node\n * - a single node path\n * - an array of nodes\n * - an array of node paths\n *\n * @exports jscodeshift\n * @param {Node|NodePath|Array|string} source\n * @param {Object} options Options to pass to Recast when passing source code\n * @return {Collection}\n */\n\n\nfunction core(source, options) {\n  return typeof source === 'string' ? fromSource(source, options) : fromAST(source);\n}\n/**\n * Returns a collection from a node, node path, array of nodes or array of node\n * paths.\n *\n * @ignore\n * @param {Node|NodePath|Array} source\n * @return {Collection}\n */\n\n\nfunction fromAST(ast) {\n  if (Array.isArray(ast)) {\n    if (ast[0] instanceof NodePath || ast.length === 0) {\n      return Collection.fromPaths(ast);\n    } else if (Node.check(ast[0])) {\n      return Collection.fromNodes(ast);\n    }\n  } else {\n    if (ast instanceof NodePath) {\n      return Collection.fromPaths([ast]);\n    } else if (Node.check(ast)) {\n      return Collection.fromNodes([ast]);\n    }\n  }\n\n  throw new TypeError('Received an unexpected value ' + Object.prototype.toString.call(ast));\n}\n\nfunction fromSource(source, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (!options.parser) {\n    options.parser = getParser();\n  }\n\n  return fromAST(recast.parse(source, options));\n}\n/**\n * Utility function to match a node against a pattern.\n * @augments core\n * @static\n * @param {Node|NodePath|Object} path\n * @parma {Object} filter\n * @return boolean\n */\n\n\nfunction match(path, filter) {\n  if (!(path instanceof NodePath)) {\n    if (typeof path.get === 'function') {\n      path = path.get();\n    } else {\n      path = {\n        value: path\n      };\n    }\n  }\n\n  return matchNode(path.value, filter);\n}\n\nconst plugins = [];\n/**\n * Utility function for registering plugins.\n *\n * Plugins are simple functions that are passed the core jscodeshift instance.\n * They should extend jscodeshift by calling `registerMethods`, etc.\n * This method guards against repeated registrations (the plugin callback will only be called once).\n *\n * @augments core\n * @static\n * @param {Function} plugin\n */\n\nfunction use(plugin) {\n  if (plugins.indexOf(plugin) === -1) {\n    plugins.push(plugin);\n    plugin(core);\n  }\n}\n/**\n * Returns a version of the core jscodeshift function \"bound\" to a specific\n * parser.\n *\n * @augments core\n * @static\n */\n\n\nfunction withParser(parser) {\n  if (typeof parser === 'string') {\n    parser = getParser(parser);\n  }\n\n  const newCore = function (source, options) {\n    if (options && !options.parser) {\n      options.parser = parser;\n    } else {\n      options = {\n        parser\n      };\n    }\n\n    return core(source, options);\n  };\n\n  return enrichCore(newCore, parser);\n}\n/**\n* The ast-types library\n* @external astTypes\n* @see {@link https://github.com/benjamn/ast-types}\n*/\n\n\nfunction enrichCore(core, parser) {\n  // add builders and types to the function for simple access\n  Object.assign(core, recast.types.namedTypes);\n  Object.assign(core, recast.types.builders);\n  core.registerMethods = Collection.registerMethods;\n  /**\n  * @augments core\n  * @type external:astTypes\n  */\n\n  core.types = recast.types;\n  core.match = match;\n  core.template = template(parser); // add mappings and filters to function\n\n  core.filters = {};\n  core.mappings = {};\n\n  for (const name in collections) {\n    if (collections[name].filters) {\n      core.filters[name] = collections[name].filters;\n    }\n\n    if (collections[name].mappings) {\n      core.mappings[name] = collections[name].mappings;\n    }\n  }\n\n  core.use = use;\n  core.withParser = withParser;\n  return core;\n}\n\nmodule.exports = enrichCore(core, getParser());","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/jbook/node_modules/jscodeshift/src/core.js"],"names":["Collection","require","collections","getParser","matchNode","recast","template","Node","types","namedTypes","NodePath","name","register","core","source","options","fromSource","fromAST","ast","Array","isArray","length","fromPaths","check","fromNodes","TypeError","Object","prototype","toString","call","parser","parse","match","path","filter","get","value","plugins","use","plugin","indexOf","push","withParser","newCore","enrichCore","assign","builders","registerMethods","filters","mappings","module","exports"],"mappings":"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","sourcesContent":["\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\nconst Collection = require('./Collection');\n\nconst collections = require('./collections');\nconst getParser = require('./getParser');\nconst matchNode = require('./matchNode');\nconst recast = require('recast');\nconst template = require('./template');\n\nconst Node = recast.types.namedTypes.Node;\nconst NodePath = recast.types.NodePath;\n\n// Register all built-in collections\nfor (var name in collections) {\n  collections[name].register();\n}\n\n/**\n * Main entry point to the tool. The function accepts multiple different kinds\n * of arguments as a convenience. In particular the function accepts either\n *\n * - a string containing source code\n *   The string is parsed with Recast\n * - a single AST node\n * - a single node path\n * - an array of nodes\n * - an array of node paths\n *\n * @exports jscodeshift\n * @param {Node|NodePath|Array|string} source\n * @param {Object} options Options to pass to Recast when passing source code\n * @return {Collection}\n */\nfunction core(source, options) {\n  return typeof source === 'string' ?\n    fromSource(source, options) :\n    fromAST(source);\n}\n\n/**\n * Returns a collection from a node, node path, array of nodes or array of node\n * paths.\n *\n * @ignore\n * @param {Node|NodePath|Array} source\n * @return {Collection}\n */\nfunction fromAST(ast) {\n  if (Array.isArray(ast)) {\n    if (ast[0] instanceof NodePath || ast.length === 0) {\n      return Collection.fromPaths(ast);\n    } else if (Node.check(ast[0])) {\n      return Collection.fromNodes(ast);\n    }\n  } else {\n    if (ast instanceof NodePath) {\n      return Collection.fromPaths([ast]);\n    } else if (Node.check(ast)) {\n      return Collection.fromNodes([ast]);\n    }\n  }\n  throw new TypeError(\n    'Received an unexpected value ' + Object.prototype.toString.call(ast)\n  );\n}\n\nfunction fromSource(source, options) {\n  if (!options) {\n    options = {};\n  }\n  if (!options.parser) {\n    options.parser = getParser();\n  }\n  return fromAST(recast.parse(source, options));\n}\n\n/**\n * Utility function to match a node against a pattern.\n * @augments core\n * @static\n * @param {Node|NodePath|Object} path\n * @parma {Object} filter\n * @return boolean\n */\nfunction match(path, filter) {\n  if (!(path instanceof NodePath)) {\n    if (typeof path.get === 'function') {\n      path = path.get();\n    } else {\n      path = {value: path};\n    }\n  }\n  return matchNode(path.value, filter);\n}\n\nconst plugins = [];\n\n/**\n * Utility function for registering plugins.\n *\n * Plugins are simple functions that are passed the core jscodeshift instance.\n * They should extend jscodeshift by calling `registerMethods`, etc.\n * This method guards against repeated registrations (the plugin callback will only be called once).\n *\n * @augments core\n * @static\n * @param {Function} plugin\n */\nfunction use(plugin) {\n  if (plugins.indexOf(plugin) === -1) {\n    plugins.push(plugin);\n    plugin(core);\n  }\n}\n\n/**\n * Returns a version of the core jscodeshift function \"bound\" to a specific\n * parser.\n *\n * @augments core\n * @static\n */\nfunction withParser(parser) {\n  if (typeof parser === 'string') {\n    parser = getParser(parser);\n  }\n\n  const newCore = function(source, options) {\n    if (options && !options.parser) {\n      options.parser = parser;\n    } else {\n      options = {parser};\n    }\n    return core(source, options);\n  };\n\n  return enrichCore(newCore, parser);\n}\n\n/**\n* The ast-types library\n* @external astTypes\n* @see {@link https://github.com/benjamn/ast-types}\n*/\n\nfunction enrichCore(core, parser) {\n  // add builders and types to the function for simple access\n  Object.assign(core, recast.types.namedTypes);\n  Object.assign(core, recast.types.builders);\n  core.registerMethods = Collection.registerMethods;\n  /**\n  * @augments core\n  * @type external:astTypes\n  */\n  core.types = recast.types;\n  core.match = match;\n  core.template = template(parser);\n\n  // add mappings and filters to function\n  core.filters = {};\n  core.mappings = {};\n  for (const name in collections) {\n    if (collections[name].filters) {\n      core.filters[name] = collections[name].filters;\n    }\n    if (collections[name].mappings) {\n      core.mappings[name] = collections[name].mappings;\n    }\n  }\n  core.use = use;\n  core.withParser = withParser;\n  return core;\n}\n\nmodule.exports = enrichCore(core, getParser());\n"]},"metadata":{},"sourceType":"script"}