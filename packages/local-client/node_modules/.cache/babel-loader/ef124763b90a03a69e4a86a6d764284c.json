{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isTrailingCommaEnabled = exports.getParentExportDeclaration = exports.isExportDeclaration = exports.fixFaultyLocations = exports.getTrueLoc = exports.composeSourceMaps = exports.copyPos = exports.comparePos = exports.getUnionOfKeys = exports.getOption = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\n\nvar types = tslib_1.__importStar(require(\"ast-types\"));\n\nvar n = types.namedTypes;\n\nvar source_map_1 = tslib_1.__importDefault(require(\"source-map\"));\n\nvar SourceMapConsumer = source_map_1.default.SourceMapConsumer;\nvar SourceMapGenerator = source_map_1.default.SourceMapGenerator;\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction getOption(options, key, defaultValue) {\n  if (options && hasOwn.call(options, key)) {\n    return options[key];\n  }\n\n  return defaultValue;\n}\n\nexports.getOption = getOption;\n\nfunction getUnionOfKeys() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  var result = {};\n  var argc = args.length;\n\n  for (var i = 0; i < argc; ++i) {\n    var keys = Object.keys(args[i]);\n    var keyCount = keys.length;\n\n    for (var j = 0; j < keyCount; ++j) {\n      result[keys[j]] = true;\n    }\n  }\n\n  return result;\n}\n\nexports.getUnionOfKeys = getUnionOfKeys;\n\nfunction comparePos(pos1, pos2) {\n  return pos1.line - pos2.line || pos1.column - pos2.column;\n}\n\nexports.comparePos = comparePos;\n\nfunction copyPos(pos) {\n  return {\n    line: pos.line,\n    column: pos.column\n  };\n}\n\nexports.copyPos = copyPos;\n\nfunction composeSourceMaps(formerMap, latterMap) {\n  if (formerMap) {\n    if (!latterMap) {\n      return formerMap;\n    }\n  } else {\n    return latterMap || null;\n  }\n\n  var smcFormer = new SourceMapConsumer(formerMap);\n  var smcLatter = new SourceMapConsumer(latterMap);\n  var smg = new SourceMapGenerator({\n    file: latterMap.file,\n    sourceRoot: latterMap.sourceRoot\n  });\n  var sourcesToContents = {};\n  smcLatter.eachMapping(function (mapping) {\n    var origPos = smcFormer.originalPositionFor({\n      line: mapping.originalLine,\n      column: mapping.originalColumn\n    });\n    var sourceName = origPos.source;\n\n    if (sourceName === null) {\n      return;\n    }\n\n    smg.addMapping({\n      source: sourceName,\n      original: copyPos(origPos),\n      generated: {\n        line: mapping.generatedLine,\n        column: mapping.generatedColumn\n      },\n      name: mapping.name\n    });\n    var sourceContent = smcFormer.sourceContentFor(sourceName);\n\n    if (sourceContent && !hasOwn.call(sourcesToContents, sourceName)) {\n      sourcesToContents[sourceName] = sourceContent;\n      smg.setSourceContent(sourceName, sourceContent);\n    }\n  });\n  return smg.toJSON();\n}\n\nexports.composeSourceMaps = composeSourceMaps;\n\nfunction getTrueLoc(node, lines) {\n  // It's possible that node is newly-created (not parsed by Esprima),\n  // in which case it probably won't have a .loc property (or an\n  // .original property for that matter). That's fine; we'll just\n  // pretty-print it as usual.\n  if (!node.loc) {\n    return null;\n  }\n\n  var result = {\n    start: node.loc.start,\n    end: node.loc.end\n  };\n\n  function include(node) {\n    expandLoc(result, node.loc);\n  } // If the node is an export declaration and its .declaration has any\n  // decorators, their locations might contribute to the true start/end\n  // positions of the export declaration node.\n\n\n  if (node.declaration && node.declaration.decorators && isExportDeclaration(node)) {\n    node.declaration.decorators.forEach(include);\n  }\n\n  if (comparePos(result.start, result.end) < 0) {\n    // Trim leading whitespace.\n    result.start = copyPos(result.start);\n    lines.skipSpaces(result.start, false, true);\n\n    if (comparePos(result.start, result.end) < 0) {\n      // Trim trailing whitespace, if the end location is not already the\n      // same as the start location.\n      result.end = copyPos(result.end);\n      lines.skipSpaces(result.end, true, true);\n    }\n  } // If the node has any comments, their locations might contribute to\n  // the true start/end positions of the node.\n\n\n  if (node.comments) {\n    node.comments.forEach(include);\n  }\n\n  return result;\n}\n\nexports.getTrueLoc = getTrueLoc;\n\nfunction expandLoc(parentLoc, childLoc) {\n  if (parentLoc && childLoc) {\n    if (comparePos(childLoc.start, parentLoc.start) < 0) {\n      parentLoc.start = childLoc.start;\n    }\n\n    if (comparePos(parentLoc.end, childLoc.end) < 0) {\n      parentLoc.end = childLoc.end;\n    }\n  }\n}\n\nfunction fixFaultyLocations(node, lines) {\n  var loc = node.loc;\n\n  if (loc) {\n    if (loc.start.line < 1) {\n      loc.start.line = 1;\n    }\n\n    if (loc.end.line < 1) {\n      loc.end.line = 1;\n    }\n  }\n\n  if (node.type === \"File\") {\n    // Babylon returns File nodes whose .loc.{start,end} do not include\n    // leading or trailing whitespace.\n    loc.start = lines.firstPos();\n    loc.end = lines.lastPos();\n  }\n\n  fixForLoopHead(node, lines);\n  fixTemplateLiteral(node, lines);\n\n  if (loc && node.decorators) {\n    // Expand the .loc of the node responsible for printing the decorators\n    // (here, the decorated node) so that it includes node.decorators.\n    node.decorators.forEach(function (decorator) {\n      expandLoc(loc, decorator.loc);\n    });\n  } else if (node.declaration && isExportDeclaration(node)) {\n    // Nullify .loc information for the child declaration so that we never\n    // try to reprint it without also reprinting the export declaration.\n    node.declaration.loc = null; // Expand the .loc of the node responsible for printing the decorators\n    // (here, the export declaration) so that it includes node.decorators.\n\n    var decorators = node.declaration.decorators;\n\n    if (decorators) {\n      decorators.forEach(function (decorator) {\n        expandLoc(loc, decorator.loc);\n      });\n    }\n  } else if (n.MethodDefinition && n.MethodDefinition.check(node) || n.Property.check(node) && (node.method || node.shorthand)) {\n    // If the node is a MethodDefinition or a .method or .shorthand\n    // Property, then the location information stored in\n    // node.value.loc is very likely untrustworthy (just the {body}\n    // part of a method, or nothing in the case of shorthand\n    // properties), so we null out that information to prevent\n    // accidental reuse of bogus source code during reprinting.\n    node.value.loc = null;\n\n    if (n.FunctionExpression.check(node.value)) {\n      // FunctionExpression method values should be anonymous,\n      // because their .id fields are ignored anyway.\n      node.value.id = null;\n    }\n  } else if (node.type === \"ObjectTypeProperty\") {\n    var loc_1 = node.loc;\n    var end = loc_1 && loc_1.end;\n\n    if (end) {\n      end = copyPos(end);\n\n      if (lines.prevPos(end) && lines.charAt(end) === \",\") {\n        // Some parsers accidentally include trailing commas in the\n        // .loc.end information for ObjectTypeProperty nodes.\n        if (end = lines.skipSpaces(end, true, true)) {\n          loc_1.end = end;\n        }\n      }\n    }\n  }\n}\n\nexports.fixFaultyLocations = fixFaultyLocations;\n\nfunction fixForLoopHead(node, lines) {\n  if (node.type !== \"ForStatement\") {\n    return;\n  }\n\n  function fix(child) {\n    var loc = child && child.loc;\n    var start = loc && loc.start;\n    var end = loc && copyPos(loc.end);\n\n    while (start && end && comparePos(start, end) < 0) {\n      lines.prevPos(end);\n\n      if (lines.charAt(end) === \";\") {\n        // Update child.loc.end to *exclude* the ';' character.\n        loc.end.line = end.line;\n        loc.end.column = end.column;\n      } else {\n        break;\n      }\n    }\n  }\n\n  fix(node.init);\n  fix(node.test);\n  fix(node.update);\n}\n\nfunction fixTemplateLiteral(node, lines) {\n  if (node.type !== \"TemplateLiteral\") {\n    return;\n  }\n\n  if (node.quasis.length === 0) {\n    // If there are no quasi elements, then there is nothing to fix.\n    return;\n  } // node.loc is not present when using export default with a template literal\n\n\n  if (node.loc) {\n    // First we need to exclude the opening ` from the .loc of the first\n    // quasi element, in case the parser accidentally decided to include it.\n    var afterLeftBackTickPos = copyPos(node.loc.start);\n    assert_1.default.strictEqual(lines.charAt(afterLeftBackTickPos), \"`\");\n    assert_1.default.ok(lines.nextPos(afterLeftBackTickPos));\n    var firstQuasi = node.quasis[0];\n\n    if (comparePos(firstQuasi.loc.start, afterLeftBackTickPos) < 0) {\n      firstQuasi.loc.start = afterLeftBackTickPos;\n    } // Next we need to exclude the closing ` from the .loc of the last quasi\n    // element, in case the parser accidentally decided to include it.\n\n\n    var rightBackTickPos = copyPos(node.loc.end);\n    assert_1.default.ok(lines.prevPos(rightBackTickPos));\n    assert_1.default.strictEqual(lines.charAt(rightBackTickPos), \"`\");\n    var lastQuasi = node.quasis[node.quasis.length - 1];\n\n    if (comparePos(rightBackTickPos, lastQuasi.loc.end) < 0) {\n      lastQuasi.loc.end = rightBackTickPos;\n    }\n  } // Now we need to exclude ${ and } characters from the .loc's of all\n  // quasi elements, since some parsers accidentally include them.\n\n\n  node.expressions.forEach(function (expr, i) {\n    // Rewind from expr.loc.start over any whitespace and the ${ that\n    // precedes the expression. The position of the $ should be the same\n    // as the .loc.end of the preceding quasi element, but some parsers\n    // accidentally include the ${ in the .loc of the quasi element.\n    var dollarCurlyPos = lines.skipSpaces(expr.loc.start, true, false);\n\n    if (lines.prevPos(dollarCurlyPos) && lines.charAt(dollarCurlyPos) === \"{\" && lines.prevPos(dollarCurlyPos) && lines.charAt(dollarCurlyPos) === \"$\") {\n      var quasiBefore = node.quasis[i];\n\n      if (comparePos(dollarCurlyPos, quasiBefore.loc.end) < 0) {\n        quasiBefore.loc.end = dollarCurlyPos;\n      }\n    } // Likewise, some parsers accidentally include the } that follows\n    // the expression in the .loc of the following quasi element.\n\n\n    var rightCurlyPos = lines.skipSpaces(expr.loc.end, false, false);\n\n    if (lines.charAt(rightCurlyPos) === \"}\") {\n      assert_1.default.ok(lines.nextPos(rightCurlyPos)); // Now rightCurlyPos is technically the position just after the }.\n\n      var quasiAfter = node.quasis[i + 1];\n\n      if (comparePos(quasiAfter.loc.start, rightCurlyPos) < 0) {\n        quasiAfter.loc.start = rightCurlyPos;\n      }\n    }\n  });\n}\n\nfunction isExportDeclaration(node) {\n  if (node) switch (node.type) {\n    case \"ExportDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportDefaultSpecifier\":\n    case \"DeclareExportDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ExportAllDeclaration\":\n      return true;\n  }\n  return false;\n}\n\nexports.isExportDeclaration = isExportDeclaration;\n\nfunction getParentExportDeclaration(path) {\n  var parentNode = path.getParentNode();\n\n  if (path.getName() === \"declaration\" && isExportDeclaration(parentNode)) {\n    return parentNode;\n  }\n\n  return null;\n}\n\nexports.getParentExportDeclaration = getParentExportDeclaration;\n\nfunction isTrailingCommaEnabled(options, context) {\n  var trailingComma = options.trailingComma;\n\n  if (typeof trailingComma === \"object\") {\n    return !!trailingComma[context];\n  }\n\n  return !!trailingComma;\n}\n\nexports.isTrailingCommaEnabled = isTrailingCommaEnabled;","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/jbook/node_modules/jscodeshift/node_modules/recast/lib/util.js"],"names":["Object","defineProperty","exports","value","isTrailingCommaEnabled","getParentExportDeclaration","isExportDeclaration","fixFaultyLocations","getTrueLoc","composeSourceMaps","copyPos","comparePos","getUnionOfKeys","getOption","tslib_1","require","assert_1","__importDefault","types","__importStar","n","namedTypes","source_map_1","SourceMapConsumer","default","SourceMapGenerator","hasOwn","prototype","hasOwnProperty","options","key","defaultValue","call","args","_i","arguments","length","result","argc","i","keys","keyCount","j","pos1","pos2","line","column","pos","formerMap","latterMap","smcFormer","smcLatter","smg","file","sourceRoot","sourcesToContents","eachMapping","mapping","origPos","originalPositionFor","originalLine","originalColumn","sourceName","source","addMapping","original","generated","generatedLine","generatedColumn","name","sourceContent","sourceContentFor","setSourceContent","toJSON","node","lines","loc","start","end","include","expandLoc","declaration","decorators","forEach","skipSpaces","comments","parentLoc","childLoc","type","firstPos","lastPos","fixForLoopHead","fixTemplateLiteral","decorator","MethodDefinition","check","Property","method","shorthand","FunctionExpression","id","loc_1","prevPos","charAt","fix","child","init","test","update","quasis","afterLeftBackTickPos","strictEqual","ok","nextPos","firstQuasi","rightBackTickPos","lastQuasi","expressions","expr","dollarCurlyPos","quasiBefore","rightCurlyPos","quasiAfter","path","parentNode","getParentNode","getName","context","trailingComma"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isTrailingCommaEnabled = exports.getParentExportDeclaration = exports.isExportDeclaration = exports.fixFaultyLocations = exports.getTrueLoc = exports.composeSourceMaps = exports.copyPos = exports.comparePos = exports.getUnionOfKeys = exports.getOption = void 0;\nvar tslib_1 = require(\"tslib\");\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\nvar types = tslib_1.__importStar(require(\"ast-types\"));\nvar n = types.namedTypes;\nvar source_map_1 = tslib_1.__importDefault(require(\"source-map\"));\nvar SourceMapConsumer = source_map_1.default.SourceMapConsumer;\nvar SourceMapGenerator = source_map_1.default.SourceMapGenerator;\nvar hasOwn = Object.prototype.hasOwnProperty;\nfunction getOption(options, key, defaultValue) {\n    if (options && hasOwn.call(options, key)) {\n        return options[key];\n    }\n    return defaultValue;\n}\nexports.getOption = getOption;\nfunction getUnionOfKeys() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var result = {};\n    var argc = args.length;\n    for (var i = 0; i < argc; ++i) {\n        var keys = Object.keys(args[i]);\n        var keyCount = keys.length;\n        for (var j = 0; j < keyCount; ++j) {\n            result[keys[j]] = true;\n        }\n    }\n    return result;\n}\nexports.getUnionOfKeys = getUnionOfKeys;\nfunction comparePos(pos1, pos2) {\n    return pos1.line - pos2.line || pos1.column - pos2.column;\n}\nexports.comparePos = comparePos;\nfunction copyPos(pos) {\n    return {\n        line: pos.line,\n        column: pos.column,\n    };\n}\nexports.copyPos = copyPos;\nfunction composeSourceMaps(formerMap, latterMap) {\n    if (formerMap) {\n        if (!latterMap) {\n            return formerMap;\n        }\n    }\n    else {\n        return latterMap || null;\n    }\n    var smcFormer = new SourceMapConsumer(formerMap);\n    var smcLatter = new SourceMapConsumer(latterMap);\n    var smg = new SourceMapGenerator({\n        file: latterMap.file,\n        sourceRoot: latterMap.sourceRoot,\n    });\n    var sourcesToContents = {};\n    smcLatter.eachMapping(function (mapping) {\n        var origPos = smcFormer.originalPositionFor({\n            line: mapping.originalLine,\n            column: mapping.originalColumn,\n        });\n        var sourceName = origPos.source;\n        if (sourceName === null) {\n            return;\n        }\n        smg.addMapping({\n            source: sourceName,\n            original: copyPos(origPos),\n            generated: {\n                line: mapping.generatedLine,\n                column: mapping.generatedColumn,\n            },\n            name: mapping.name,\n        });\n        var sourceContent = smcFormer.sourceContentFor(sourceName);\n        if (sourceContent && !hasOwn.call(sourcesToContents, sourceName)) {\n            sourcesToContents[sourceName] = sourceContent;\n            smg.setSourceContent(sourceName, sourceContent);\n        }\n    });\n    return smg.toJSON();\n}\nexports.composeSourceMaps = composeSourceMaps;\nfunction getTrueLoc(node, lines) {\n    // It's possible that node is newly-created (not parsed by Esprima),\n    // in which case it probably won't have a .loc property (or an\n    // .original property for that matter). That's fine; we'll just\n    // pretty-print it as usual.\n    if (!node.loc) {\n        return null;\n    }\n    var result = {\n        start: node.loc.start,\n        end: node.loc.end,\n    };\n    function include(node) {\n        expandLoc(result, node.loc);\n    }\n    // If the node is an export declaration and its .declaration has any\n    // decorators, their locations might contribute to the true start/end\n    // positions of the export declaration node.\n    if (node.declaration &&\n        node.declaration.decorators &&\n        isExportDeclaration(node)) {\n        node.declaration.decorators.forEach(include);\n    }\n    if (comparePos(result.start, result.end) < 0) {\n        // Trim leading whitespace.\n        result.start = copyPos(result.start);\n        lines.skipSpaces(result.start, false, true);\n        if (comparePos(result.start, result.end) < 0) {\n            // Trim trailing whitespace, if the end location is not already the\n            // same as the start location.\n            result.end = copyPos(result.end);\n            lines.skipSpaces(result.end, true, true);\n        }\n    }\n    // If the node has any comments, their locations might contribute to\n    // the true start/end positions of the node.\n    if (node.comments) {\n        node.comments.forEach(include);\n    }\n    return result;\n}\nexports.getTrueLoc = getTrueLoc;\nfunction expandLoc(parentLoc, childLoc) {\n    if (parentLoc && childLoc) {\n        if (comparePos(childLoc.start, parentLoc.start) < 0) {\n            parentLoc.start = childLoc.start;\n        }\n        if (comparePos(parentLoc.end, childLoc.end) < 0) {\n            parentLoc.end = childLoc.end;\n        }\n    }\n}\nfunction fixFaultyLocations(node, lines) {\n    var loc = node.loc;\n    if (loc) {\n        if (loc.start.line < 1) {\n            loc.start.line = 1;\n        }\n        if (loc.end.line < 1) {\n            loc.end.line = 1;\n        }\n    }\n    if (node.type === \"File\") {\n        // Babylon returns File nodes whose .loc.{start,end} do not include\n        // leading or trailing whitespace.\n        loc.start = lines.firstPos();\n        loc.end = lines.lastPos();\n    }\n    fixForLoopHead(node, lines);\n    fixTemplateLiteral(node, lines);\n    if (loc && node.decorators) {\n        // Expand the .loc of the node responsible for printing the decorators\n        // (here, the decorated node) so that it includes node.decorators.\n        node.decorators.forEach(function (decorator) {\n            expandLoc(loc, decorator.loc);\n        });\n    }\n    else if (node.declaration && isExportDeclaration(node)) {\n        // Nullify .loc information for the child declaration so that we never\n        // try to reprint it without also reprinting the export declaration.\n        node.declaration.loc = null;\n        // Expand the .loc of the node responsible for printing the decorators\n        // (here, the export declaration) so that it includes node.decorators.\n        var decorators = node.declaration.decorators;\n        if (decorators) {\n            decorators.forEach(function (decorator) {\n                expandLoc(loc, decorator.loc);\n            });\n        }\n    }\n    else if ((n.MethodDefinition && n.MethodDefinition.check(node)) ||\n        (n.Property.check(node) && (node.method || node.shorthand))) {\n        // If the node is a MethodDefinition or a .method or .shorthand\n        // Property, then the location information stored in\n        // node.value.loc is very likely untrustworthy (just the {body}\n        // part of a method, or nothing in the case of shorthand\n        // properties), so we null out that information to prevent\n        // accidental reuse of bogus source code during reprinting.\n        node.value.loc = null;\n        if (n.FunctionExpression.check(node.value)) {\n            // FunctionExpression method values should be anonymous,\n            // because their .id fields are ignored anyway.\n            node.value.id = null;\n        }\n    }\n    else if (node.type === \"ObjectTypeProperty\") {\n        var loc_1 = node.loc;\n        var end = loc_1 && loc_1.end;\n        if (end) {\n            end = copyPos(end);\n            if (lines.prevPos(end) && lines.charAt(end) === \",\") {\n                // Some parsers accidentally include trailing commas in the\n                // .loc.end information for ObjectTypeProperty nodes.\n                if ((end = lines.skipSpaces(end, true, true))) {\n                    loc_1.end = end;\n                }\n            }\n        }\n    }\n}\nexports.fixFaultyLocations = fixFaultyLocations;\nfunction fixForLoopHead(node, lines) {\n    if (node.type !== \"ForStatement\") {\n        return;\n    }\n    function fix(child) {\n        var loc = child && child.loc;\n        var start = loc && loc.start;\n        var end = loc && copyPos(loc.end);\n        while (start && end && comparePos(start, end) < 0) {\n            lines.prevPos(end);\n            if (lines.charAt(end) === \";\") {\n                // Update child.loc.end to *exclude* the ';' character.\n                loc.end.line = end.line;\n                loc.end.column = end.column;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    fix(node.init);\n    fix(node.test);\n    fix(node.update);\n}\nfunction fixTemplateLiteral(node, lines) {\n    if (node.type !== \"TemplateLiteral\") {\n        return;\n    }\n    if (node.quasis.length === 0) {\n        // If there are no quasi elements, then there is nothing to fix.\n        return;\n    }\n    // node.loc is not present when using export default with a template literal\n    if (node.loc) {\n        // First we need to exclude the opening ` from the .loc of the first\n        // quasi element, in case the parser accidentally decided to include it.\n        var afterLeftBackTickPos = copyPos(node.loc.start);\n        assert_1.default.strictEqual(lines.charAt(afterLeftBackTickPos), \"`\");\n        assert_1.default.ok(lines.nextPos(afterLeftBackTickPos));\n        var firstQuasi = node.quasis[0];\n        if (comparePos(firstQuasi.loc.start, afterLeftBackTickPos) < 0) {\n            firstQuasi.loc.start = afterLeftBackTickPos;\n        }\n        // Next we need to exclude the closing ` from the .loc of the last quasi\n        // element, in case the parser accidentally decided to include it.\n        var rightBackTickPos = copyPos(node.loc.end);\n        assert_1.default.ok(lines.prevPos(rightBackTickPos));\n        assert_1.default.strictEqual(lines.charAt(rightBackTickPos), \"`\");\n        var lastQuasi = node.quasis[node.quasis.length - 1];\n        if (comparePos(rightBackTickPos, lastQuasi.loc.end) < 0) {\n            lastQuasi.loc.end = rightBackTickPos;\n        }\n    }\n    // Now we need to exclude ${ and } characters from the .loc's of all\n    // quasi elements, since some parsers accidentally include them.\n    node.expressions.forEach(function (expr, i) {\n        // Rewind from expr.loc.start over any whitespace and the ${ that\n        // precedes the expression. The position of the $ should be the same\n        // as the .loc.end of the preceding quasi element, but some parsers\n        // accidentally include the ${ in the .loc of the quasi element.\n        var dollarCurlyPos = lines.skipSpaces(expr.loc.start, true, false);\n        if (lines.prevPos(dollarCurlyPos) &&\n            lines.charAt(dollarCurlyPos) === \"{\" &&\n            lines.prevPos(dollarCurlyPos) &&\n            lines.charAt(dollarCurlyPos) === \"$\") {\n            var quasiBefore = node.quasis[i];\n            if (comparePos(dollarCurlyPos, quasiBefore.loc.end) < 0) {\n                quasiBefore.loc.end = dollarCurlyPos;\n            }\n        }\n        // Likewise, some parsers accidentally include the } that follows\n        // the expression in the .loc of the following quasi element.\n        var rightCurlyPos = lines.skipSpaces(expr.loc.end, false, false);\n        if (lines.charAt(rightCurlyPos) === \"}\") {\n            assert_1.default.ok(lines.nextPos(rightCurlyPos));\n            // Now rightCurlyPos is technically the position just after the }.\n            var quasiAfter = node.quasis[i + 1];\n            if (comparePos(quasiAfter.loc.start, rightCurlyPos) < 0) {\n                quasiAfter.loc.start = rightCurlyPos;\n            }\n        }\n    });\n}\nfunction isExportDeclaration(node) {\n    if (node)\n        switch (node.type) {\n            case \"ExportDeclaration\":\n            case \"ExportDefaultDeclaration\":\n            case \"ExportDefaultSpecifier\":\n            case \"DeclareExportDeclaration\":\n            case \"ExportNamedDeclaration\":\n            case \"ExportAllDeclaration\":\n                return true;\n        }\n    return false;\n}\nexports.isExportDeclaration = isExportDeclaration;\nfunction getParentExportDeclaration(path) {\n    var parentNode = path.getParentNode();\n    if (path.getName() === \"declaration\" && isExportDeclaration(parentNode)) {\n        return parentNode;\n    }\n    return null;\n}\nexports.getParentExportDeclaration = getParentExportDeclaration;\nfunction isTrailingCommaEnabled(options, context) {\n    var trailingComma = options.trailingComma;\n    if (typeof trailingComma === \"object\") {\n        return !!trailingComma[context];\n    }\n    return !!trailingComma;\n}\nexports.isTrailingCommaEnabled = isTrailingCommaEnabled;\n"]},"metadata":{},"sourceType":"script"}