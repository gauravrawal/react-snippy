{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nconst recast = require('recast');\n\nconst builders = recast.types.builders;\nconst types = recast.types.namedTypes;\n\nfunction splice(arr, element, replacement) {\n  arr.splice.apply(arr, [arr.indexOf(element), 1].concat(replacement));\n}\n\nfunction cleanLocation(node) {\n  delete node.start;\n  delete node.end;\n  delete node.loc;\n  return node;\n}\n\nfunction ensureStatement(node) {\n  return types.Statement.check(node) ? // Removing the location information seems to ensure that the node is\n  // correctly reprinted with a trailing semicolon\n  cleanLocation(node) : builders.expressionStatement(node);\n}\n\nfunction getVistor(varNames, nodes) {\n  return {\n    visitIdentifier: function (path) {\n      this.traverse(path);\n      const node = path.node;\n      const parent = path.parent.node; // If this identifier is not one of our generated ones, do nothing\n\n      const varIndex = varNames.indexOf(node.name);\n\n      if (varIndex === -1) {\n        return;\n      }\n\n      let replacement = nodes[varIndex];\n      nodes[varIndex] = null; // If the replacement is an array, we need to explode the nodes in context\n\n      if (Array.isArray(replacement)) {\n        if (types.Function.check(parent) && parent.params.indexOf(node) > -1) {\n          // Function parameters: function foo(${bar}) {}\n          splice(parent.params, node, replacement);\n        } else if (types.VariableDeclarator.check(parent)) {\n          // Variable declarations: var foo = ${bar}, baz = 42;\n          splice(path.parent.parent.node.declarations, parent, replacement);\n        } else if (types.ArrayExpression.check(parent)) {\n          // Arrays: var foo = [${bar}, baz];\n          splice(parent.elements, node, replacement);\n        } else if (types.Property.check(parent) && parent.shorthand) {\n          // Objects: var foo = {${bar}, baz: 42};\n          splice(path.parent.parent.node.properties, parent, replacement);\n        } else if (types.CallExpression.check(parent) && parent.arguments.indexOf(node) > -1) {\n          // Function call arguments: foo(${bar}, baz)\n          splice(parent.arguments, node, replacement);\n        } else if (types.ExpressionStatement.check(parent)) {\n          // Generic sequence of statements: { ${foo}; bar; }\n          path.parent.replace.apply(path.parent, replacement.map(ensureStatement));\n        } else {\n          // Every else, let recast take care of it\n          path.replace.apply(path, replacement);\n        }\n      } else if (types.ExpressionStatement.check(parent)) {\n        path.parent.replace(ensureStatement(replacement));\n      } else {\n        path.replace(replacement);\n      }\n    }\n  };\n}\n\nfunction replaceNodes(src, varNames, nodes, parser) {\n  const ast = recast.parse(src, {\n    parser\n  });\n  recast.visit(ast, getVistor(varNames, nodes));\n  return ast;\n}\n\nlet varNameCounter = 0;\n\nfunction getUniqueVarName() {\n  return `$jscodeshift${varNameCounter++}$`;\n}\n\nmodule.exports = function withParser(parser) {\n  function statements(template\n  /*, ...nodes*/\n  ) {\n    template = Array.from(template);\n    const nodes = Array.from(arguments).slice(1);\n    const varNames = nodes.map(() => getUniqueVarName());\n    const src = template.reduce((result, elem, i) => result + varNames[i - 1] + elem);\n    return replaceNodes(src, varNames, nodes, parser).program.body;\n  }\n\n  function statement()\n  /*template, ...nodes*/\n  {\n    return statements.apply(null, arguments)[0];\n  }\n\n  function expression(template\n  /*, ...nodes*/\n  ) {\n    // wrap code in `(...)` to force evaluation as expression\n    template = Array.from(template);\n\n    if (template.length > 0) {\n      template[0] = '(' + template[0];\n      template[template.length - 1] += ')';\n    }\n\n    const expression = statement.apply(null, [template].concat(Array.from(arguments).slice(1))).expression; // Remove added parens\n\n    if (expression.extra) {\n      expression.extra.parenthesized = false;\n    }\n\n    return expression;\n  }\n\n  return {\n    statements,\n    statement,\n    expression\n  };\n};","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/github/react-snippy/node_modules/jscodeshift/src/template.js"],"names":["recast","require","builders","types","namedTypes","splice","arr","element","replacement","apply","indexOf","concat","cleanLocation","node","start","end","loc","ensureStatement","Statement","check","expressionStatement","getVistor","varNames","nodes","visitIdentifier","path","traverse","parent","varIndex","name","Array","isArray","Function","params","VariableDeclarator","declarations","ArrayExpression","elements","Property","shorthand","properties","CallExpression","arguments","ExpressionStatement","replace","map","replaceNodes","src","parser","ast","parse","visit","varNameCounter","getUniqueVarName","module","exports","withParser","statements","template","from","slice","reduce","result","elem","i","program","body","statement","expression","length","extra","parenthesized"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AAEA,MAAMC,QAAQ,GAAGF,MAAM,CAACG,KAAP,CAAaD,QAA9B;AACA,MAAMC,KAAK,GAAGH,MAAM,CAACG,KAAP,CAAaC,UAA3B;;AAEA,SAASC,MAAT,CAAgBC,GAAhB,EAAqBC,OAArB,EAA8BC,WAA9B,EAA2C;AACzCF,EAAAA,GAAG,CAACD,MAAJ,CAAWI,KAAX,CAAiBH,GAAjB,EAAsB,CAACA,GAAG,CAACI,OAAJ,CAAYH,OAAZ,CAAD,EAAuB,CAAvB,EAA0BI,MAA1B,CAAiCH,WAAjC,CAAtB;AACD;;AAED,SAASI,aAAT,CAAuBC,IAAvB,EAA6B;AAC3B,SAAOA,IAAI,CAACC,KAAZ;AACA,SAAOD,IAAI,CAACE,GAAZ;AACA,SAAOF,IAAI,CAACG,GAAZ;AACA,SAAOH,IAAP;AACD;;AAED,SAASI,eAAT,CAAyBJ,IAAzB,EAA+B;AAC7B,SAAOV,KAAK,CAACe,SAAN,CAAgBC,KAAhB,CAAsBN,IAAtB,IACL;AACA;AACAD,EAAAA,aAAa,CAACC,IAAD,CAHR,GAILX,QAAQ,CAACkB,mBAAT,CAA6BP,IAA7B,CAJF;AAKD;;AAED,SAASQ,SAAT,CAAmBC,QAAnB,EAA6BC,KAA7B,EAAoC;AAClC,SAAO;AACLC,IAAAA,eAAe,EAAE,UAASC,IAAT,EAAe;AAC9B,WAAKC,QAAL,CAAcD,IAAd;AACA,YAAMZ,IAAI,GAAGY,IAAI,CAACZ,IAAlB;AACA,YAAMc,MAAM,GAAGF,IAAI,CAACE,MAAL,CAAYd,IAA3B,CAH8B,CAK9B;;AACA,YAAMe,QAAQ,GAAGN,QAAQ,CAACZ,OAAT,CAAiBG,IAAI,CAACgB,IAAtB,CAAjB;;AACA,UAAID,QAAQ,KAAK,CAAC,CAAlB,EAAqB;AACnB;AACD;;AAED,UAAIpB,WAAW,GAAGe,KAAK,CAACK,QAAD,CAAvB;AACAL,MAAAA,KAAK,CAACK,QAAD,CAAL,GAAkB,IAAlB,CAZ8B,CAc9B;;AACA,UAAIE,KAAK,CAACC,OAAN,CAAcvB,WAAd,CAAJ,EAAgC;AAE9B,YAAIL,KAAK,CAAC6B,QAAN,CAAeb,KAAf,CAAqBQ,MAArB,KACAA,MAAM,CAACM,MAAP,CAAcvB,OAAd,CAAsBG,IAAtB,IAA8B,CAAC,CADnC,EACsC;AACpC;AACAR,UAAAA,MAAM,CAACsB,MAAM,CAACM,MAAR,EAAgBpB,IAAhB,EAAsBL,WAAtB,CAAN;AACD,SAJD,MAIO,IAAIL,KAAK,CAAC+B,kBAAN,CAAyBf,KAAzB,CAA+BQ,MAA/B,CAAJ,EAA4C;AACjD;AACAtB,UAAAA,MAAM,CACJoB,IAAI,CAACE,MAAL,CAAYA,MAAZ,CAAmBd,IAAnB,CAAwBsB,YADpB,EAEJR,MAFI,EAGJnB,WAHI,CAAN;AAKD,SAPM,MAOA,IAAIL,KAAK,CAACiC,eAAN,CAAsBjB,KAAtB,CAA4BQ,MAA5B,CAAJ,EAAyC;AAC9C;AACAtB,UAAAA,MAAM,CAACsB,MAAM,CAACU,QAAR,EAAkBxB,IAAlB,EAAwBL,WAAxB,CAAN;AACD,SAHM,MAGA,IAAIL,KAAK,CAACmC,QAAN,CAAenB,KAAf,CAAqBQ,MAArB,KAAgCA,MAAM,CAACY,SAA3C,EAAsD;AAC3D;AACAlC,UAAAA,MAAM,CACJoB,IAAI,CAACE,MAAL,CAAYA,MAAZ,CAAmBd,IAAnB,CAAwB2B,UADpB,EAEJb,MAFI,EAGJnB,WAHI,CAAN;AAKD,SAPM,MAOA,IAAIL,KAAK,CAACsC,cAAN,CAAqBtB,KAArB,CAA2BQ,MAA3B,KACPA,MAAM,CAACe,SAAP,CAAiBhC,OAAjB,CAAyBG,IAAzB,IAAiC,CAAC,CAD/B,EACkC;AACvC;AACAR,UAAAA,MAAM,CAACsB,MAAM,CAACe,SAAR,EAAmB7B,IAAnB,EAAyBL,WAAzB,CAAN;AACD,SAJM,MAIA,IAAIL,KAAK,CAACwC,mBAAN,CAA0BxB,KAA1B,CAAgCQ,MAAhC,CAAJ,EAA6C;AAClD;AACAF,UAAAA,IAAI,CAACE,MAAL,CAAYiB,OAAZ,CAAoBnC,KAApB,CACEgB,IAAI,CAACE,MADP,EAEEnB,WAAW,CAACqC,GAAZ,CAAgB5B,eAAhB,CAFF;AAID,SANM,MAMA;AACL;AACAQ,UAAAA,IAAI,CAACmB,OAAL,CAAanC,KAAb,CAAmBgB,IAAnB,EAAyBjB,WAAzB;AACD;AACF,OArCD,MAqCO,IAAIL,KAAK,CAACwC,mBAAN,CAA0BxB,KAA1B,CAAgCQ,MAAhC,CAAJ,EAA6C;AAClDF,QAAAA,IAAI,CAACE,MAAL,CAAYiB,OAAZ,CAAoB3B,eAAe,CAACT,WAAD,CAAnC;AACD,OAFM,MAEA;AACLiB,QAAAA,IAAI,CAACmB,OAAL,CAAapC,WAAb;AACD;AACF;AA1DI,GAAP;AA4DD;;AAED,SAASsC,YAAT,CAAsBC,GAAtB,EAA2BzB,QAA3B,EAAqCC,KAArC,EAA4CyB,MAA5C,EAAoD;AAClD,QAAMC,GAAG,GAAGjD,MAAM,CAACkD,KAAP,CAAaH,GAAb,EAAkB;AAACC,IAAAA;AAAD,GAAlB,CAAZ;AACAhD,EAAAA,MAAM,CAACmD,KAAP,CAAaF,GAAb,EAAkB5B,SAAS,CAACC,QAAD,EAAWC,KAAX,CAA3B;AACA,SAAO0B,GAAP;AACD;;AAED,IAAIG,cAAc,GAAG,CAArB;;AACA,SAASC,gBAAT,GAA4B;AAC1B,SAAQ,eAAcD,cAAc,EAAG,GAAvC;AACD;;AAGDE,MAAM,CAACC,OAAP,GAAiB,SAASC,UAAT,CAAoBR,MAApB,EAA4B;AAC3C,WAASS,UAAT,CAAoBC;AAAQ;AAA5B,IAA4C;AAC1CA,IAAAA,QAAQ,GAAG5B,KAAK,CAAC6B,IAAN,CAAWD,QAAX,CAAX;AACA,UAAMnC,KAAK,GAAGO,KAAK,CAAC6B,IAAN,CAAWjB,SAAX,EAAsBkB,KAAtB,CAA4B,CAA5B,CAAd;AACA,UAAMtC,QAAQ,GAAGC,KAAK,CAACsB,GAAN,CAAU,MAAMQ,gBAAgB,EAAhC,CAAjB;AACA,UAAMN,GAAG,GAAGW,QAAQ,CAACG,MAAT,CACV,CAACC,MAAD,EAASC,IAAT,EAAeC,CAAf,KAAqBF,MAAM,GAAGxC,QAAQ,CAAC0C,CAAC,GAAG,CAAL,CAAjB,GAA2BD,IADtC,CAAZ;AAIA,WAAOjB,YAAY,CACjBC,GADiB,EAEjBzB,QAFiB,EAGjBC,KAHiB,EAIjByB,MAJiB,CAAZ,CAKLiB,OALK,CAKGC,IALV;AAMD;;AAED,WAASC,SAAT;AAAmB;AAAwB;AACzC,WAAOV,UAAU,CAAChD,KAAX,CAAiB,IAAjB,EAAuBiC,SAAvB,EAAkC,CAAlC,CAAP;AACD;;AAED,WAAS0B,UAAT,CAAoBV;AAAQ;AAA5B,IAA4C;AAC1C;AACAA,IAAAA,QAAQ,GAAG5B,KAAK,CAAC6B,IAAN,CAAWD,QAAX,CAAX;;AACA,QAAIA,QAAQ,CAACW,MAAT,GAAkB,CAAtB,EAAyB;AACvBX,MAAAA,QAAQ,CAAC,CAAD,CAAR,GAAc,MAAMA,QAAQ,CAAC,CAAD,CAA5B;AACAA,MAAAA,QAAQ,CAACA,QAAQ,CAACW,MAAT,GAAkB,CAAnB,CAAR,IAAiC,GAAjC;AACD;;AAED,UAAMD,UAAU,GAAGD,SAAS,CAAC1D,KAAV,CACjB,IADiB,EAEjB,CAACiD,QAAD,EAAW/C,MAAX,CAAkBmB,KAAK,CAAC6B,IAAN,CAAWjB,SAAX,EAAsBkB,KAAtB,CAA4B,CAA5B,CAAlB,CAFiB,EAGjBQ,UAHF,CAR0C,CAa1C;;AACA,QAAIA,UAAU,CAACE,KAAf,EAAsB;AACpBF,MAAAA,UAAU,CAACE,KAAX,CAAiBC,aAAjB,GAAiC,KAAjC;AACD;;AAED,WAAOH,UAAP;AACD;;AAED,SAAO;AAACX,IAAAA,UAAD;AAAaU,IAAAA,SAAb;AAAwBC,IAAAA;AAAxB,GAAP;AACD,CA3CD","sourcesContent":["\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst recast = require('recast');\n\nconst builders = recast.types.builders;\nconst types = recast.types.namedTypes;\n\nfunction splice(arr, element, replacement) {\n  arr.splice.apply(arr, [arr.indexOf(element), 1].concat(replacement));\n}\n\nfunction cleanLocation(node) {\n  delete node.start;\n  delete node.end;\n  delete node.loc;\n  return node;\n}\n\nfunction ensureStatement(node) {\n  return types.Statement.check(node) ?\n    // Removing the location information seems to ensure that the node is\n    // correctly reprinted with a trailing semicolon\n    cleanLocation(node) :\n    builders.expressionStatement(node);\n}\n\nfunction getVistor(varNames, nodes) {\n  return {\n    visitIdentifier: function(path) {\n      this.traverse(path);\n      const node = path.node;\n      const parent = path.parent.node;\n\n      // If this identifier is not one of our generated ones, do nothing\n      const varIndex = varNames.indexOf(node.name);\n      if (varIndex === -1) {\n        return;\n      }\n\n      let replacement = nodes[varIndex];\n      nodes[varIndex] = null;\n\n      // If the replacement is an array, we need to explode the nodes in context\n      if (Array.isArray(replacement)) {\n\n        if (types.Function.check(parent) &&\n            parent.params.indexOf(node) > -1) {\n          // Function parameters: function foo(${bar}) {}\n          splice(parent.params, node, replacement);\n        } else if (types.VariableDeclarator.check(parent)) {\n          // Variable declarations: var foo = ${bar}, baz = 42;\n          splice(\n            path.parent.parent.node.declarations,\n            parent,\n            replacement\n          );\n        } else if (types.ArrayExpression.check(parent)) {\n          // Arrays: var foo = [${bar}, baz];\n          splice(parent.elements, node, replacement);\n        } else if (types.Property.check(parent) && parent.shorthand) {\n          // Objects: var foo = {${bar}, baz: 42};\n          splice(\n            path.parent.parent.node.properties,\n            parent,\n            replacement\n          );\n        } else if (types.CallExpression.check(parent) &&\n            parent.arguments.indexOf(node) > -1) {\n          // Function call arguments: foo(${bar}, baz)\n          splice(parent.arguments, node, replacement);\n        } else if (types.ExpressionStatement.check(parent)) {\n          // Generic sequence of statements: { ${foo}; bar; }\n          path.parent.replace.apply(\n            path.parent,\n            replacement.map(ensureStatement)\n          );\n        } else {\n          // Every else, let recast take care of it\n          path.replace.apply(path, replacement);\n        }\n      } else if (types.ExpressionStatement.check(parent)) {\n        path.parent.replace(ensureStatement(replacement));\n      } else {\n        path.replace(replacement);\n      }\n    }\n  };\n}\n\nfunction replaceNodes(src, varNames, nodes, parser) {\n  const ast = recast.parse(src, {parser});\n  recast.visit(ast, getVistor(varNames, nodes));\n  return ast;\n}\n\nlet varNameCounter = 0;\nfunction getUniqueVarName() {\n  return `$jscodeshift${varNameCounter++}$`;\n}\n\n\nmodule.exports = function withParser(parser) {\n  function statements(template/*, ...nodes*/) {\n    template = Array.from(template);\n    const nodes = Array.from(arguments).slice(1);\n    const varNames = nodes.map(() => getUniqueVarName());\n    const src = template.reduce(\n      (result, elem, i) => result + varNames[i - 1] + elem\n    );\n\n    return replaceNodes(\n      src,\n      varNames,\n      nodes,\n      parser\n    ).program.body;\n  }\n\n  function statement(/*template, ...nodes*/) {\n    return statements.apply(null, arguments)[0];\n  }\n\n  function expression(template/*, ...nodes*/) {\n    // wrap code in `(...)` to force evaluation as expression\n    template = Array.from(template);\n    if (template.length > 0) {\n      template[0] = '(' + template[0];\n      template[template.length - 1] += ')';\n    }\n\n    const expression = statement.apply(\n      null,\n      [template].concat(Array.from(arguments).slice(1))\n    ).expression;\n\n    // Remove added parens\n    if (expression.extra) {\n      expression.extra.parenthesized = false;\n    }\n\n    return expression;\n  }\n\n  return {statements, statement, expression};\n}\n"]},"metadata":{},"sourceType":"script"}