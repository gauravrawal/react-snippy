{"ast":null,"code":"\"use strict\";\n\n;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\n\nfunction default_1(fork) {\n  var types = fork.use(types_1.default);\n  var getFieldNames = types.getFieldNames;\n  var getFieldValue = types.getFieldValue;\n  var isArray = types.builtInTypes.array;\n  var isObject = types.builtInTypes.object;\n  var isDate = types.builtInTypes.Date;\n  var isRegExp = types.builtInTypes.RegExp;\n  var hasOwn = Object.prototype.hasOwnProperty;\n\n  function astNodesAreEquivalent(a, b, problemPath) {\n    if (isArray.check(problemPath)) {\n      problemPath.length = 0;\n    } else {\n      problemPath = null;\n    }\n\n    return areEquivalent(a, b, problemPath);\n  }\n\n  astNodesAreEquivalent.assert = function (a, b) {\n    var problemPath = [];\n\n    if (!astNodesAreEquivalent(a, b, problemPath)) {\n      if (problemPath.length === 0) {\n        if (a !== b) {\n          throw new Error(\"Nodes must be equal\");\n        }\n      } else {\n        throw new Error(\"Nodes differ in the following path: \" + problemPath.map(subscriptForProperty).join(\"\"));\n      }\n    }\n  };\n\n  function subscriptForProperty(property) {\n    if (/[_$a-z][_$a-z0-9]*/i.test(property)) {\n      return \".\" + property;\n    }\n\n    return \"[\" + JSON.stringify(property) + \"]\";\n  }\n\n  function areEquivalent(a, b, problemPath) {\n    if (a === b) {\n      return true;\n    }\n\n    if (isArray.check(a)) {\n      return arraysAreEquivalent(a, b, problemPath);\n    }\n\n    if (isObject.check(a)) {\n      return objectsAreEquivalent(a, b, problemPath);\n    }\n\n    if (isDate.check(a)) {\n      return isDate.check(b) && +a === +b;\n    }\n\n    if (isRegExp.check(a)) {\n      return isRegExp.check(b) && a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.ignoreCase === b.ignoreCase;\n    }\n\n    return a == b;\n  }\n\n  function arraysAreEquivalent(a, b, problemPath) {\n    isArray.assert(a);\n    var aLength = a.length;\n\n    if (!isArray.check(b) || b.length !== aLength) {\n      if (problemPath) {\n        problemPath.push(\"length\");\n      }\n\n      return false;\n    }\n\n    for (var i = 0; i < aLength; ++i) {\n      if (problemPath) {\n        problemPath.push(i);\n      }\n\n      if (i in a !== i in b) {\n        return false;\n      }\n\n      if (!areEquivalent(a[i], b[i], problemPath)) {\n        return false;\n      }\n\n      if (problemPath) {\n        var problemPathTail = problemPath.pop();\n\n        if (problemPathTail !== i) {\n          throw new Error(\"\" + problemPathTail);\n        }\n      }\n    }\n\n    return true;\n  }\n\n  function objectsAreEquivalent(a, b, problemPath) {\n    isObject.assert(a);\n\n    if (!isObject.check(b)) {\n      return false;\n    } // Fast path for a common property of AST nodes.\n\n\n    if (a.type !== b.type) {\n      if (problemPath) {\n        problemPath.push(\"type\");\n      }\n\n      return false;\n    }\n\n    var aNames = getFieldNames(a);\n    var aNameCount = aNames.length;\n    var bNames = getFieldNames(b);\n    var bNameCount = bNames.length;\n\n    if (aNameCount === bNameCount) {\n      for (var i = 0; i < aNameCount; ++i) {\n        var name = aNames[i];\n        var aChild = getFieldValue(a, name);\n        var bChild = getFieldValue(b, name);\n\n        if (problemPath) {\n          problemPath.push(name);\n        }\n\n        if (!areEquivalent(aChild, bChild, problemPath)) {\n          return false;\n        }\n\n        if (problemPath) {\n          var problemPathTail = problemPath.pop();\n\n          if (problemPathTail !== name) {\n            throw new Error(\"\" + problemPathTail);\n          }\n        }\n      }\n\n      return true;\n    }\n\n    if (!problemPath) {\n      return false;\n    } // Since aNameCount !== bNameCount, we need to find some name that's\n    // missing in aNames but present in bNames, or vice-versa.\n\n\n    var seenNames = Object.create(null);\n\n    for (i = 0; i < aNameCount; ++i) {\n      seenNames[aNames[i]] = true;\n    }\n\n    for (i = 0; i < bNameCount; ++i) {\n      name = bNames[i];\n\n      if (!hasOwn.call(seenNames, name)) {\n        problemPath.push(name);\n        return false;\n      }\n\n      delete seenNames[name];\n    }\n\n    for (name in seenNames) {\n      problemPath.push(name);\n      break;\n    }\n\n    return false;\n  }\n\n  return astNodesAreEquivalent;\n}\n\nexports.default = default_1;\nmodule.exports = exports[\"default\"];","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/github/react-snippy/node_modules/jscodeshift/node_modules/ast-types/lib/equiv.js"],"names":["Object","defineProperty","exports","value","tslib_1","require","types_1","__importDefault","default_1","fork","types","use","default","getFieldNames","getFieldValue","isArray","builtInTypes","array","isObject","object","isDate","Date","isRegExp","RegExp","hasOwn","prototype","hasOwnProperty","astNodesAreEquivalent","a","b","problemPath","check","length","areEquivalent","assert","Error","map","subscriptForProperty","join","property","test","JSON","stringify","arraysAreEquivalent","objectsAreEquivalent","source","global","multiline","ignoreCase","aLength","push","i","problemPathTail","pop","type","aNames","aNameCount","bNames","bNameCount","name","aChild","bChild","seenNames","create","call","module"],"mappings":"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","sourcesContent":["\"use strict\";;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\nfunction default_1(fork) {\n    var types = fork.use(types_1.default);\n    var getFieldNames = types.getFieldNames;\n    var getFieldValue = types.getFieldValue;\n    var isArray = types.builtInTypes.array;\n    var isObject = types.builtInTypes.object;\n    var isDate = types.builtInTypes.Date;\n    var isRegExp = types.builtInTypes.RegExp;\n    var hasOwn = Object.prototype.hasOwnProperty;\n    function astNodesAreEquivalent(a, b, problemPath) {\n        if (isArray.check(problemPath)) {\n            problemPath.length = 0;\n        }\n        else {\n            problemPath = null;\n        }\n        return areEquivalent(a, b, problemPath);\n    }\n    astNodesAreEquivalent.assert = function (a, b) {\n        var problemPath = [];\n        if (!astNodesAreEquivalent(a, b, problemPath)) {\n            if (problemPath.length === 0) {\n                if (a !== b) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n            }\n            else {\n                throw new Error(\"Nodes differ in the following path: \" +\n                    problemPath.map(subscriptForProperty).join(\"\"));\n            }\n        }\n    };\n    function subscriptForProperty(property) {\n        if (/[_$a-z][_$a-z0-9]*/i.test(property)) {\n            return \".\" + property;\n        }\n        return \"[\" + JSON.stringify(property) + \"]\";\n    }\n    function areEquivalent(a, b, problemPath) {\n        if (a === b) {\n            return true;\n        }\n        if (isArray.check(a)) {\n            return arraysAreEquivalent(a, b, problemPath);\n        }\n        if (isObject.check(a)) {\n            return objectsAreEquivalent(a, b, problemPath);\n        }\n        if (isDate.check(a)) {\n            return isDate.check(b) && (+a === +b);\n        }\n        if (isRegExp.check(a)) {\n            return isRegExp.check(b) && (a.source === b.source &&\n                a.global === b.global &&\n                a.multiline === b.multiline &&\n                a.ignoreCase === b.ignoreCase);\n        }\n        return a == b;\n    }\n    function arraysAreEquivalent(a, b, problemPath) {\n        isArray.assert(a);\n        var aLength = a.length;\n        if (!isArray.check(b) || b.length !== aLength) {\n            if (problemPath) {\n                problemPath.push(\"length\");\n            }\n            return false;\n        }\n        for (var i = 0; i < aLength; ++i) {\n            if (problemPath) {\n                problemPath.push(i);\n            }\n            if (i in a !== i in b) {\n                return false;\n            }\n            if (!areEquivalent(a[i], b[i], problemPath)) {\n                return false;\n            }\n            if (problemPath) {\n                var problemPathTail = problemPath.pop();\n                if (problemPathTail !== i) {\n                    throw new Error(\"\" + problemPathTail);\n                }\n            }\n        }\n        return true;\n    }\n    function objectsAreEquivalent(a, b, problemPath) {\n        isObject.assert(a);\n        if (!isObject.check(b)) {\n            return false;\n        }\n        // Fast path for a common property of AST nodes.\n        if (a.type !== b.type) {\n            if (problemPath) {\n                problemPath.push(\"type\");\n            }\n            return false;\n        }\n        var aNames = getFieldNames(a);\n        var aNameCount = aNames.length;\n        var bNames = getFieldNames(b);\n        var bNameCount = bNames.length;\n        if (aNameCount === bNameCount) {\n            for (var i = 0; i < aNameCount; ++i) {\n                var name = aNames[i];\n                var aChild = getFieldValue(a, name);\n                var bChild = getFieldValue(b, name);\n                if (problemPath) {\n                    problemPath.push(name);\n                }\n                if (!areEquivalent(aChild, bChild, problemPath)) {\n                    return false;\n                }\n                if (problemPath) {\n                    var problemPathTail = problemPath.pop();\n                    if (problemPathTail !== name) {\n                        throw new Error(\"\" + problemPathTail);\n                    }\n                }\n            }\n            return true;\n        }\n        if (!problemPath) {\n            return false;\n        }\n        // Since aNameCount !== bNameCount, we need to find some name that's\n        // missing in aNames but present in bNames, or vice-versa.\n        var seenNames = Object.create(null);\n        for (i = 0; i < aNameCount; ++i) {\n            seenNames[aNames[i]] = true;\n        }\n        for (i = 0; i < bNameCount; ++i) {\n            name = bNames[i];\n            if (!hasOwn.call(seenNames, name)) {\n                problemPath.push(name);\n                return false;\n            }\n            delete seenNames[name];\n        }\n        for (name in seenNames) {\n            problemPath.push(name);\n            break;\n        }\n        return false;\n    }\n    return astNodesAreEquivalent;\n}\nexports.default = default_1;\nmodule.exports = exports[\"default\"];\n"]},"metadata":{},"sourceType":"script"}