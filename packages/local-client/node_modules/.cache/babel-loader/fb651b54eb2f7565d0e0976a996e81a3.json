{"ast":null,"code":"(function (Prism) {\n  var expressionDef = /\\{[^\\r\\n\\[\\]{}]*\\}/;\n  var params = {\n    'quoted-string': {\n      pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n      alias: 'operator'\n    },\n    'command-param-id': {\n      pattern: /(\\s)\\w+:/,\n      lookbehind: true,\n      alias: 'property'\n    },\n    'command-param-value': [{\n      pattern: expressionDef,\n      alias: 'selector'\n    }, {\n      pattern: /([\\t ])\\S+/,\n      lookbehind: true,\n      greedy: true,\n      alias: 'operator'\n    }, {\n      pattern: /\\S(?:.*\\S)?/,\n      alias: 'operator'\n    }]\n  };\n  Prism.languages.naniscript = {\n    // ; ...\n    'comment': {\n      pattern: /^([\\t ]*);.*/m,\n      lookbehind: true\n    },\n    // > ...\n    // Define is a control line starting with '>' followed by a word, a space and a text.\n    'define': {\n      pattern: /^>.+/m,\n      alias: 'tag',\n      inside: {\n        'value': {\n          pattern: /(^>\\w+[\\t ]+)(?!\\s)[^{}\\r\\n]+/,\n          lookbehind: true,\n          alias: 'operator'\n        },\n        'key': {\n          pattern: /(^>)\\w+/,\n          lookbehind: true\n        }\n      }\n    },\n    // # ...\n    'label': {\n      pattern: /^([\\t ]*)#[\\t ]*\\w+[\\t ]*$/m,\n      lookbehind: true,\n      alias: 'regex'\n    },\n    'command': {\n      pattern: /^([\\t ]*)@\\w+(?=[\\t ]|$).*/m,\n      lookbehind: true,\n      alias: 'function',\n      inside: {\n        'command-name': /^@\\w+/,\n        'expression': {\n          pattern: expressionDef,\n          greedy: true,\n          alias: 'selector'\n        },\n        'command-params': {\n          pattern: /\\s*\\S[\\s\\S]*/,\n          inside: params\n        }\n      }\n    },\n    // Generic is any line that doesn't start with operators: ;>#@\n    'generic-text': {\n      pattern: /(^[ \\t]*)[^#@>;\\s].*/m,\n      lookbehind: true,\n      alias: 'punctuation',\n      inside: {\n        // \\{ ... \\} ... \\[ ... \\] ... \\\"\n        'escaped-char': /\\\\[{}\\[\\]\"]/,\n        'expression': {\n          pattern: expressionDef,\n          greedy: true,\n          alias: 'selector'\n        },\n        'inline-command': {\n          pattern: /\\[[\\t ]*\\w[^\\r\\n\\[\\]]*\\]/,\n          greedy: true,\n          alias: 'function',\n          inside: {\n            'command-params': {\n              pattern: /(^\\[[\\t ]*\\w+\\b)[\\s\\S]+(?=\\]$)/,\n              lookbehind: true,\n              inside: params\n            },\n            'command-param-name': {\n              pattern: /^(\\[[\\t ]*)\\w+/,\n              lookbehind: true,\n              alias: 'name'\n            },\n            'start-stop-char': /[\\[\\]]/\n          }\n        }\n      }\n    }\n  };\n  Prism.languages.nani = Prism.languages['naniscript'];\n  /** @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token */\n\n  /**\n   * This hook is used to validate generic-text tokens for balanced brackets.\n   * Mark token as bad-line when contains not balanced brackets: {},[]\n   */\n\n  Prism.hooks.add('after-tokenize', function (env) {\n    /** @type {(Token | string)[]} */\n    var tokens = env.tokens;\n    tokens.forEach(function (token) {\n      if (typeof token !== 'string' && token.type === 'generic-text') {\n        var content = getTextContent(token);\n\n        if (!isBracketsBalanced(content)) {\n          token.type = 'bad-line';\n          token.content = content;\n        }\n      }\n    });\n  });\n  /**\n   * @param {string} input\n   * @returns {boolean}\n   */\n\n  function isBracketsBalanced(input) {\n    var brackets = '[]{}';\n    var stack = [];\n\n    for (var i = 0; i < input.length; i++) {\n      var bracket = input[i];\n      var bracketsIndex = brackets.indexOf(bracket);\n\n      if (bracketsIndex !== -1) {\n        if (bracketsIndex % 2 === 0) {\n          stack.push(bracketsIndex + 1);\n        } else if (stack.pop() !== bracketsIndex) {\n          return false;\n        }\n      }\n    }\n\n    return stack.length === 0;\n  }\n  /**\n   * @param {string | Token | (string | Token)[]} token\n   * @returns {string}\n   */\n\n\n  function getTextContent(token) {\n    if (typeof token === 'string') {\n      return token;\n    } else if (Array.isArray(token)) {\n      return token.map(getTextContent).join('');\n    } else {\n      return getTextContent(token.content);\n    }\n  }\n})(Prism);","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/jbook/node_modules/prismjs/components/prism-naniscript.js"],"names":["Prism","expressionDef","params","pattern","alias","lookbehind","greedy","languages","naniscript","inside","nani","hooks","add","env","tokens","forEach","token","type","content","getTextContent","isBracketsBalanced","input","brackets","stack","i","length","bracket","bracketsIndex","indexOf","push","pop","Array","isArray","map","join"],"mappings":"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","sourcesContent":["(function (Prism) {\n\n\tvar expressionDef = /\\{[^\\r\\n\\[\\]{}]*\\}/;\n\n\tvar params = {\n\t\t'quoted-string': {\n\t\t\tpattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n\t\t\talias: 'operator'\n\t\t},\n\t\t'command-param-id': {\n\t\t\tpattern: /(\\s)\\w+:/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'property'\n\t\t},\n\t\t'command-param-value': [\n\t\t\t{\n\t\t\t\tpattern: expressionDef,\n\t\t\t\talias: 'selector',\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /([\\t ])\\S+/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\talias: 'operator',\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /\\S(?:.*\\S)?/,\n\t\t\t\talias: 'operator',\n\t\t\t}\n\t\t]\n\t};\n\n\tPrism.languages.naniscript = {\n\t\t// ; ...\n\t\t'comment': {\n\t\t\tpattern: /^([\\t ]*);.*/m,\n\t\t\tlookbehind: true,\n\t\t},\n\t\t// > ...\n\t\t// Define is a control line starting with '>' followed by a word, a space and a text.\n\t\t'define': {\n\t\t\tpattern: /^>.+/m,\n\t\t\talias: 'tag',\n\t\t\tinside: {\n\t\t\t\t'value': {\n\t\t\t\t\tpattern: /(^>\\w+[\\t ]+)(?!\\s)[^{}\\r\\n]+/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'operator'\n\t\t\t\t},\n\t\t\t\t'key': {\n\t\t\t\t\tpattern: /(^>)\\w+/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// # ...\n\t\t'label': {\n\t\t\tpattern: /^([\\t ]*)#[\\t ]*\\w+[\\t ]*$/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'regex'\n\t\t},\n\t\t'command': {\n\t\t\tpattern: /^([\\t ]*)@\\w+(?=[\\t ]|$).*/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'function',\n\t\t\tinside: {\n\t\t\t\t'command-name': /^@\\w+/,\n\t\t\t\t'expression': {\n\t\t\t\t\tpattern: expressionDef,\n\t\t\t\t\tgreedy: true,\n\t\t\t\t\talias: 'selector'\n\t\t\t\t},\n\t\t\t\t'command-params': {\n\t\t\t\t\tpattern: /\\s*\\S[\\s\\S]*/,\n\t\t\t\t\tinside: params\n\t\t\t\t},\n\t\t\t}\n\t\t},\n\t\t// Generic is any line that doesn't start with operators: ;>#@\n\t\t'generic-text': {\n\t\t\tpattern: /(^[ \\t]*)[^#@>;\\s].*/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'punctuation',\n\t\t\tinside: {\n\t\t\t\t// \\{ ... \\} ... \\[ ... \\] ... \\\"\n\t\t\t\t'escaped-char': /\\\\[{}\\[\\]\"]/,\n\t\t\t\t'expression': {\n\t\t\t\t\tpattern: expressionDef,\n\t\t\t\t\tgreedy: true,\n\t\t\t\t\talias: 'selector'\n\t\t\t\t},\n\t\t\t\t'inline-command': {\n\t\t\t\t\tpattern: /\\[[\\t ]*\\w[^\\r\\n\\[\\]]*\\]/,\n\t\t\t\t\tgreedy: true,\n\t\t\t\t\talias: 'function',\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'command-params': {\n\t\t\t\t\t\t\tpattern: /(^\\[[\\t ]*\\w+\\b)[\\s\\S]+(?=\\]$)/,\n\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\tinside: params\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'command-param-name': {\n\t\t\t\t\t\t\tpattern: /^(\\[[\\t ]*)\\w+/,\n\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\talias: 'name',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'start-stop-char': /[\\[\\]]/,\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t};\n\tPrism.languages.nani = Prism.languages['naniscript'];\n\n\t/** @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token */\n\n\t/**\n\t * This hook is used to validate generic-text tokens for balanced brackets.\n\t * Mark token as bad-line when contains not balanced brackets: {},[]\n\t */\n\tPrism.hooks.add('after-tokenize', function (env) {\n\t\t/** @type {(Token | string)[]} */\n\t\tvar tokens = env.tokens;\n\t\ttokens.forEach(function (token) {\n\t\t\tif (typeof token !== 'string' && token.type === 'generic-text') {\n\t\t\t\tvar content = getTextContent(token);\n\t\t\t\tif (!isBracketsBalanced(content)) {\n\t\t\t\t\ttoken.type = 'bad-line';\n\t\t\t\t\ttoken.content = content;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n\n\t/**\n\t * @param {string} input\n\t * @returns {boolean}\n\t */\n\tfunction isBracketsBalanced(input) {\n\t\tvar brackets = '[]{}';\n\t\tvar stack = [];\n\t\tfor (var i = 0; i < input.length; i++) {\n\t\t\tvar bracket = input[i];\n\t\t\tvar bracketsIndex = brackets.indexOf(bracket);\n\t\t\tif (bracketsIndex !== -1) {\n\t\t\t\tif (bracketsIndex % 2 === 0) {\n\t\t\t\t\tstack.push(bracketsIndex + 1);\n\t\t\t\t} else if (stack.pop() !== bracketsIndex) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn stack.length === 0;\n\t}\n\n\t/**\n\t * @param {string | Token | (string | Token)[]} token\n\t * @returns {string}\n\t */\n\tfunction getTextContent(token) {\n\t\tif (typeof token === 'string') {\n\t\t\treturn token;\n\t\t} else if (Array.isArray(token)) {\n\t\t\treturn token.map(getTextContent).join('');\n\t\t} else {\n\t\t\treturn getTextContent(token.content);\n\t\t}\n\t}\n\n}(Prism));\n"]},"metadata":{},"sourceType":"script"}