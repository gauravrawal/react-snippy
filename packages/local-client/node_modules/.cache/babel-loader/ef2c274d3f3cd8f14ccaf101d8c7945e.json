{"ast":null,"code":"'use strict';\n\nvar repeat = require('repeat-string');\n\nmodule.exports = markdownTable;\nvar trailingWhitespace = / +$/; // Characters.\n\nvar space = ' ';\nvar lineFeed = '\\n';\nvar dash = '-';\nvar colon = ':';\nvar verticalBar = '|';\nvar x = 0;\nvar C = 67;\nvar L = 76;\nvar R = 82;\nvar c = 99;\nvar l = 108;\nvar r = 114; // Create a table from a matrix of strings.\n\nfunction markdownTable(table, options) {\n  var settings = options || {};\n  var padding = settings.padding !== false;\n  var start = settings.delimiterStart !== false;\n  var end = settings.delimiterEnd !== false;\n  var align = (settings.align || []).concat();\n  var alignDelimiters = settings.alignDelimiters !== false;\n  var alignments = [];\n  var stringLength = settings.stringLength || defaultStringLength;\n  var rowIndex = -1;\n  var rowLength = table.length;\n  var cellMatrix = [];\n  var sizeMatrix = [];\n  var row = [];\n  var sizes = [];\n  var longestCellByColumn = [];\n  var mostCellsPerRow = 0;\n  var cells;\n  var columnIndex;\n  var columnLength;\n  var largest;\n  var size;\n  var cell;\n  var lines;\n  var line;\n  var before;\n  var after;\n  var code; // This is a superfluous loop if we don’t align delimiters, but otherwise we’d\n  // do superfluous work when aligning, so optimize for aligning.\n\n  while (++rowIndex < rowLength) {\n    cells = table[rowIndex];\n    columnIndex = -1;\n    columnLength = cells.length;\n    row = [];\n    sizes = [];\n\n    if (columnLength > mostCellsPerRow) {\n      mostCellsPerRow = columnLength;\n    }\n\n    while (++columnIndex < columnLength) {\n      cell = serialize(cells[columnIndex]);\n\n      if (alignDelimiters === true) {\n        size = stringLength(cell);\n        sizes[columnIndex] = size;\n        largest = longestCellByColumn[columnIndex];\n\n        if (largest === undefined || size > largest) {\n          longestCellByColumn[columnIndex] = size;\n        }\n      }\n\n      row.push(cell);\n    }\n\n    cellMatrix[rowIndex] = row;\n    sizeMatrix[rowIndex] = sizes;\n  } // Figure out which alignments to use.\n\n\n  columnIndex = -1;\n  columnLength = mostCellsPerRow;\n\n  if (typeof align === 'object' && 'length' in align) {\n    while (++columnIndex < columnLength) {\n      alignments[columnIndex] = toAlignment(align[columnIndex]);\n    }\n  } else {\n    code = toAlignment(align);\n\n    while (++columnIndex < columnLength) {\n      alignments[columnIndex] = code;\n    }\n  } // Inject the alignment row.\n\n\n  columnIndex = -1;\n  columnLength = mostCellsPerRow;\n  row = [];\n  sizes = [];\n\n  while (++columnIndex < columnLength) {\n    code = alignments[columnIndex];\n    before = '';\n    after = '';\n\n    if (code === l) {\n      before = colon;\n    } else if (code === r) {\n      after = colon;\n    } else if (code === c) {\n      before = colon;\n      after = colon;\n    } // There *must* be at least one hyphen-minus in each alignment cell.\n\n\n    size = alignDelimiters ? Math.max(1, longestCellByColumn[columnIndex] - before.length - after.length) : 1;\n    cell = before + repeat(dash, size) + after;\n\n    if (alignDelimiters === true) {\n      size = before.length + size + after.length;\n\n      if (size > longestCellByColumn[columnIndex]) {\n        longestCellByColumn[columnIndex] = size;\n      }\n\n      sizes[columnIndex] = size;\n    }\n\n    row[columnIndex] = cell;\n  } // Inject the alignment row.\n\n\n  cellMatrix.splice(1, 0, row);\n  sizeMatrix.splice(1, 0, sizes);\n  rowIndex = -1;\n  rowLength = cellMatrix.length;\n  lines = [];\n\n  while (++rowIndex < rowLength) {\n    row = cellMatrix[rowIndex];\n    sizes = sizeMatrix[rowIndex];\n    columnIndex = -1;\n    columnLength = mostCellsPerRow;\n    line = [];\n\n    while (++columnIndex < columnLength) {\n      cell = row[columnIndex] || '';\n      before = '';\n      after = '';\n\n      if (alignDelimiters === true) {\n        size = longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0);\n        code = alignments[columnIndex];\n\n        if (code === r) {\n          before = repeat(space, size);\n        } else if (code === c) {\n          if (size % 2 === 0) {\n            before = repeat(space, size / 2);\n            after = before;\n          } else {\n            before = repeat(space, size / 2 + 0.5);\n            after = repeat(space, size / 2 - 0.5);\n          }\n        } else {\n          after = repeat(space, size);\n        }\n      }\n\n      if (start === true && columnIndex === 0) {\n        line.push(verticalBar);\n      }\n\n      if (padding === true && // Don’t add the opening space if we’re not aligning and the cell is\n      // empty: there will be a closing space.\n      !(alignDelimiters === false && cell === '') && (start === true || columnIndex !== 0)) {\n        line.push(space);\n      }\n\n      if (alignDelimiters === true) {\n        line.push(before);\n      }\n\n      line.push(cell);\n\n      if (alignDelimiters === true) {\n        line.push(after);\n      }\n\n      if (padding === true) {\n        line.push(space);\n      }\n\n      if (end === true || columnIndex !== columnLength - 1) {\n        line.push(verticalBar);\n      }\n    }\n\n    line = line.join('');\n\n    if (end === false) {\n      line = line.replace(trailingWhitespace, '');\n    }\n\n    lines.push(line);\n  }\n\n  return lines.join(lineFeed);\n}\n\nfunction serialize(value) {\n  return value === null || value === undefined ? '' : String(value);\n}\n\nfunction defaultStringLength(value) {\n  return value.length;\n}\n\nfunction toAlignment(value) {\n  var code = typeof value === 'string' ? value.charCodeAt(0) : x;\n  return code === L || code === l ? l : code === R || code === r ? r : code === C || code === c ? c : x;\n}","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/jbook/node_modules/markdown-table/index.js"],"names":["repeat","require","module","exports","markdownTable","trailingWhitespace","space","lineFeed","dash","colon","verticalBar","x","C","L","R","c","l","r","table","options","settings","padding","start","delimiterStart","end","delimiterEnd","align","concat","alignDelimiters","alignments","stringLength","defaultStringLength","rowIndex","rowLength","length","cellMatrix","sizeMatrix","row","sizes","longestCellByColumn","mostCellsPerRow","cells","columnIndex","columnLength","largest","size","cell","lines","line","before","after","code","serialize","undefined","push","toAlignment","Math","max","splice","join","replace","value","String","charCodeAt"],"mappings":"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","sourcesContent":["'use strict'\n\nvar repeat = require('repeat-string')\n\nmodule.exports = markdownTable\n\nvar trailingWhitespace = / +$/\n\n// Characters.\nvar space = ' '\nvar lineFeed = '\\n'\nvar dash = '-'\nvar colon = ':'\nvar verticalBar = '|'\n\nvar x = 0\nvar C = 67\nvar L = 76\nvar R = 82\nvar c = 99\nvar l = 108\nvar r = 114\n\n// Create a table from a matrix of strings.\nfunction markdownTable(table, options) {\n  var settings = options || {}\n  var padding = settings.padding !== false\n  var start = settings.delimiterStart !== false\n  var end = settings.delimiterEnd !== false\n  var align = (settings.align || []).concat()\n  var alignDelimiters = settings.alignDelimiters !== false\n  var alignments = []\n  var stringLength = settings.stringLength || defaultStringLength\n  var rowIndex = -1\n  var rowLength = table.length\n  var cellMatrix = []\n  var sizeMatrix = []\n  var row = []\n  var sizes = []\n  var longestCellByColumn = []\n  var mostCellsPerRow = 0\n  var cells\n  var columnIndex\n  var columnLength\n  var largest\n  var size\n  var cell\n  var lines\n  var line\n  var before\n  var after\n  var code\n\n  // This is a superfluous loop if we don’t align delimiters, but otherwise we’d\n  // do superfluous work when aligning, so optimize for aligning.\n  while (++rowIndex < rowLength) {\n    cells = table[rowIndex]\n    columnIndex = -1\n    columnLength = cells.length\n    row = []\n    sizes = []\n\n    if (columnLength > mostCellsPerRow) {\n      mostCellsPerRow = columnLength\n    }\n\n    while (++columnIndex < columnLength) {\n      cell = serialize(cells[columnIndex])\n\n      if (alignDelimiters === true) {\n        size = stringLength(cell)\n        sizes[columnIndex] = size\n\n        largest = longestCellByColumn[columnIndex]\n\n        if (largest === undefined || size > largest) {\n          longestCellByColumn[columnIndex] = size\n        }\n      }\n\n      row.push(cell)\n    }\n\n    cellMatrix[rowIndex] = row\n    sizeMatrix[rowIndex] = sizes\n  }\n\n  // Figure out which alignments to use.\n  columnIndex = -1\n  columnLength = mostCellsPerRow\n\n  if (typeof align === 'object' && 'length' in align) {\n    while (++columnIndex < columnLength) {\n      alignments[columnIndex] = toAlignment(align[columnIndex])\n    }\n  } else {\n    code = toAlignment(align)\n\n    while (++columnIndex < columnLength) {\n      alignments[columnIndex] = code\n    }\n  }\n\n  // Inject the alignment row.\n  columnIndex = -1\n  columnLength = mostCellsPerRow\n  row = []\n  sizes = []\n\n  while (++columnIndex < columnLength) {\n    code = alignments[columnIndex]\n    before = ''\n    after = ''\n\n    if (code === l) {\n      before = colon\n    } else if (code === r) {\n      after = colon\n    } else if (code === c) {\n      before = colon\n      after = colon\n    }\n\n    // There *must* be at least one hyphen-minus in each alignment cell.\n    size = alignDelimiters\n      ? Math.max(\n          1,\n          longestCellByColumn[columnIndex] - before.length - after.length\n        )\n      : 1\n\n    cell = before + repeat(dash, size) + after\n\n    if (alignDelimiters === true) {\n      size = before.length + size + after.length\n\n      if (size > longestCellByColumn[columnIndex]) {\n        longestCellByColumn[columnIndex] = size\n      }\n\n      sizes[columnIndex] = size\n    }\n\n    row[columnIndex] = cell\n  }\n\n  // Inject the alignment row.\n  cellMatrix.splice(1, 0, row)\n  sizeMatrix.splice(1, 0, sizes)\n\n  rowIndex = -1\n  rowLength = cellMatrix.length\n  lines = []\n\n  while (++rowIndex < rowLength) {\n    row = cellMatrix[rowIndex]\n    sizes = sizeMatrix[rowIndex]\n    columnIndex = -1\n    columnLength = mostCellsPerRow\n    line = []\n\n    while (++columnIndex < columnLength) {\n      cell = row[columnIndex] || ''\n      before = ''\n      after = ''\n\n      if (alignDelimiters === true) {\n        size = longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0)\n        code = alignments[columnIndex]\n\n        if (code === r) {\n          before = repeat(space, size)\n        } else if (code === c) {\n          if (size % 2 === 0) {\n            before = repeat(space, size / 2)\n            after = before\n          } else {\n            before = repeat(space, size / 2 + 0.5)\n            after = repeat(space, size / 2 - 0.5)\n          }\n        } else {\n          after = repeat(space, size)\n        }\n      }\n\n      if (start === true && columnIndex === 0) {\n        line.push(verticalBar)\n      }\n\n      if (\n        padding === true &&\n        // Don’t add the opening space if we’re not aligning and the cell is\n        // empty: there will be a closing space.\n        !(alignDelimiters === false && cell === '') &&\n        (start === true || columnIndex !== 0)\n      ) {\n        line.push(space)\n      }\n\n      if (alignDelimiters === true) {\n        line.push(before)\n      }\n\n      line.push(cell)\n\n      if (alignDelimiters === true) {\n        line.push(after)\n      }\n\n      if (padding === true) {\n        line.push(space)\n      }\n\n      if (end === true || columnIndex !== columnLength - 1) {\n        line.push(verticalBar)\n      }\n    }\n\n    line = line.join('')\n\n    if (end === false) {\n      line = line.replace(trailingWhitespace, '')\n    }\n\n    lines.push(line)\n  }\n\n  return lines.join(lineFeed)\n}\n\nfunction serialize(value) {\n  return value === null || value === undefined ? '' : String(value)\n}\n\nfunction defaultStringLength(value) {\n  return value.length\n}\n\nfunction toAlignment(value) {\n  var code = typeof value === 'string' ? value.charCodeAt(0) : x\n\n  return code === L || code === l\n    ? l\n    : code === R || code === r\n    ? r\n    : code === C || code === c\n    ? c\n    : x\n}\n"]},"metadata":{},"sourceType":"script"}