{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nconst Collection = require('../Collection');\n\nconst matchNode = require('../matchNode');\n\nconst once = require('../utils/once');\n\nconst recast = require('recast');\n\nconst Node = recast.types.namedTypes.Node;\nvar types = recast.types.namedTypes;\n/**\n* @mixin\n*/\n\nconst traversalMethods = {\n  /**\n   * Find nodes of a specific type within the nodes of this collection.\n   *\n   * @param {type}\n   * @param {filter}\n   * @return {Collection}\n   */\n  find: function (type, filter) {\n    const paths = [];\n    const visitorMethodName = 'visit' + type;\n    const visitor = {};\n\n    function visit(path) {\n      /*jshint validthis:true */\n      if (!filter || matchNode(path.value, filter)) {\n        paths.push(path);\n      }\n\n      this.traverse(path);\n    }\n\n    this.__paths.forEach(function (p, i) {\n      const self = this;\n\n      visitor[visitorMethodName] = function (path) {\n        if (self.__paths[i] === path) {\n          this.traverse(path);\n        } else {\n          return visit.call(this, path);\n        }\n      };\n\n      recast.visit(p, visitor);\n    }, this);\n\n    return Collection.fromPaths(paths, this, type);\n  },\n\n  /**\n   * Returns a collection containing the paths that create the scope of the\n   * currently selected paths. Dedupes the paths.\n   *\n   * @return {Collection}\n   */\n  closestScope: function () {\n    return this.map(path => path.scope && path.scope.path);\n  },\n\n  /**\n   * Traverse the AST up and finds the closest node of the provided type.\n   *\n   * @param {Collection}\n   * @param {filter}\n   * @return {Collection}\n   */\n  closest: function (type, filter) {\n    return this.map(function (path) {\n      let parent = path.parent;\n\n      while (parent && !(type.check(parent.value) && (!filter || matchNode(parent.value, filter)))) {\n        parent = parent.parent;\n      }\n\n      return parent || null;\n    });\n  },\n\n  /**\n   * Finds the declaration for each selected path. Useful for member expressions\n   * or JSXElements. Expects a callback function that maps each path to the name\n   * to look for.\n   *\n   * If the callback returns a falsey value, the element is skipped.\n   *\n   * @param {function} nameGetter\n   *\n   * @return {Collection}\n   */\n  getVariableDeclarators: function (nameGetter) {\n    return this.map(function (path) {\n      /*jshint curly:false*/\n      let scope = path.scope;\n      if (!scope) return;\n      const name = nameGetter.apply(path, arguments);\n      if (!name) return;\n      scope = scope.lookup(name);\n      if (!scope) return;\n      const bindings = scope.getBindings()[name];\n      if (!bindings) return;\n      const decl = Collection.fromPaths(bindings).closest(types.VariableDeclarator);\n\n      if (decl.length === 1) {\n        return decl.paths()[0];\n      }\n    }, types.VariableDeclarator);\n  }\n};\n\nfunction toArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n/**\n* @mixin\n*/\n\n\nconst mutationMethods = {\n  /**\n   * Simply replaces the selected nodes with the provided node. If a function\n   * is provided it is executed for every node and the node is replaced with the\n   * functions return value.\n   *\n   * @param {Node|Array<Node>|function} nodes\n   * @return {Collection}\n   */\n  replaceWith: function (nodes) {\n    return this.forEach(function (path, i) {\n      const newNodes = typeof nodes === 'function' ? nodes.call(path, path, i) : nodes;\n      path.replace.apply(path, toArray(newNodes));\n    });\n  },\n\n  /**\n   * Inserts a new node before the current one.\n   *\n   * @param {Node|Array<Node>|function} insert\n   * @return {Collection}\n   */\n  insertBefore: function (insert) {\n    return this.forEach(function (path, i) {\n      const newNodes = typeof insert === 'function' ? insert.call(path, path, i) : insert;\n      path.insertBefore.apply(path, toArray(newNodes));\n    });\n  },\n\n  /**\n   * Inserts a new node after the current one.\n   *\n   * @param {Node|Array<Node>|function} insert\n   * @return {Collection}\n   */\n  insertAfter: function (insert) {\n    return this.forEach(function (path, i) {\n      const newNodes = typeof insert === 'function' ? insert.call(path, path, i) : insert;\n      path.insertAfter.apply(path, toArray(newNodes));\n    });\n  },\n  remove: function () {\n    return this.forEach(path => path.prune());\n  }\n};\n\nfunction register() {\n  Collection.registerMethods(traversalMethods, Node);\n  Collection.registerMethods(mutationMethods, Node);\n  Collection.setDefaultCollectionType(Node);\n}\n\nexports.register = once(register);","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/jbook/node_modules/jscodeshift/src/collections/Node.js"],"names":["Collection","require","matchNode","once","recast","Node","types","namedTypes","traversalMethods","find","type","filter","paths","visitorMethodName","visitor","visit","path","value","push","traverse","__paths","forEach","p","i","self","call","fromPaths","closestScope","map","scope","closest","parent","check","getVariableDeclarators","nameGetter","name","apply","arguments","lookup","bindings","getBindings","decl","VariableDeclarator","length","toArray","Array","isArray","mutationMethods","replaceWith","nodes","newNodes","replace","insertBefore","insert","insertAfter","remove","prune","register","registerMethods","setDefaultCollectionType","exports"],"mappings":"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","sourcesContent":["\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst Collection = require('../Collection');\n\nconst matchNode = require('../matchNode');\nconst once = require('../utils/once');\nconst recast = require('recast');\n\nconst Node = recast.types.namedTypes.Node;\nvar types = recast.types.namedTypes;\n\n/**\n* @mixin\n*/\nconst traversalMethods = {\n\n  /**\n   * Find nodes of a specific type within the nodes of this collection.\n   *\n   * @param {type}\n   * @param {filter}\n   * @return {Collection}\n   */\n  find: function(type, filter) {\n    const paths = [];\n    const visitorMethodName = 'visit' + type;\n\n    const visitor = {};\n    function visit(path) {\n      /*jshint validthis:true */\n      if (!filter || matchNode(path.value, filter)) {\n        paths.push(path);\n      }\n      this.traverse(path);\n    }\n    this.__paths.forEach(function(p, i) {\n      const self = this;\n      visitor[visitorMethodName] = function(path) {\n        if (self.__paths[i] === path) {\n          this.traverse(path);\n        } else {\n          return visit.call(this, path);\n        }\n      };\n      recast.visit(p, visitor);\n    }, this);\n\n    return Collection.fromPaths(paths, this, type);\n  },\n\n  /**\n   * Returns a collection containing the paths that create the scope of the\n   * currently selected paths. Dedupes the paths.\n   *\n   * @return {Collection}\n   */\n  closestScope: function() {\n    return this.map(path => path.scope && path.scope.path);\n  },\n\n  /**\n   * Traverse the AST up and finds the closest node of the provided type.\n   *\n   * @param {Collection}\n   * @param {filter}\n   * @return {Collection}\n   */\n  closest: function(type, filter) {\n    return this.map(function(path) {\n      let parent = path.parent;\n      while (\n        parent &&\n        !(\n          type.check(parent.value) &&\n          (!filter || matchNode(parent.value, filter))\n        )\n      ) {\n        parent = parent.parent;\n      }\n      return parent || null;\n    });\n  },\n\n  /**\n   * Finds the declaration for each selected path. Useful for member expressions\n   * or JSXElements. Expects a callback function that maps each path to the name\n   * to look for.\n   *\n   * If the callback returns a falsey value, the element is skipped.\n   *\n   * @param {function} nameGetter\n   *\n   * @return {Collection}\n   */\n  getVariableDeclarators: function(nameGetter) {\n    return this.map(function(path) {\n      /*jshint curly:false*/\n      let scope = path.scope;\n      if (!scope) return;\n      const name = nameGetter.apply(path, arguments);\n      if (!name) return;\n      scope = scope.lookup(name);\n      if (!scope) return;\n      const bindings = scope.getBindings()[name];\n      if (!bindings) return;\n      const decl = Collection.fromPaths(bindings)\n        .closest(types.VariableDeclarator);\n      if (decl.length === 1) {\n        return decl.paths()[0];\n      }\n    }, types.VariableDeclarator);\n  },\n};\n\nfunction toArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\n/**\n* @mixin\n*/\nconst mutationMethods = {\n  /**\n   * Simply replaces the selected nodes with the provided node. If a function\n   * is provided it is executed for every node and the node is replaced with the\n   * functions return value.\n   *\n   * @param {Node|Array<Node>|function} nodes\n   * @return {Collection}\n   */\n  replaceWith: function(nodes) {\n    return this.forEach(function(path, i) {\n      const newNodes =\n        (typeof nodes === 'function') ? nodes.call(path, path, i) : nodes;\n      path.replace.apply(path, toArray(newNodes));\n    });\n  },\n\n  /**\n   * Inserts a new node before the current one.\n   *\n   * @param {Node|Array<Node>|function} insert\n   * @return {Collection}\n   */\n  insertBefore: function(insert) {\n    return this.forEach(function(path, i) {\n      const newNodes =\n        (typeof insert === 'function') ? insert.call(path, path, i) : insert;\n      path.insertBefore.apply(path, toArray(newNodes));\n    });\n  },\n\n  /**\n   * Inserts a new node after the current one.\n   *\n   * @param {Node|Array<Node>|function} insert\n   * @return {Collection}\n   */\n  insertAfter: function(insert) {\n    return this.forEach(function(path, i) {\n      const newNodes =\n        (typeof insert === 'function') ? insert.call(path, path, i) : insert;\n      path.insertAfter.apply(path, toArray(newNodes));\n    });\n  },\n\n  remove: function() {\n    return this.forEach(path => path.prune());\n  }\n\n};\n\nfunction register() {\n  Collection.registerMethods(traversalMethods, Node);\n  Collection.registerMethods(mutationMethods, Node);\n  Collection.setDefaultCollectionType(Node);\n}\n\nexports.register = once(register);\n"]},"metadata":{},"sourceType":"script"}