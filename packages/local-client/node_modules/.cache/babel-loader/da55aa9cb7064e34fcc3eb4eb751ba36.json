{"ast":null,"code":"(function (Prism) {\n  var keyword = /\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char8_t|char16_t|char32_t|class|compl|concept|const|consteval|constexpr|constinit|const_cast|continue|co_await|co_return|co_yield|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/;\n  var modName = /\\b(?!<keyword>)\\w+(?:\\s*\\.\\s*\\w+)*\\b/.source.replace(/<keyword>/g, function () {\n    return keyword.source;\n  });\n  Prism.languages.cpp = Prism.languages.extend('c', {\n    'class-name': [{\n      pattern: RegExp(/(\\b(?:class|concept|enum|struct|typename)\\s+)(?!<keyword>)\\w+/.source.replace(/<keyword>/g, function () {\n        return keyword.source;\n      })),\n      lookbehind: true\n    }, // This is intended to capture the class name of method implementations like:\n    //   void foo::bar() const {}\n    // However! The `foo` in the above example could also be a namespace, so we only capture the class name if\n    // it starts with an uppercase letter. This approximation should give decent results.\n    /\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/, // This will capture the class name before destructors like:\n    //   Foo::~Foo() {}\n    /\\b[A-Z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i, // This also intends to capture the class name of method implementations but here the class has template\n    // parameters, so it can't be a namespace (until C++ adds generic namespaces).\n    /\\b\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/],\n    'keyword': keyword,\n    'number': {\n      pattern: /(?:\\b0b[01']+|\\b0x(?:[\\da-f']+(?:\\.[\\da-f']*)?|\\.[\\da-f']+)(?:p[+-]?[\\d']+)?|(?:\\b[\\d']+(?:\\.[\\d']*)?|\\B\\.[\\d']+)(?:e[+-]?[\\d']+)?)[ful]{0,4}/i,\n      greedy: true\n    },\n    'operator': />>=?|<<=?|->|--|\\+\\+|&&|\\|\\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/,\n    'boolean': /\\b(?:true|false)\\b/\n  });\n  Prism.languages.insertBefore('cpp', 'string', {\n    'module': {\n      // https://en.cppreference.com/w/cpp/language/modules\n      pattern: RegExp(/(\\b(?:module|import)\\s+)/.source + '(?:' + // header-name\n      /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|<[^<>\\r\\n]*>/.source + '|' + // module name or partition or both\n      /<mod-name>(?:\\s*:\\s*<mod-name>)?|:\\s*<mod-name>/.source.replace(/<mod-name>/g, function () {\n        return modName;\n      }) + ')'),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'string': /^[<\"][\\s\\S]+/,\n        'operator': /:/,\n        'punctuation': /\\./\n      }\n    },\n    'raw-string': {\n      pattern: /R\"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1\"/,\n      alias: 'string',\n      greedy: true\n    }\n  });\n  Prism.languages.insertBefore('cpp', 'keyword', {\n    'generic-function': {\n      pattern: /\\b[a-z_]\\w*\\s*<(?:[^<>]|<(?:[^<>])*>)*>(?=\\s*\\()/i,\n      inside: {\n        'function': /^\\w+/,\n        'generic': {\n          pattern: /<[\\s\\S]+/,\n          alias: 'class-name',\n          inside: Prism.languages.cpp\n        }\n      }\n    }\n  });\n  Prism.languages.insertBefore('cpp', 'operator', {\n    'double-colon': {\n      pattern: /::/,\n      alias: 'punctuation'\n    }\n  });\n  Prism.languages.insertBefore('cpp', 'class-name', {\n    // the base clause is an optional list of parent classes\n    // https://en.cppreference.com/w/cpp/language/class\n    'base-clause': {\n      pattern: /(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)[^;{}\"'\\s]+(?:\\s+[^;{}\"'\\s]+)*(?=\\s*[;{])/,\n      lookbehind: true,\n      greedy: true,\n      inside: Prism.languages.extend('cpp', {})\n    }\n  });\n  Prism.languages.insertBefore('inside', 'double-colon', {\n    // All untokenized words that are not namespaces should be class names\n    'class-name': /\\b[a-z_]\\w*\\b(?!\\s*::)/i\n  }, Prism.languages.cpp['base-clause']);\n})(Prism);","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/jbook/node_modules/prismjs/components/prism-cpp.js"],"names":["Prism","keyword","modName","source","replace","languages","cpp","extend","pattern","RegExp","lookbehind","greedy","insertBefore","inside","alias"],"mappings":"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","sourcesContent":["(function (Prism) {\n\n\tvar keyword = /\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char8_t|char16_t|char32_t|class|compl|concept|const|consteval|constexpr|constinit|const_cast|continue|co_await|co_return|co_yield|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/;\n\tvar modName = /\\b(?!<keyword>)\\w+(?:\\s*\\.\\s*\\w+)*\\b/.source.replace(/<keyword>/g, function () { return keyword.source; });\n\n\tPrism.languages.cpp = Prism.languages.extend('c', {\n\t\t'class-name': [\n\t\t\t{\n\t\t\t\tpattern: RegExp(/(\\b(?:class|concept|enum|struct|typename)\\s+)(?!<keyword>)\\w+/.source\n\t\t\t\t\t.replace(/<keyword>/g, function () { return keyword.source; })),\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t// This is intended to capture the class name of method implementations like:\n\t\t\t//   void foo::bar() const {}\n\t\t\t// However! The `foo` in the above example could also be a namespace, so we only capture the class name if\n\t\t\t// it starts with an uppercase letter. This approximation should give decent results.\n\t\t\t/\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/,\n\t\t\t// This will capture the class name before destructors like:\n\t\t\t//   Foo::~Foo() {}\n\t\t\t/\\b[A-Z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i,\n\t\t\t// This also intends to capture the class name of method implementations but here the class has template\n\t\t\t// parameters, so it can't be a namespace (until C++ adds generic namespaces).\n\t\t\t/\\b\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/\n\t\t],\n\t\t'keyword': keyword,\n\t\t'number': {\n\t\t\tpattern: /(?:\\b0b[01']+|\\b0x(?:[\\da-f']+(?:\\.[\\da-f']*)?|\\.[\\da-f']+)(?:p[+-]?[\\d']+)?|(?:\\b[\\d']+(?:\\.[\\d']*)?|\\B\\.[\\d']+)(?:e[+-]?[\\d']+)?)[ful]{0,4}/i,\n\t\t\tgreedy: true\n\t\t},\n\t\t'operator': />>=?|<<=?|->|--|\\+\\+|&&|\\|\\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/,\n\t\t'boolean': /\\b(?:true|false)\\b/\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'string', {\n\t\t'module': {\n\t\t\t// https://en.cppreference.com/w/cpp/language/modules\n\t\t\tpattern: RegExp(\n\t\t\t\t/(\\b(?:module|import)\\s+)/.source +\n\t\t\t\t'(?:' +\n\t\t\t\t// header-name\n\t\t\t\t/\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|<[^<>\\r\\n]*>/.source +\n\t\t\t\t'|' +\n\t\t\t\t// module name or partition or both\n\t\t\t\t/<mod-name>(?:\\s*:\\s*<mod-name>)?|:\\s*<mod-name>/.source.replace(/<mod-name>/g, function () { return modName; }) +\n\t\t\t\t')'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'string': /^[<\"][\\s\\S]+/,\n\t\t\t\t'operator': /:/,\n\t\t\t\t'punctuation': /\\./\n\t\t\t}\n\t\t},\n\t\t'raw-string': {\n\t\t\tpattern: /R\"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1\"/,\n\t\t\talias: 'string',\n\t\t\tgreedy: true\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'keyword', {\n\t\t'generic-function': {\n\t\t\tpattern: /\\b[a-z_]\\w*\\s*<(?:[^<>]|<(?:[^<>])*>)*>(?=\\s*\\()/i,\n\t\t\tinside: {\n\t\t\t\t'function': /^\\w+/,\n\t\t\t\t'generic': {\n\t\t\t\t\tpattern: /<[\\s\\S]+/,\n\t\t\t\t\talias: 'class-name',\n\t\t\t\t\tinside: Prism.languages.cpp\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'operator', {\n\t\t'double-colon': {\n\t\t\tpattern: /::/,\n\t\t\talias: 'punctuation'\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'class-name', {\n\t\t// the base clause is an optional list of parent classes\n\t\t// https://en.cppreference.com/w/cpp/language/class\n\t\t'base-clause': {\n\t\t\tpattern: /(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)[^;{}\"'\\s]+(?:\\s+[^;{}\"'\\s]+)*(?=\\s*[;{])/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: Prism.languages.extend('cpp', {})\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('inside', 'double-colon', {\n\t\t// All untokenized words that are not namespaces should be class names\n\t\t'class-name': /\\b[a-z_]\\w*\\b(?!\\s*::)/i\n\t}, Prism.languages.cpp['base-clause']);\n\n}(Prism));\n"]},"metadata":{},"sourceType":"script"}