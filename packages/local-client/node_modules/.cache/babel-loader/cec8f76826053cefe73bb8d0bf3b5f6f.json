{"ast":null,"code":"exports.flow = {\n  null: {\n    tokenize: tokenizeTable,\n    resolve: resolveTable,\n    interruptible: true\n  }\n};\n\nvar createSpace = require('micromark/dist/tokenize/factory-space');\n\nvar setextUnderlineMini = {\n  tokenize: tokenizeSetextUnderlineMini,\n  partial: true\n};\nvar nextPrefixedOrBlank = {\n  tokenize: tokenizeNextPrefixedOrBlank,\n  partial: true\n};\n\nfunction resolveTable(events, context) {\n  var length = events.length;\n  var index = -1;\n  var token;\n  var inHead;\n  var inDelimiterRow;\n  var inRow;\n  var cell;\n  var content;\n  var text;\n  var contentStart;\n  var contentEnd;\n  var cellStart;\n\n  while (++index < length) {\n    token = events[index][1];\n\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index;\n        contentEnd = index;\n      }\n\n      if ( // Combine separate content parts into one.\n      (token.type === 'tableCellDivider' || token.type === 'tableRow') && contentEnd) {\n        content = {\n          type: 'tableContent',\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        };\n        text = {\n          type: 'chunkText',\n          start: content.start,\n          end: content.end,\n          contentType: 'text'\n        };\n        events.splice(contentStart, contentEnd - contentStart + 1, ['enter', content, context], ['enter', text, context], ['exit', text, context], ['exit', content, context]);\n        index -= contentEnd - contentStart - 3;\n        length = events.length;\n        contentStart = undefined;\n        contentEnd = undefined;\n      }\n    }\n\n    if (events[index][0] === 'exit' && cellStart && cellStart + 1 < index && (token.type === 'tableCellDivider' || token.type === 'tableRow' && (cellStart + 3 < index || events[cellStart][1].type !== 'whitespace'))) {\n      cell = {\n        type: inDelimiterRow ? 'tableDelimiter' : inHead ? 'tableHeader' : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      };\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, ['exit', cell, context]);\n      events.splice(cellStart, 0, ['enter', cell, context]);\n      index += 2;\n      length = events.length;\n      cellStart = index + 1;\n    }\n\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter';\n\n      if (inRow) {\n        cellStart = index + 1;\n      }\n    }\n\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter';\n\n      if (inDelimiterRow) {\n        cellStart = index + 1;\n      }\n    }\n\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter';\n    }\n  }\n\n  return events;\n}\n\nfunction tokenizeTable(effects, ok, nok) {\n  var align = [];\n  var tableHeaderCount = 0;\n  var seenDelimiter;\n  var hasDash;\n  return start;\n\n  function start(code) {\n    /* istanbul ignore if - used to be passed in beta micromark versions. */\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return nok(code);\n    }\n\n    effects.enter('table')._align = align;\n    effects.enter('tableHead');\n    effects.enter('tableRow'); // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerHead(code);\n    }\n\n    tableHeaderCount++;\n    effects.enter('temporaryTableCellContent'); // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentHead(code);\n  }\n\n  function cellDividerHead(code) {\n    // Always a pipe.\n    effects.enter('tableCellDivider');\n    effects.consume(code);\n    effects.exit('tableCellDivider');\n    seenDelimiter = true;\n    return cellBreakHead;\n  }\n\n  function cellBreakHead(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return atRowEndHead(code);\n    } // HT, VS, SP.\n\n\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceHead;\n    }\n\n    if (seenDelimiter) {\n      seenDelimiter = undefined;\n      tableHeaderCount++;\n    } // `|`\n\n\n    if (code === 124) {\n      return cellDividerHead(code);\n    } // Anything else is cell content.\n\n\n    effects.enter('temporaryTableCellContent');\n    return inCellContentHead(code);\n  }\n\n  function inWhitespaceHead(code) {\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code);\n      return inWhitespaceHead;\n    }\n\n    effects.exit('whitespace');\n    return cellBreakHead(code);\n  }\n\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code < 0 || code === 32 || code === 124) {\n      effects.exit('temporaryTableCellContent');\n      return cellBreakHead(code);\n    }\n\n    effects.consume(code); // `\\`\n\n    return code === 92 ? inCellContentEscapeHead : inCellContentHead;\n  }\n\n  function inCellContentEscapeHead(code) {\n    // `\\` or `|`\n    if (code === 92 || code === 124) {\n      effects.consume(code);\n      return inCellContentHead;\n    } // Anything else.\n\n\n    return inCellContentHead(code);\n  }\n\n  function atRowEndHead(code) {\n    if (code === null) {\n      return nok(code);\n    }\n\n    effects.exit('tableRow');\n    effects.exit('tableHead'); // Always a line ending.\n\n    effects.enter('lineEnding');\n    effects.consume(code);\n    effects.exit('lineEnding'); // If a setext heading, exit.\n\n    return effects.check(setextUnderlineMini, nok, // Support an indent before the delimiter row.\n    createSpace(effects, rowStartDelimiter, 'linePrefix', 4));\n  }\n\n  function rowStartDelimiter(code) {\n    // If there’s another space, or we’re at the EOL/EOF, exit.\n    if (code === null || code < 0 || code === 32) {\n      return nok(code);\n    }\n\n    effects.enter('tableDelimiterRow');\n    return atDelimiterRowBreak(code);\n  }\n\n  function atDelimiterRowBreak(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return rowEndDelimiter(code);\n    } // HT, VS, SP.\n\n\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    } // `-`\n\n\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller');\n      effects.consume(code);\n      hasDash = true;\n      align.push(null);\n      return inFillerDelimiter;\n    } // `:`\n\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment');\n      effects.consume(code);\n      effects.exit('tableDelimiterAlignment');\n      align.push('left');\n      return afterLeftAlignment;\n    } // If we start with a pipe, we open a cell marker.\n\n\n    if (code === 124) {\n      effects.enter('tableCellDivider');\n      effects.consume(code);\n      effects.exit('tableCellDivider');\n      return atDelimiterRowBreak;\n    }\n\n    return nok(code);\n  }\n\n  function inWhitespaceDelimiter(code) {\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    }\n\n    effects.exit('whitespace');\n    return atDelimiterRowBreak(code);\n  }\n\n  function inFillerDelimiter(code) {\n    // `-`\n    if (code === 45) {\n      effects.consume(code);\n      return inFillerDelimiter;\n    }\n\n    effects.exit('tableDelimiterFiller'); // `:`\n\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment');\n      effects.consume(code);\n      effects.exit('tableDelimiterAlignment');\n      align[align.length - 1] = align[align.length - 1] === 'left' ? 'center' : 'right';\n      return afterRightAlignment;\n    }\n\n    return atDelimiterRowBreak(code);\n  }\n\n  function afterLeftAlignment(code) {\n    // `-`\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller');\n      effects.consume(code);\n      hasDash = true;\n      return inFillerDelimiter;\n    } // Anything else is not ok.\n\n\n    return nok(code);\n  }\n\n  function afterRightAlignment(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return rowEndDelimiter(code);\n    } // HT, VS, SP.\n\n\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    } // `|`\n\n\n    if (code === 124) {\n      effects.enter('tableCellDivider');\n      effects.consume(code);\n      effects.exit('tableCellDivider');\n      return atDelimiterRowBreak;\n    }\n\n    return nok(code);\n  }\n\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow'); // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code);\n    }\n\n    if (code === null) {\n      return tableClose(code);\n    }\n\n    return effects.check(nextPrefixedOrBlank, tableClose, tableContinue)(code);\n  }\n\n  function tableClose(code) {\n    effects.exit('table');\n    return ok(code);\n  }\n\n  function tableContinue(code) {\n    // Always a line ending.\n    effects.enter('lineEnding');\n    effects.consume(code);\n    effects.exit('lineEnding'); // We checked that it’s not a prefixed or blank line, so we’re certain a\n    // body is coming, though it may be indented.\n\n    return createSpace(effects, bodyStart, 'linePrefix', 4);\n  }\n\n  function bodyStart(code) {\n    effects.enter('tableBody');\n    return rowStartBody(code);\n  }\n\n  function rowStartBody(code) {\n    effects.enter('tableRow'); // If we start with a pipe, we open a cell marker.\n\n    if (code === 124) {\n      return cellDividerBody(code);\n    }\n\n    effects.enter('temporaryTableCellContent'); // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentBody(code);\n  }\n\n  function cellDividerBody(code) {\n    // Always a pipe.\n    effects.enter('tableCellDivider');\n    effects.consume(code);\n    effects.exit('tableCellDivider');\n    return cellBreakBody;\n  }\n\n  function cellBreakBody(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return atRowEndBody(code);\n    } // HT, VS, SP.\n\n\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace');\n      effects.consume(code);\n      return inWhitespaceBody;\n    } // `|`\n\n\n    if (code === 124) {\n      return cellDividerBody(code);\n    } // Anything else is cell content.\n\n\n    effects.enter('temporaryTableCellContent');\n    return inCellContentBody(code);\n  }\n\n  function inWhitespaceBody(code) {\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code);\n      return inWhitespaceBody;\n    }\n\n    effects.exit('whitespace');\n    return cellBreakBody(code);\n  }\n\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code < 0 || code === 32 || code === 124) {\n      effects.exit('temporaryTableCellContent');\n      return cellBreakBody(code);\n    }\n\n    effects.consume(code); // `\\`\n\n    return code === 92 ? inCellContentEscapeBody : inCellContentBody;\n  }\n\n  function inCellContentEscapeBody(code) {\n    // `\\` or `|`\n    if (code === 92 || code === 124) {\n      effects.consume(code);\n      return inCellContentBody;\n    } // Anything else.\n\n\n    return inCellContentBody(code);\n  }\n\n  function atRowEndBody(code) {\n    effects.exit('tableRow');\n\n    if (code === null) {\n      return tableBodyClose(code);\n    }\n\n    return effects.check(nextPrefixedOrBlank, tableBodyClose, tableBodyContinue)(code);\n  }\n\n  function tableBodyClose(code) {\n    effects.exit('tableBody');\n    return tableClose(code);\n  }\n\n  function tableBodyContinue(code) {\n    // Always a line ending.\n    effects.enter('lineEnding');\n    effects.consume(code);\n    effects.exit('lineEnding'); // Support an optional prefix, then start a body row.\n\n    return createSpace(effects, rowStartBody, 'linePrefix', 4);\n  }\n} // Based on micromark, but that won’t work as we’re in a table, and that expects\n// content.\n// <https://github.com/micromark/micromark/blob/main/lib/tokenize/setext-underline.js>\n\n\nfunction tokenizeSetextUnderlineMini(effects, ok, nok) {\n  return start;\n\n  function start(code) {\n    // `-`\n    if (code !== 45) {\n      return nok(code);\n    }\n\n    effects.enter('setextUnderline');\n    return sequence(code);\n  }\n\n  function sequence(code) {\n    if (code === 45) {\n      effects.consume(code);\n      return sequence;\n    }\n\n    return whitespace(code);\n  }\n\n  function whitespace(code) {\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code);\n      return whitespace;\n    }\n\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return ok(code);\n    }\n\n    return nok(code);\n  }\n}\n\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  var size = 0;\n  return start;\n\n  function start(code) {\n    // This is a check, so we don’t care about tokens, but we open a bogus one\n    // so we’re valid.\n    effects.enter('check'); // EOL.\n\n    effects.consume(code);\n    return whitespace;\n  }\n\n  function whitespace(code) {\n    // VS or SP.\n    if (code === -1 || code === 32) {\n      effects.consume(code);\n      size++;\n      return size === 4 ? ok : whitespace;\n    } // EOF or whitespace\n\n\n    if (code === null || code < 0) {\n      return ok(code);\n    } // Anything else.\n\n\n    return nok(code);\n  }\n}","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/github/react-snippy/node_modules/micromark-extension-gfm-table/syntax.js"],"names":["exports","flow","null","tokenize","tokenizeTable","resolve","resolveTable","interruptible","createSpace","require","setextUnderlineMini","tokenizeSetextUnderlineMini","partial","nextPrefixedOrBlank","tokenizeNextPrefixedOrBlank","events","context","length","index","token","inHead","inDelimiterRow","inRow","cell","content","text","contentStart","contentEnd","cellStart","type","start","end","contentType","splice","undefined","effects","ok","nok","align","tableHeaderCount","seenDelimiter","hasDash","code","enter","_align","cellDividerHead","inCellContentHead","consume","exit","cellBreakHead","atRowEndHead","inWhitespaceHead","inCellContentEscapeHead","check","rowStartDelimiter","atDelimiterRowBreak","rowEndDelimiter","inWhitespaceDelimiter","push","inFillerDelimiter","afterLeftAlignment","afterRightAlignment","tableClose","tableContinue","bodyStart","rowStartBody","cellDividerBody","inCellContentBody","cellBreakBody","atRowEndBody","inWhitespaceBody","inCellContentEscapeBody","tableBodyClose","tableBodyContinue","sequence","whitespace","size"],"mappings":"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","sourcesContent":["exports.flow = {\n  null: {tokenize: tokenizeTable, resolve: resolveTable, interruptible: true}\n}\n\nvar createSpace = require('micromark/dist/tokenize/factory-space')\n\nvar setextUnderlineMini = {tokenize: tokenizeSetextUnderlineMini, partial: true}\nvar nextPrefixedOrBlank = {tokenize: tokenizeNextPrefixedOrBlank, partial: true}\n\nfunction resolveTable(events, context) {\n  var length = events.length\n  var index = -1\n  var token\n  var inHead\n  var inDelimiterRow\n  var inRow\n  var cell\n  var content\n  var text\n  var contentStart\n  var contentEnd\n  var cellStart\n\n  while (++index < length) {\n    token = events[index][1]\n\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index\n        contentEnd = index\n      }\n\n      if (\n        // Combine separate content parts into one.\n        (token.type === 'tableCellDivider' || token.type === 'tableRow') &&\n        contentEnd\n      ) {\n        content = {\n          type: 'tableContent',\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        }\n        text = {\n          type: 'chunkText',\n          start: content.start,\n          end: content.end,\n          contentType: 'text'\n        }\n\n        events.splice(\n          contentStart,\n          contentEnd - contentStart + 1,\n          ['enter', content, context],\n          ['enter', text, context],\n          ['exit', text, context],\n          ['exit', content, context]\n        )\n        index -= contentEnd - contentStart - 3\n        length = events.length\n        contentStart = undefined\n        contentEnd = undefined\n      }\n    }\n\n    if (\n      events[index][0] === 'exit' &&\n      cellStart &&\n      cellStart + 1 < index &&\n      (token.type === 'tableCellDivider' ||\n        (token.type === 'tableRow' &&\n          (cellStart + 3 < index ||\n            events[cellStart][1].type !== 'whitespace')))\n    ) {\n      cell = {\n        type: inDelimiterRow\n          ? 'tableDelimiter'\n          : inHead\n          ? 'tableHeader'\n          : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      }\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, [\n        'exit',\n        cell,\n        context\n      ])\n      events.splice(cellStart, 0, ['enter', cell, context])\n      index += 2\n      length = events.length\n      cellStart = index + 1\n    }\n\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter'\n\n      if (inRow) {\n        cellStart = index + 1\n      }\n    }\n\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter'\n\n      if (inDelimiterRow) {\n        cellStart = index + 1\n      }\n    }\n\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter'\n    }\n  }\n\n  return events\n}\n\nfunction tokenizeTable(effects, ok, nok) {\n  var align = []\n  var tableHeaderCount = 0\n  var seenDelimiter\n  var hasDash\n\n  return start\n\n  function start(code) {\n    /* istanbul ignore if - used to be passed in beta micromark versions. */\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return nok(code)\n    }\n\n    effects.enter('table')._align = align\n    effects.enter('tableHead')\n    effects.enter('tableRow')\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === 124) {\n      return cellDividerHead(code)\n    }\n\n    tableHeaderCount++\n    effects.enter('temporaryTableCellContent')\n    // Can’t be space or eols at the start of a construct, so we’re in a cell.\n    return inCellContentHead(code)\n  }\n\n  function cellDividerHead(code) {\n    // Always a pipe.\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    seenDelimiter = true\n    return cellBreakHead\n  }\n\n  function cellBreakHead(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return atRowEndHead(code)\n    }\n\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    if (seenDelimiter) {\n      seenDelimiter = undefined\n      tableHeaderCount++\n    }\n\n    // `|`\n    if (code === 124) {\n      return cellDividerHead(code)\n    }\n\n    // Anything else is cell content.\n    effects.enter('temporaryTableCellContent')\n    return inCellContentHead(code)\n  }\n\n  function inWhitespaceHead(code) {\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    effects.exit('whitespace')\n    return cellBreakHead(code)\n  }\n\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code < 0 || code === 32 || code === 124) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakHead(code)\n    }\n\n    effects.consume(code)\n    // `\\`\n    return code === 92 ? inCellContentEscapeHead : inCellContentHead\n  }\n\n  function inCellContentEscapeHead(code) {\n    // `\\` or `|`\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return inCellContentHead\n    }\n\n    // Anything else.\n    return inCellContentHead(code)\n  }\n\n  function atRowEndHead(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    effects.exit('tableRow')\n    effects.exit('tableHead')\n\n    // Always a line ending.\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n\n    // If a setext heading, exit.\n    return effects.check(\n      setextUnderlineMini,\n      nok,\n      // Support an indent before the delimiter row.\n      createSpace(effects, rowStartDelimiter, 'linePrefix', 4)\n    )\n  }\n\n  function rowStartDelimiter(code) {\n    // If there’s another space, or we’re at the EOL/EOF, exit.\n    if (code === null || code < 0 || code === 32) {\n      return nok(code)\n    }\n\n    effects.enter('tableDelimiterRow')\n    return atDelimiterRowBreak(code)\n  }\n\n  function atDelimiterRowBreak(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return rowEndDelimiter(code)\n    }\n\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    // `-`\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      align.push(null)\n      return inFillerDelimiter\n    }\n\n    // `:`\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n      align.push('left')\n      return afterLeftAlignment\n    }\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n\n  function inWhitespaceDelimiter(code) {\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    effects.exit('whitespace')\n    return atDelimiterRowBreak(code)\n  }\n\n  function inFillerDelimiter(code) {\n    // `-`\n    if (code === 45) {\n      effects.consume(code)\n      return inFillerDelimiter\n    }\n\n    effects.exit('tableDelimiterFiller')\n\n    // `:`\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n\n      align[align.length - 1] =\n        align[align.length - 1] === 'left' ? 'center' : 'right'\n\n      return afterRightAlignment\n    }\n\n    return atDelimiterRowBreak(code)\n  }\n\n  function afterLeftAlignment(code) {\n    // `-`\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      return inFillerDelimiter\n    }\n\n    // Anything else is not ok.\n    return nok(code)\n  }\n\n  function afterRightAlignment(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return rowEndDelimiter(code)\n    }\n\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    // `|`\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow')\n\n    // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code)\n    }\n\n    if (code === null) {\n      return tableClose(code)\n    }\n\n    return effects.check(nextPrefixedOrBlank, tableClose, tableContinue)(code)\n  }\n\n  function tableClose(code) {\n    effects.exit('table')\n    return ok(code)\n  }\n\n  function tableContinue(code) {\n    // Always a line ending.\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    // We checked that it’s not a prefixed or blank line, so we’re certain a\n    // body is coming, though it may be indented.\n    return createSpace(effects, bodyStart, 'linePrefix', 4)\n  }\n\n  function bodyStart(code) {\n    effects.enter('tableBody')\n    return rowStartBody(code)\n  }\n\n  function rowStartBody(code) {\n    effects.enter('tableRow')\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === 124) {\n      return cellDividerBody(code)\n    }\n\n    effects.enter('temporaryTableCellContent')\n    // Can’t be space or eols at the start of a construct, so we’re in a cell.\n    return inCellContentBody(code)\n  }\n\n  function cellDividerBody(code) {\n    // Always a pipe.\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    return cellBreakBody\n  }\n\n  function cellBreakBody(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return atRowEndBody(code)\n    }\n\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceBody\n    }\n\n    // `|`\n    if (code === 124) {\n      return cellDividerBody(code)\n    }\n\n    // Anything else is cell content.\n    effects.enter('temporaryTableCellContent')\n    return inCellContentBody(code)\n  }\n\n  function inWhitespaceBody(code) {\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code)\n      return inWhitespaceBody\n    }\n\n    effects.exit('whitespace')\n    return cellBreakBody(code)\n  }\n\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code < 0 || code === 32 || code === 124) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakBody(code)\n    }\n\n    effects.consume(code)\n    // `\\`\n    return code === 92 ? inCellContentEscapeBody : inCellContentBody\n  }\n\n  function inCellContentEscapeBody(code) {\n    // `\\` or `|`\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return inCellContentBody\n    }\n\n    // Anything else.\n    return inCellContentBody(code)\n  }\n\n  function atRowEndBody(code) {\n    effects.exit('tableRow')\n\n    if (code === null) {\n      return tableBodyClose(code)\n    }\n\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableBodyClose,\n      tableBodyContinue\n    )(code)\n  }\n\n  function tableBodyClose(code) {\n    effects.exit('tableBody')\n    return tableClose(code)\n  }\n\n  function tableBodyContinue(code) {\n    // Always a line ending.\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    // Support an optional prefix, then start a body row.\n    return createSpace(effects, rowStartBody, 'linePrefix', 4)\n  }\n}\n\n// Based on micromark, but that won’t work as we’re in a table, and that expects\n// content.\n// <https://github.com/micromark/micromark/blob/main/lib/tokenize/setext-underline.js>\nfunction tokenizeSetextUnderlineMini(effects, ok, nok) {\n  return start\n\n  function start(code) {\n    // `-`\n    if (code !== 45) {\n      return nok(code)\n    }\n\n    effects.enter('setextUnderline')\n    return sequence(code)\n  }\n\n  function sequence(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return sequence\n    }\n\n    return whitespace(code)\n  }\n\n  function whitespace(code) {\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code)\n      return whitespace\n    }\n\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  var size = 0\n\n  return start\n\n  function start(code) {\n    // This is a check, so we don’t care about tokens, but we open a bogus one\n    // so we’re valid.\n    effects.enter('check')\n    // EOL.\n    effects.consume(code)\n    return whitespace\n  }\n\n  function whitespace(code) {\n    // VS or SP.\n    if (code === -1 || code === 32) {\n      effects.consume(code)\n      size++\n      return size === 4 ? ok : whitespace\n    }\n\n    // EOF or whitespace\n    if (code === null || code < 0) {\n      return ok(code)\n    }\n\n    // Anything else.\n    return nok(code)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}