{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nconst Collection = require('../Collection');\n\nconst NodeCollection = require('./Node');\n\nconst assert = require('assert');\n\nconst once = require('../utils/once');\n\nconst recast = require('recast');\n\nconst requiresModule = require('./VariableDeclarator').filters.requiresModule;\n\nconst types = recast.types.namedTypes;\nconst JSXElement = types.JSXElement;\nconst JSXAttribute = types.JSXAttribute;\nconst Literal = types.Literal;\n/**\n * Contains filter methods and mutation methods for processing JSXElements.\n * @mixin\n */\n\nconst globalMethods = {\n  /**\n   * Finds all JSXElements optionally filtered by name\n   *\n   * @param {string} name\n   * @return {Collection}\n   */\n  findJSXElements: function (name) {\n    const nameFilter = name && {\n      openingElement: {\n        name: {\n          name: name\n        }\n      }\n    };\n    return this.find(JSXElement, nameFilter);\n  },\n\n  /**\n   * Finds all JSXElements by module name. Given\n   *\n   *     var Bar = require('Foo');\n   *     <Bar />\n   *\n   * findJSXElementsByModuleName('Foo') will find <Bar />, without having to\n   * know the variable name.\n   */\n  findJSXElementsByModuleName: function (moduleName) {\n    assert.ok(moduleName && typeof moduleName === 'string', 'findJSXElementsByModuleName(...) needs a name to look for');\n    return this.find(types.VariableDeclarator).filter(requiresModule(moduleName)).map(function (path) {\n      const id = path.value.id.name;\n\n      if (id) {\n        return Collection.fromPaths([path]).closestScope().findJSXElements(id).paths();\n      }\n    });\n  }\n};\nconst filterMethods = {\n  /**\n   * Filter method for attributes.\n   *\n   * @param {Object} attributeFilter\n   * @return {function}\n   */\n  hasAttributes: function (attributeFilter) {\n    const attributeNames = Object.keys(attributeFilter);\n    return function filter(path) {\n      if (!JSXElement.check(path.value)) {\n        return false;\n      }\n\n      const elementAttributes = Object.create(null);\n      path.value.openingElement.attributes.forEach(function (attr) {\n        if (!JSXAttribute.check(attr) || !(attr.name.name in attributeFilter)) {\n          return;\n        }\n\n        elementAttributes[attr.name.name] = attr;\n      });\n      return attributeNames.every(function (name) {\n        if (!(name in elementAttributes)) {\n          return false;\n        }\n\n        const value = elementAttributes[name].value;\n        const expected = attributeFilter[name]; // Only when value is truthy access it's properties\n\n        const actual = !value ? value : Literal.check(value) ? value.value : value.expression;\n\n        if (typeof expected === 'function') {\n          return expected(actual);\n        } // Literal attribute values are always strings\n\n\n        return String(expected) === actual;\n      });\n    };\n  },\n\n  /**\n   * Filter elements which contain a specific child type\n   *\n   * @param {string} name\n   * @return {function}\n   */\n  hasChildren: function (name) {\n    return function filter(path) {\n      return JSXElement.check(path.value) && path.value.children.some(child => JSXElement.check(child) && child.openingElement.name.name === name);\n    };\n  }\n};\n/**\n* @mixin\n*/\n\nconst traversalMethods = {\n  /**\n   * Returns all child nodes, including literals and expressions.\n   *\n   * @return {Collection}\n   */\n  childNodes: function () {\n    const paths = [];\n    this.forEach(function (path) {\n      const children = path.get('children');\n      const l = children.value.length;\n\n      for (let i = 0; i < l; i++) {\n        paths.push(children.get(i));\n      }\n    });\n    return Collection.fromPaths(paths, this);\n  },\n\n  /**\n   * Returns all children that are JSXElements.\n   *\n   * @return {JSXElementCollection}\n   */\n  childElements: function () {\n    const paths = [];\n    this.forEach(function (path) {\n      const children = path.get('children');\n      const l = children.value.length;\n\n      for (let i = 0; i < l; i++) {\n        if (types.JSXElement.check(children.value[i])) {\n          paths.push(children.get(i));\n        }\n      }\n    });\n    return Collection.fromPaths(paths, this, JSXElement);\n  }\n};\nconst mappingMethods = {\n  /**\n   * Given a JSXElement, returns its \"root\" name. E.g. it would return \"Foo\" for\n   * both <Foo /> and <Foo.Bar />.\n   *\n   * @param {NodePath} path\n   * @return {string}\n   */\n  getRootName: function (path) {\n    let name = path.value.openingElement.name;\n\n    while (types.JSXMemberExpression.check(name)) {\n      name = name.object;\n    }\n\n    return name && name.name || null;\n  }\n};\n\nfunction register() {\n  NodeCollection.register();\n  Collection.registerMethods(globalMethods, types.Node);\n  Collection.registerMethods(traversalMethods, JSXElement);\n}\n\nexports.register = once(register);\nexports.filters = filterMethods;\nexports.mappings = mappingMethods;","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/jbook/node_modules/jscodeshift/src/collections/JSXElement.js"],"names":["Collection","require","NodeCollection","assert","once","recast","requiresModule","filters","types","namedTypes","JSXElement","JSXAttribute","Literal","globalMethods","findJSXElements","name","nameFilter","openingElement","find","findJSXElementsByModuleName","moduleName","ok","VariableDeclarator","filter","map","path","id","value","fromPaths","closestScope","paths","filterMethods","hasAttributes","attributeFilter","attributeNames","Object","keys","check","elementAttributes","create","attributes","forEach","attr","every","expected","actual","expression","String","hasChildren","children","some","child","traversalMethods","childNodes","get","l","length","i","push","childElements","mappingMethods","getRootName","JSXMemberExpression","object","register","registerMethods","Node","exports","mappings"],"mappings":"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","sourcesContent":["\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst Collection = require('../Collection');\nconst NodeCollection = require('./Node');\n\nconst assert = require('assert');\nconst once = require('../utils/once');\nconst recast = require('recast');\nconst requiresModule = require('./VariableDeclarator').filters.requiresModule;\n\nconst types = recast.types.namedTypes;\nconst JSXElement = types.JSXElement;\nconst JSXAttribute = types.JSXAttribute;\nconst Literal = types.Literal;\n\n/**\n * Contains filter methods and mutation methods for processing JSXElements.\n * @mixin\n */\nconst globalMethods = {\n  /**\n   * Finds all JSXElements optionally filtered by name\n   *\n   * @param {string} name\n   * @return {Collection}\n   */\n  findJSXElements: function(name) {\n    const nameFilter = name && {openingElement: {name: {name: name}}};\n    return this.find(JSXElement, nameFilter);\n  },\n\n  /**\n   * Finds all JSXElements by module name. Given\n   *\n   *     var Bar = require('Foo');\n   *     <Bar />\n   *\n   * findJSXElementsByModuleName('Foo') will find <Bar />, without having to\n   * know the variable name.\n   */\n  findJSXElementsByModuleName: function(moduleName) {\n    assert.ok(\n      moduleName && typeof moduleName === 'string',\n      'findJSXElementsByModuleName(...) needs a name to look for'\n    );\n\n    return this.find(types.VariableDeclarator)\n      .filter(requiresModule(moduleName))\n      .map(function(path) {\n        const id = path.value.id.name;\n        if (id) {\n          return Collection.fromPaths([path])\n            .closestScope()\n            .findJSXElements(id)\n            .paths();\n        }\n      });\n  }\n};\n\nconst filterMethods = {\n\n  /**\n   * Filter method for attributes.\n   *\n   * @param {Object} attributeFilter\n   * @return {function}\n   */\n  hasAttributes: function(attributeFilter) {\n    const attributeNames = Object.keys(attributeFilter);\n    return function filter(path) {\n      if (!JSXElement.check(path.value)) {\n        return false;\n      }\n      const elementAttributes = Object.create(null);\n      path.value.openingElement.attributes.forEach(function(attr) {\n        if (!JSXAttribute.check(attr) ||\n          !(attr.name.name in attributeFilter)) {\n          return;\n        }\n        elementAttributes[attr.name.name] = attr;\n      });\n\n      return attributeNames.every(function(name) {\n        if (!(name in elementAttributes) ){\n          return false;\n        }\n\n        const value = elementAttributes[name].value;\n        const expected = attributeFilter[name];\n\n        // Only when value is truthy access it's properties\n        const actual = !value\n          ? value\n          : Literal.check(value)\n          ? value.value\n          : value.expression;\n\n        if (typeof expected === 'function') {\n          return expected(actual);\n        }\n\n         // Literal attribute values are always strings\n        return String(expected) === actual;\n      });\n    };\n  },\n\n  /**\n   * Filter elements which contain a specific child type\n   *\n   * @param {string} name\n   * @return {function}\n   */\n  hasChildren: function(name) {\n    return function filter(path) {\n      return JSXElement.check(path.value) &&\n        path.value.children.some(\n          child => JSXElement.check(child) &&\n                   child.openingElement.name.name === name\n        );\n    };\n  }\n};\n\n/**\n* @mixin\n*/\nconst traversalMethods = {\n\n  /**\n   * Returns all child nodes, including literals and expressions.\n   *\n   * @return {Collection}\n   */\n  childNodes: function() {\n    const paths = [];\n    this.forEach(function(path) {\n      const children = path.get('children');\n      const l = children.value.length;\n      for (let i = 0; i < l; i++) {\n        paths.push(children.get(i));\n      }\n    });\n    return Collection.fromPaths(paths, this);\n  },\n\n  /**\n   * Returns all children that are JSXElements.\n   *\n   * @return {JSXElementCollection}\n   */\n  childElements: function() {\n    const paths = [];\n    this.forEach(function(path) {\n      const children = path.get('children');\n      const l = children.value.length;\n      for (let i = 0; i < l; i++) {\n        if (types.JSXElement.check(children.value[i])) {\n          paths.push(children.get(i));\n        }\n      }\n    });\n    return Collection.fromPaths(paths, this, JSXElement);\n  },\n};\n\nconst mappingMethods = {\n  /**\n   * Given a JSXElement, returns its \"root\" name. E.g. it would return \"Foo\" for\n   * both <Foo /> and <Foo.Bar />.\n   *\n   * @param {NodePath} path\n   * @return {string}\n   */\n  getRootName: function(path) {\n    let name = path.value.openingElement.name;\n    while (types.JSXMemberExpression.check(name)) {\n      name = name.object;\n    }\n\n    return name && name.name || null;\n  }\n};\n\nfunction register() {\n  NodeCollection.register();\n  Collection.registerMethods(globalMethods, types.Node);\n  Collection.registerMethods(traversalMethods, JSXElement);\n}\n\nexports.register = once(register);\nexports.filters = filterMethods;\nexports.mappings = mappingMethods;\n"]},"metadata":{},"sourceType":"script"}