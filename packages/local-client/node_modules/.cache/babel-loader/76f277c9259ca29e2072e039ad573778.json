{"ast":null,"code":"import getSurroundingWord from './getSurroundingWord';\nexport function selectWord(_ref) {\n  var text = _ref.text,\n      selection = _ref.selection;\n\n  if (text && text.length && selection.start === selection.end) {\n    // the user is pointing to a word\n    return getSurroundingWord(text, selection.start);\n  }\n\n  return selection;\n}\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\n\nexport function getBreaksNeededForEmptyLineBefore() {\n  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  var startPosition = arguments.length > 1 ? arguments[1] : undefined;\n  if (startPosition === 0) return 0; // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInFirstLine = true;\n\n  for (var i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        // blank space\n        continue;\n\n      case 10:\n        // line break\n        neededBreaks--;\n        isInFirstLine = false;\n        break;\n\n      default:\n        return neededBreaks;\n    }\n  }\n\n  return isInFirstLine ? 0 : neededBreaks;\n}\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\n\nexport function getBreaksNeededForEmptyLineAfter() {\n  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  var startPosition = arguments.length > 1 ? arguments[1] : undefined;\n  if (startPosition === text.length - 1) return 0; // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInLastLine = true;\n\n  for (var i = startPosition; i < text.length && neededBreaks >= 0; i++) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        continue;\n\n      case 10:\n        {\n          neededBreaks--;\n          isInLastLine = false;\n          break;\n        }\n\n      default:\n        return neededBreaks;\n    }\n  }\n\n  return isInLastLine ? 0 : neededBreaks;\n}","map":{"version":3,"sources":["../../../src/utils/markdownUtils.ts"],"names":["text","selection","getSurroundingWord","startPosition","neededBreaks","isInFirstLine","i","isInLastLine"],"mappings":"AACA,OAAA,kBAAA,MAAA,sBAAA;AAOA,OAAO,SAAA,UAAA,CAAA,IAAA,EAAiE;AAAA,MAA3CA,IAA2C,GAAA,IAAA,CAA3CA,IAA2C;AAAA,MAArCC,SAAqC,GAAA,IAAA,CAArCA,SAAqC;;AACtE,MAAID,IAAI,IAAIA,IAAI,CAAZA,MAAAA,IAAuBC,SAAS,CAATA,KAAAA,KAAoBA,SAAS,CAAxD,GAAA,EAA8D;AAC5D;AACA,WAAOC,kBAAkB,CAAA,IAAA,EAAOD,SAAS,CAAzC,KAAyB,CAAzB;AACD;;AACD,SAAA,SAAA;AACD;AAED;AACA;AACA;AACA;;AACA,OAAO,SAAA,iCAAA,GAAqF;AAAA,MAA1CD,IAA0C,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAnC,EAAmC;AAAA,MAA/BG,aAA+B,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAA,SAAA;AAC1F,MAAIA,aAAa,KAAjB,CAAA,EAAyB,OADiE,CACjE,CADiE,CAG1F;AACA;AACA;AACA;;AAEA,MAAIC,YAAY,GAAhB,CAAA;AACA,MAAIC,aAAa,GAAjB,IAAA;;AACA,OAAK,IAAIC,CAAC,GAAGH,aAAa,GAA1B,CAAA,EAAgCG,CAAC,IAADA,CAAAA,IAAWF,YAAY,IAAvD,CAAA,EAA+DE,CAA/D,EAAA,EAAoE;AAClE,YAAQN,IAAI,CAAJA,UAAAA,CAAR,CAAQA,CAAR;AACE,WAAA,EAAA;AAAS;AACP;;AACF,WAAA,EAAA;AAAS;AACPI,QAAAA,YAAY;AACZC,QAAAA,aAAa,GAAbA,KAAAA;AACA;;AACF;AACE,eAAA,YAAA;AARJ;AAUD;;AACD,SAAOA,aAAa,GAAA,CAAA,GAApB,YAAA;AACD;AAED;AACA;AACA;AACA;;AACA,OAAO,SAAA,gCAAA,GAAoF;AAAA,MAA1CL,IAA0C,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAnC,EAAmC;AAAA,MAA/BG,aAA+B,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAA,SAAA;AACzF,MAAIA,aAAa,KAAKH,IAAI,CAAJA,MAAAA,GAAtB,CAAA,EAAuC,OADkD,CAClD,CADkD,CAGzF;AACA;AACA;AACA;;AAEA,MAAII,YAAY,GAAhB,CAAA;AACA,MAAIG,YAAY,GAAhB,IAAA;;AACA,OAAK,IAAID,CAAC,GAAV,aAAA,EAA4BA,CAAC,GAAGN,IAAI,CAARM,MAAAA,IAAoBF,YAAY,IAA5D,CAAA,EAAoEE,CAApE,EAAA,EAAyE;AACvE,YAAQN,IAAI,CAAJA,UAAAA,CAAR,CAAQA,CAAR;AACE,WAAA,EAAA;AACE;;AACF,WAAA,EAAA;AAAS;AACPI,UAAAA,YAAY;AACZG,UAAAA,YAAY,GAAZA,KAAAA;AACA;AACD;;AACD;AACE,eAAA,YAAA;AATJ;AAWD;;AACD,SAAOA,YAAY,GAAA,CAAA,GAAnB,YAAA;AACD","sourcesContent":["import { TextRange } from '../commands';\nimport getSurroundingWord from './getSurroundingWord';\n\nexport interface TextSection {\n  text: string;\n  selection: TextRange;\n}\n\nexport function selectWord({ text, selection }: TextSection): TextRange {\n  if (text && text.length && selection.start === selection.end) {\n    // the user is pointing to a word\n    return getSurroundingWord(text, selection.start);\n  }\n  return selection;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\nexport function getBreaksNeededForEmptyLineBefore(text = \"\", startPosition: number): number {\n  if (startPosition === 0) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  let neededBreaks = 2;\n  let isInFirstLine = true;\n  for (let i = startPosition - 1; i >= 0 && (neededBreaks >= 0); i--) {\n    switch (text.charCodeAt(i)) {\n      case 32: // blank space\n        continue;\n      case 10: // line break\n        neededBreaks--;\n        isInFirstLine = false;\n        break;\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInFirstLine ? 0 : neededBreaks;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\nexport function getBreaksNeededForEmptyLineAfter(text = \"\", startPosition: number): number {\n  if (startPosition === text.length - 1) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  let neededBreaks = 2;\n  let isInLastLine = true;\n  for (let i = startPosition; i < text.length && (neededBreaks >= 0); i++) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        continue;\n      case 10: {\n        neededBreaks--;\n        isInLastLine = false;\n        break;\n      }\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInLastLine ? 0 : neededBreaks;\n}\n"]},"metadata":{},"sourceType":"module"}