{"ast":null,"code":"\"use strict\";\n\n;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\n\nvar node_path_1 = tslib_1.__importDefault(require(\"./node-path\"));\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction pathVisitorPlugin(fork) {\n  var types = fork.use(types_1.default);\n  var NodePath = fork.use(node_path_1.default);\n  var isArray = types.builtInTypes.array;\n  var isObject = types.builtInTypes.object;\n  var isFunction = types.builtInTypes.function;\n  var undefined;\n\n  var PathVisitor = function PathVisitor() {\n    if (!(this instanceof PathVisitor)) {\n      throw new Error(\"PathVisitor constructor cannot be invoked without 'new'\");\n    } // Permanent state.\n\n\n    this._reusableContextStack = [];\n    this._methodNameTable = computeMethodNameTable(this);\n    this._shouldVisitComments = hasOwn.call(this._methodNameTable, \"Block\") || hasOwn.call(this._methodNameTable, \"Line\");\n    this.Context = makeContextConstructor(this); // State reset every time PathVisitor.prototype.visit is called.\n\n    this._visiting = false;\n    this._changeReported = false;\n  };\n\n  function computeMethodNameTable(visitor) {\n    var typeNames = Object.create(null);\n\n    for (var methodName in visitor) {\n      if (/^visit[A-Z]/.test(methodName)) {\n        typeNames[methodName.slice(\"visit\".length)] = true;\n      }\n    }\n\n    var supertypeTable = types.computeSupertypeLookupTable(typeNames);\n    var methodNameTable = Object.create(null);\n    var typeNameKeys = Object.keys(supertypeTable);\n    var typeNameCount = typeNameKeys.length;\n\n    for (var i = 0; i < typeNameCount; ++i) {\n      var typeName = typeNameKeys[i];\n      methodName = \"visit\" + supertypeTable[typeName];\n\n      if (isFunction.check(visitor[methodName])) {\n        methodNameTable[typeName] = methodName;\n      }\n    }\n\n    return methodNameTable;\n  }\n\n  PathVisitor.fromMethodsObject = function fromMethodsObject(methods) {\n    if (methods instanceof PathVisitor) {\n      return methods;\n    }\n\n    if (!isObject.check(methods)) {\n      // An empty visitor?\n      return new PathVisitor();\n    }\n\n    var Visitor = function Visitor() {\n      if (!(this instanceof Visitor)) {\n        throw new Error(\"Visitor constructor cannot be invoked without 'new'\");\n      }\n\n      PathVisitor.call(this);\n    };\n\n    var Vp = Visitor.prototype = Object.create(PVp);\n    Vp.constructor = Visitor;\n    extend(Vp, methods);\n    extend(Visitor, PathVisitor);\n    isFunction.assert(Visitor.fromMethodsObject);\n    isFunction.assert(Visitor.visit);\n    return new Visitor();\n  };\n\n  function extend(target, source) {\n    for (var property in source) {\n      if (hasOwn.call(source, property)) {\n        target[property] = source[property];\n      }\n    }\n\n    return target;\n  }\n\n  PathVisitor.visit = function visit(node, methods) {\n    return PathVisitor.fromMethodsObject(methods).visit(node);\n  };\n\n  var PVp = PathVisitor.prototype;\n\n  PVp.visit = function () {\n    if (this._visiting) {\n      throw new Error(\"Recursively calling visitor.visit(path) resets visitor state. \" + \"Try this.visit(path) or this.traverse(path) instead.\");\n    } // Private state that needs to be reset before every traversal.\n\n\n    this._visiting = true;\n    this._changeReported = false;\n    this._abortRequested = false;\n    var argc = arguments.length;\n    var args = new Array(argc);\n\n    for (var i = 0; i < argc; ++i) {\n      args[i] = arguments[i];\n    }\n\n    if (!(args[0] instanceof NodePath)) {\n      args[0] = new NodePath({\n        root: args[0]\n      }).get(\"root\");\n    } // Called with the same arguments as .visit.\n\n\n    this.reset.apply(this, args);\n    var didNotThrow;\n\n    try {\n      var root = this.visitWithoutReset(args[0]);\n      didNotThrow = true;\n    } finally {\n      this._visiting = false;\n\n      if (!didNotThrow && this._abortRequested) {\n        // If this.visitWithoutReset threw an exception and\n        // this._abortRequested was set to true, return the root of\n        // the AST instead of letting the exception propagate, so that\n        // client code does not have to provide a try-catch block to\n        // intercept the AbortRequest exception.  Other kinds of\n        // exceptions will propagate without being intercepted and\n        // rethrown by a catch block, so their stacks will accurately\n        // reflect the original throwing context.\n        return args[0].value;\n      }\n    }\n\n    return root;\n  };\n\n  PVp.AbortRequest = function AbortRequest() {};\n\n  PVp.abort = function () {\n    var visitor = this;\n    visitor._abortRequested = true;\n    var request = new visitor.AbortRequest(); // If you decide to catch this exception and stop it from propagating,\n    // make sure to call its cancel method to avoid silencing other\n    // exceptions that might be thrown later in the traversal.\n\n    request.cancel = function () {\n      visitor._abortRequested = false;\n    };\n\n    throw request;\n  };\n\n  PVp.reset = function (_path\n  /*, additional arguments */\n  ) {// Empty stub; may be reassigned or overridden by subclasses.\n  };\n\n  PVp.visitWithoutReset = function (path) {\n    if (this instanceof this.Context) {\n      // Since this.Context.prototype === this, there's a chance we\n      // might accidentally call context.visitWithoutReset. If that\n      // happens, re-invoke the method against context.visitor.\n      return this.visitor.visitWithoutReset(path);\n    }\n\n    if (!(path instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n\n    var value = path.value;\n    var methodName = value && typeof value === \"object\" && typeof value.type === \"string\" && this._methodNameTable[value.type];\n\n    if (methodName) {\n      var context = this.acquireContext(path);\n\n      try {\n        return context.invokeVisitorMethod(methodName);\n      } finally {\n        this.releaseContext(context);\n      }\n    } else {\n      // If there was no visitor method to call, visit the children of\n      // this node generically.\n      return visitChildren(path, this);\n    }\n  };\n\n  function visitChildren(path, visitor) {\n    if (!(path instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n\n    if (!(visitor instanceof PathVisitor)) {\n      throw new Error(\"\");\n    }\n\n    var value = path.value;\n\n    if (isArray.check(value)) {\n      path.each(visitor.visitWithoutReset, visitor);\n    } else if (!isObject.check(value)) {// No children to visit.\n    } else {\n      var childNames = types.getFieldNames(value); // The .comments field of the Node type is hidden, so we only\n      // visit it if the visitor defines visitBlock or visitLine, and\n      // value.comments is defined.\n\n      if (visitor._shouldVisitComments && value.comments && childNames.indexOf(\"comments\") < 0) {\n        childNames.push(\"comments\");\n      }\n\n      var childCount = childNames.length;\n      var childPaths = [];\n\n      for (var i = 0; i < childCount; ++i) {\n        var childName = childNames[i];\n\n        if (!hasOwn.call(value, childName)) {\n          value[childName] = types.getFieldValue(value, childName);\n        }\n\n        childPaths.push(path.get(childName));\n      }\n\n      for (var i = 0; i < childCount; ++i) {\n        visitor.visitWithoutReset(childPaths[i]);\n      }\n    }\n\n    return path.value;\n  }\n\n  PVp.acquireContext = function (path) {\n    if (this._reusableContextStack.length === 0) {\n      return new this.Context(path);\n    }\n\n    return this._reusableContextStack.pop().reset(path);\n  };\n\n  PVp.releaseContext = function (context) {\n    if (!(context instanceof this.Context)) {\n      throw new Error(\"\");\n    }\n\n    this._reusableContextStack.push(context);\n\n    context.currentPath = null;\n  };\n\n  PVp.reportChanged = function () {\n    this._changeReported = true;\n  };\n\n  PVp.wasChangeReported = function () {\n    return this._changeReported;\n  };\n\n  function makeContextConstructor(visitor) {\n    function Context(path) {\n      if (!(this instanceof Context)) {\n        throw new Error(\"\");\n      }\n\n      if (!(this instanceof PathVisitor)) {\n        throw new Error(\"\");\n      }\n\n      if (!(path instanceof NodePath)) {\n        throw new Error(\"\");\n      }\n\n      Object.defineProperty(this, \"visitor\", {\n        value: visitor,\n        writable: false,\n        enumerable: true,\n        configurable: false\n      });\n      this.currentPath = path;\n      this.needToCallTraverse = true;\n      Object.seal(this);\n    }\n\n    if (!(visitor instanceof PathVisitor)) {\n      throw new Error(\"\");\n    } // Note that the visitor object is the prototype of Context.prototype,\n    // so all visitor methods are inherited by context objects.\n\n\n    var Cp = Context.prototype = Object.create(visitor);\n    Cp.constructor = Context;\n    extend(Cp, sharedContextProtoMethods);\n    return Context;\n  } // Every PathVisitor has a different this.Context constructor and\n  // this.Context.prototype object, but those prototypes can all use the\n  // same reset, invokeVisitorMethod, and traverse function objects.\n\n\n  var sharedContextProtoMethods = Object.create(null);\n\n  sharedContextProtoMethods.reset = function reset(path) {\n    if (!(this instanceof this.Context)) {\n      throw new Error(\"\");\n    }\n\n    if (!(path instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n\n    this.currentPath = path;\n    this.needToCallTraverse = true;\n    return this;\n  };\n\n  sharedContextProtoMethods.invokeVisitorMethod = function invokeVisitorMethod(methodName) {\n    if (!(this instanceof this.Context)) {\n      throw new Error(\"\");\n    }\n\n    if (!(this.currentPath instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n\n    var result = this.visitor[methodName].call(this, this.currentPath);\n\n    if (result === false) {\n      // Visitor methods return false to indicate that they have handled\n      // their own traversal needs, and we should not complain if\n      // this.needToCallTraverse is still true.\n      this.needToCallTraverse = false;\n    } else if (result !== undefined) {\n      // Any other non-undefined value returned from the visitor method\n      // is interpreted as a replacement value.\n      this.currentPath = this.currentPath.replace(result)[0];\n\n      if (this.needToCallTraverse) {\n        // If this.traverse still hasn't been called, visit the\n        // children of the replacement node.\n        this.traverse(this.currentPath);\n      }\n    }\n\n    if (this.needToCallTraverse !== false) {\n      throw new Error(\"Must either call this.traverse or return false in \" + methodName);\n    }\n\n    var path = this.currentPath;\n    return path && path.value;\n  };\n\n  sharedContextProtoMethods.traverse = function traverse(path, newVisitor) {\n    if (!(this instanceof this.Context)) {\n      throw new Error(\"\");\n    }\n\n    if (!(path instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n\n    if (!(this.currentPath instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n\n    this.needToCallTraverse = false;\n    return visitChildren(path, PathVisitor.fromMethodsObject(newVisitor || this.visitor));\n  };\n\n  sharedContextProtoMethods.visit = function visit(path, newVisitor) {\n    if (!(this instanceof this.Context)) {\n      throw new Error(\"\");\n    }\n\n    if (!(path instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n\n    if (!(this.currentPath instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n\n    this.needToCallTraverse = false;\n    return PathVisitor.fromMethodsObject(newVisitor || this.visitor).visitWithoutReset(path);\n  };\n\n  sharedContextProtoMethods.reportChanged = function reportChanged() {\n    this.visitor.reportChanged();\n  };\n\n  sharedContextProtoMethods.abort = function abort() {\n    this.needToCallTraverse = false;\n    this.visitor.abort();\n  };\n\n  return PathVisitor;\n}\n\nexports.default = pathVisitorPlugin;\nmodule.exports = exports[\"default\"];","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/github/react-snippy/node_modules/jscodeshift/node_modules/ast-types/lib/path-visitor.js"],"names":["Object","defineProperty","exports","value","tslib_1","require","types_1","__importDefault","node_path_1","hasOwn","prototype","hasOwnProperty","pathVisitorPlugin","fork","types","use","default","NodePath","isArray","builtInTypes","array","isObject","object","isFunction","function","undefined","PathVisitor","Error","_reusableContextStack","_methodNameTable","computeMethodNameTable","_shouldVisitComments","call","Context","makeContextConstructor","_visiting","_changeReported","visitor","typeNames","create","methodName","test","slice","length","supertypeTable","computeSupertypeLookupTable","methodNameTable","typeNameKeys","keys","typeNameCount","i","typeName","check","fromMethodsObject","methods","Visitor","Vp","PVp","constructor","extend","assert","visit","target","source","property","node","_abortRequested","argc","arguments","args","Array","root","get","reset","apply","didNotThrow","visitWithoutReset","AbortRequest","abort","request","cancel","_path","path","type","context","acquireContext","invokeVisitorMethod","releaseContext","visitChildren","each","childNames","getFieldNames","comments","indexOf","push","childCount","childPaths","childName","getFieldValue","pop","currentPath","reportChanged","wasChangeReported","writable","enumerable","configurable","needToCallTraverse","seal","Cp","sharedContextProtoMethods","result","replace","traverse","newVisitor","module"],"mappings":"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","sourcesContent":["\"use strict\";;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\nvar node_path_1 = tslib_1.__importDefault(require(\"./node-path\"));\nvar hasOwn = Object.prototype.hasOwnProperty;\nfunction pathVisitorPlugin(fork) {\n    var types = fork.use(types_1.default);\n    var NodePath = fork.use(node_path_1.default);\n    var isArray = types.builtInTypes.array;\n    var isObject = types.builtInTypes.object;\n    var isFunction = types.builtInTypes.function;\n    var undefined;\n    var PathVisitor = function PathVisitor() {\n        if (!(this instanceof PathVisitor)) {\n            throw new Error(\"PathVisitor constructor cannot be invoked without 'new'\");\n        }\n        // Permanent state.\n        this._reusableContextStack = [];\n        this._methodNameTable = computeMethodNameTable(this);\n        this._shouldVisitComments =\n            hasOwn.call(this._methodNameTable, \"Block\") ||\n                hasOwn.call(this._methodNameTable, \"Line\");\n        this.Context = makeContextConstructor(this);\n        // State reset every time PathVisitor.prototype.visit is called.\n        this._visiting = false;\n        this._changeReported = false;\n    };\n    function computeMethodNameTable(visitor) {\n        var typeNames = Object.create(null);\n        for (var methodName in visitor) {\n            if (/^visit[A-Z]/.test(methodName)) {\n                typeNames[methodName.slice(\"visit\".length)] = true;\n            }\n        }\n        var supertypeTable = types.computeSupertypeLookupTable(typeNames);\n        var methodNameTable = Object.create(null);\n        var typeNameKeys = Object.keys(supertypeTable);\n        var typeNameCount = typeNameKeys.length;\n        for (var i = 0; i < typeNameCount; ++i) {\n            var typeName = typeNameKeys[i];\n            methodName = \"visit\" + supertypeTable[typeName];\n            if (isFunction.check(visitor[methodName])) {\n                methodNameTable[typeName] = methodName;\n            }\n        }\n        return methodNameTable;\n    }\n    PathVisitor.fromMethodsObject = function fromMethodsObject(methods) {\n        if (methods instanceof PathVisitor) {\n            return methods;\n        }\n        if (!isObject.check(methods)) {\n            // An empty visitor?\n            return new PathVisitor;\n        }\n        var Visitor = function Visitor() {\n            if (!(this instanceof Visitor)) {\n                throw new Error(\"Visitor constructor cannot be invoked without 'new'\");\n            }\n            PathVisitor.call(this);\n        };\n        var Vp = Visitor.prototype = Object.create(PVp);\n        Vp.constructor = Visitor;\n        extend(Vp, methods);\n        extend(Visitor, PathVisitor);\n        isFunction.assert(Visitor.fromMethodsObject);\n        isFunction.assert(Visitor.visit);\n        return new Visitor;\n    };\n    function extend(target, source) {\n        for (var property in source) {\n            if (hasOwn.call(source, property)) {\n                target[property] = source[property];\n            }\n        }\n        return target;\n    }\n    PathVisitor.visit = function visit(node, methods) {\n        return PathVisitor.fromMethodsObject(methods).visit(node);\n    };\n    var PVp = PathVisitor.prototype;\n    PVp.visit = function () {\n        if (this._visiting) {\n            throw new Error(\"Recursively calling visitor.visit(path) resets visitor state. \" +\n                \"Try this.visit(path) or this.traverse(path) instead.\");\n        }\n        // Private state that needs to be reset before every traversal.\n        this._visiting = true;\n        this._changeReported = false;\n        this._abortRequested = false;\n        var argc = arguments.length;\n        var args = new Array(argc);\n        for (var i = 0; i < argc; ++i) {\n            args[i] = arguments[i];\n        }\n        if (!(args[0] instanceof NodePath)) {\n            args[0] = new NodePath({ root: args[0] }).get(\"root\");\n        }\n        // Called with the same arguments as .visit.\n        this.reset.apply(this, args);\n        var didNotThrow;\n        try {\n            var root = this.visitWithoutReset(args[0]);\n            didNotThrow = true;\n        }\n        finally {\n            this._visiting = false;\n            if (!didNotThrow && this._abortRequested) {\n                // If this.visitWithoutReset threw an exception and\n                // this._abortRequested was set to true, return the root of\n                // the AST instead of letting the exception propagate, so that\n                // client code does not have to provide a try-catch block to\n                // intercept the AbortRequest exception.  Other kinds of\n                // exceptions will propagate without being intercepted and\n                // rethrown by a catch block, so their stacks will accurately\n                // reflect the original throwing context.\n                return args[0].value;\n            }\n        }\n        return root;\n    };\n    PVp.AbortRequest = function AbortRequest() { };\n    PVp.abort = function () {\n        var visitor = this;\n        visitor._abortRequested = true;\n        var request = new visitor.AbortRequest();\n        // If you decide to catch this exception and stop it from propagating,\n        // make sure to call its cancel method to avoid silencing other\n        // exceptions that might be thrown later in the traversal.\n        request.cancel = function () {\n            visitor._abortRequested = false;\n        };\n        throw request;\n    };\n    PVp.reset = function (_path /*, additional arguments */) {\n        // Empty stub; may be reassigned or overridden by subclasses.\n    };\n    PVp.visitWithoutReset = function (path) {\n        if (this instanceof this.Context) {\n            // Since this.Context.prototype === this, there's a chance we\n            // might accidentally call context.visitWithoutReset. If that\n            // happens, re-invoke the method against context.visitor.\n            return this.visitor.visitWithoutReset(path);\n        }\n        if (!(path instanceof NodePath)) {\n            throw new Error(\"\");\n        }\n        var value = path.value;\n        var methodName = value &&\n            typeof value === \"object\" &&\n            typeof value.type === \"string\" &&\n            this._methodNameTable[value.type];\n        if (methodName) {\n            var context = this.acquireContext(path);\n            try {\n                return context.invokeVisitorMethod(methodName);\n            }\n            finally {\n                this.releaseContext(context);\n            }\n        }\n        else {\n            // If there was no visitor method to call, visit the children of\n            // this node generically.\n            return visitChildren(path, this);\n        }\n    };\n    function visitChildren(path, visitor) {\n        if (!(path instanceof NodePath)) {\n            throw new Error(\"\");\n        }\n        if (!(visitor instanceof PathVisitor)) {\n            throw new Error(\"\");\n        }\n        var value = path.value;\n        if (isArray.check(value)) {\n            path.each(visitor.visitWithoutReset, visitor);\n        }\n        else if (!isObject.check(value)) {\n            // No children to visit.\n        }\n        else {\n            var childNames = types.getFieldNames(value);\n            // The .comments field of the Node type is hidden, so we only\n            // visit it if the visitor defines visitBlock or visitLine, and\n            // value.comments is defined.\n            if (visitor._shouldVisitComments &&\n                value.comments &&\n                childNames.indexOf(\"comments\") < 0) {\n                childNames.push(\"comments\");\n            }\n            var childCount = childNames.length;\n            var childPaths = [];\n            for (var i = 0; i < childCount; ++i) {\n                var childName = childNames[i];\n                if (!hasOwn.call(value, childName)) {\n                    value[childName] = types.getFieldValue(value, childName);\n                }\n                childPaths.push(path.get(childName));\n            }\n            for (var i = 0; i < childCount; ++i) {\n                visitor.visitWithoutReset(childPaths[i]);\n            }\n        }\n        return path.value;\n    }\n    PVp.acquireContext = function (path) {\n        if (this._reusableContextStack.length === 0) {\n            return new this.Context(path);\n        }\n        return this._reusableContextStack.pop().reset(path);\n    };\n    PVp.releaseContext = function (context) {\n        if (!(context instanceof this.Context)) {\n            throw new Error(\"\");\n        }\n        this._reusableContextStack.push(context);\n        context.currentPath = null;\n    };\n    PVp.reportChanged = function () {\n        this._changeReported = true;\n    };\n    PVp.wasChangeReported = function () {\n        return this._changeReported;\n    };\n    function makeContextConstructor(visitor) {\n        function Context(path) {\n            if (!(this instanceof Context)) {\n                throw new Error(\"\");\n            }\n            if (!(this instanceof PathVisitor)) {\n                throw new Error(\"\");\n            }\n            if (!(path instanceof NodePath)) {\n                throw new Error(\"\");\n            }\n            Object.defineProperty(this, \"visitor\", {\n                value: visitor,\n                writable: false,\n                enumerable: true,\n                configurable: false\n            });\n            this.currentPath = path;\n            this.needToCallTraverse = true;\n            Object.seal(this);\n        }\n        if (!(visitor instanceof PathVisitor)) {\n            throw new Error(\"\");\n        }\n        // Note that the visitor object is the prototype of Context.prototype,\n        // so all visitor methods are inherited by context objects.\n        var Cp = Context.prototype = Object.create(visitor);\n        Cp.constructor = Context;\n        extend(Cp, sharedContextProtoMethods);\n        return Context;\n    }\n    // Every PathVisitor has a different this.Context constructor and\n    // this.Context.prototype object, but those prototypes can all use the\n    // same reset, invokeVisitorMethod, and traverse function objects.\n    var sharedContextProtoMethods = Object.create(null);\n    sharedContextProtoMethods.reset =\n        function reset(path) {\n            if (!(this instanceof this.Context)) {\n                throw new Error(\"\");\n            }\n            if (!(path instanceof NodePath)) {\n                throw new Error(\"\");\n            }\n            this.currentPath = path;\n            this.needToCallTraverse = true;\n            return this;\n        };\n    sharedContextProtoMethods.invokeVisitorMethod =\n        function invokeVisitorMethod(methodName) {\n            if (!(this instanceof this.Context)) {\n                throw new Error(\"\");\n            }\n            if (!(this.currentPath instanceof NodePath)) {\n                throw new Error(\"\");\n            }\n            var result = this.visitor[methodName].call(this, this.currentPath);\n            if (result === false) {\n                // Visitor methods return false to indicate that they have handled\n                // their own traversal needs, and we should not complain if\n                // this.needToCallTraverse is still true.\n                this.needToCallTraverse = false;\n            }\n            else if (result !== undefined) {\n                // Any other non-undefined value returned from the visitor method\n                // is interpreted as a replacement value.\n                this.currentPath = this.currentPath.replace(result)[0];\n                if (this.needToCallTraverse) {\n                    // If this.traverse still hasn't been called, visit the\n                    // children of the replacement node.\n                    this.traverse(this.currentPath);\n                }\n            }\n            if (this.needToCallTraverse !== false) {\n                throw new Error(\"Must either call this.traverse or return false in \" + methodName);\n            }\n            var path = this.currentPath;\n            return path && path.value;\n        };\n    sharedContextProtoMethods.traverse =\n        function traverse(path, newVisitor) {\n            if (!(this instanceof this.Context)) {\n                throw new Error(\"\");\n            }\n            if (!(path instanceof NodePath)) {\n                throw new Error(\"\");\n            }\n            if (!(this.currentPath instanceof NodePath)) {\n                throw new Error(\"\");\n            }\n            this.needToCallTraverse = false;\n            return visitChildren(path, PathVisitor.fromMethodsObject(newVisitor || this.visitor));\n        };\n    sharedContextProtoMethods.visit =\n        function visit(path, newVisitor) {\n            if (!(this instanceof this.Context)) {\n                throw new Error(\"\");\n            }\n            if (!(path instanceof NodePath)) {\n                throw new Error(\"\");\n            }\n            if (!(this.currentPath instanceof NodePath)) {\n                throw new Error(\"\");\n            }\n            this.needToCallTraverse = false;\n            return PathVisitor.fromMethodsObject(newVisitor || this.visitor).visitWithoutReset(path);\n        };\n    sharedContextProtoMethods.reportChanged = function reportChanged() {\n        this.visitor.reportChanged();\n    };\n    sharedContextProtoMethods.abort = function abort() {\n        this.needToCallTraverse = false;\n        this.visitor.abort();\n    };\n    return PathVisitor;\n}\nexports.default = pathVisitorPlugin;\nmodule.exports = exports[\"default\"];\n"]},"metadata":{},"sourceType":"script"}