{"ast":null,"code":"\"use strict\";\n\n;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar core_1 = tslib_1.__importDefault(require(\"./core\"));\n\nvar types_1 = tslib_1.__importDefault(require(\"../lib/types\"));\n\nvar shared_1 = tslib_1.__importDefault(require(\"../lib/shared\"));\n\nfunction default_1(fork) {\n  fork.use(core_1.default);\n  var types = fork.use(types_1.default);\n  var def = types.Type.def;\n  var or = types.Type.or;\n  var defaults = fork.use(shared_1.default).defaults;\n  def(\"Function\").field(\"generator\", Boolean, defaults[\"false\"]).field(\"expression\", Boolean, defaults[\"false\"]).field(\"defaults\", [or(def(\"Expression\"), null)], defaults.emptyArray) // Legacy\n  .field(\"rest\", or(def(\"Identifier\"), null), defaults[\"null\"]); // The ESTree way of representing a ...rest parameter.\n\n  def(\"RestElement\").bases(\"Pattern\").build(\"argument\").field(\"argument\", def(\"Pattern\")).field(\"typeAnnotation\", // for Babylon. Flow parser puts it on the identifier\n  or(def(\"TypeAnnotation\"), def(\"TSTypeAnnotation\"), null), defaults[\"null\"]);\n  def(\"SpreadElementPattern\").bases(\"Pattern\").build(\"argument\").field(\"argument\", def(\"Pattern\"));\n  def(\"FunctionDeclaration\").build(\"id\", \"params\", \"body\", \"generator\", \"expression\") // May be `null` in the context of `export default function () {}`\n  .field(\"id\", or(def(\"Identifier\"), null));\n  def(\"FunctionExpression\").build(\"id\", \"params\", \"body\", \"generator\", \"expression\");\n  def(\"ArrowFunctionExpression\").bases(\"Function\", \"Expression\").build(\"params\", \"body\", \"expression\") // The forced null value here is compatible with the overridden\n  // definition of the \"id\" field in the Function interface.\n  .field(\"id\", null, defaults[\"null\"]) // Arrow function bodies are allowed to be expressions.\n  .field(\"body\", or(def(\"BlockStatement\"), def(\"Expression\"))) // The current spec forbids arrow generators, so I have taken the\n  // liberty of enforcing that. TODO Report this.\n  .field(\"generator\", false, defaults[\"false\"]);\n  def(\"ForOfStatement\").bases(\"Statement\").build(\"left\", \"right\", \"body\").field(\"left\", or(def(\"VariableDeclaration\"), def(\"Pattern\"))).field(\"right\", def(\"Expression\")).field(\"body\", def(\"Statement\"));\n  def(\"YieldExpression\").bases(\"Expression\").build(\"argument\", \"delegate\").field(\"argument\", or(def(\"Expression\"), null)).field(\"delegate\", Boolean, defaults[\"false\"]);\n  def(\"GeneratorExpression\").bases(\"Expression\").build(\"body\", \"blocks\", \"filter\").field(\"body\", def(\"Expression\")).field(\"blocks\", [def(\"ComprehensionBlock\")]).field(\"filter\", or(def(\"Expression\"), null));\n  def(\"ComprehensionExpression\").bases(\"Expression\").build(\"body\", \"blocks\", \"filter\").field(\"body\", def(\"Expression\")).field(\"blocks\", [def(\"ComprehensionBlock\")]).field(\"filter\", or(def(\"Expression\"), null));\n  def(\"ComprehensionBlock\").bases(\"Node\").build(\"left\", \"right\", \"each\").field(\"left\", def(\"Pattern\")).field(\"right\", def(\"Expression\")).field(\"each\", Boolean);\n  def(\"Property\").field(\"key\", or(def(\"Literal\"), def(\"Identifier\"), def(\"Expression\"))).field(\"value\", or(def(\"Expression\"), def(\"Pattern\"))).field(\"method\", Boolean, defaults[\"false\"]).field(\"shorthand\", Boolean, defaults[\"false\"]).field(\"computed\", Boolean, defaults[\"false\"]);\n  def(\"ObjectProperty\").field(\"shorthand\", Boolean, defaults[\"false\"]);\n  def(\"PropertyPattern\").bases(\"Pattern\").build(\"key\", \"pattern\").field(\"key\", or(def(\"Literal\"), def(\"Identifier\"), def(\"Expression\"))).field(\"pattern\", def(\"Pattern\")).field(\"computed\", Boolean, defaults[\"false\"]);\n  def(\"ObjectPattern\").bases(\"Pattern\").build(\"properties\").field(\"properties\", [or(def(\"PropertyPattern\"), def(\"Property\"))]);\n  def(\"ArrayPattern\").bases(\"Pattern\").build(\"elements\").field(\"elements\", [or(def(\"Pattern\"), null)]);\n  def(\"SpreadElement\").bases(\"Node\").build(\"argument\").field(\"argument\", def(\"Expression\"));\n  def(\"ArrayExpression\").field(\"elements\", [or(def(\"Expression\"), def(\"SpreadElement\"), def(\"RestElement\"), null)]);\n  def(\"NewExpression\").field(\"arguments\", [or(def(\"Expression\"), def(\"SpreadElement\"))]);\n  def(\"CallExpression\").field(\"arguments\", [or(def(\"Expression\"), def(\"SpreadElement\"))]); // Note: this node type is *not* an AssignmentExpression with a Pattern on\n  // the left-hand side! The existing AssignmentExpression type already\n  // supports destructuring assignments. AssignmentPattern nodes may appear\n  // wherever a Pattern is allowed, and the right-hand side represents a\n  // default value to be destructured against the left-hand side, if no\n  // value is otherwise provided. For example: default parameter values.\n\n  def(\"AssignmentPattern\").bases(\"Pattern\").build(\"left\", \"right\").field(\"left\", def(\"Pattern\")).field(\"right\", def(\"Expression\"));\n  def(\"MethodDefinition\").bases(\"Declaration\").build(\"kind\", \"key\", \"value\", \"static\").field(\"kind\", or(\"constructor\", \"method\", \"get\", \"set\")).field(\"key\", def(\"Expression\")).field(\"value\", def(\"Function\")).field(\"computed\", Boolean, defaults[\"false\"]).field(\"static\", Boolean, defaults[\"false\"]);\n  var ClassBodyElement = or(def(\"MethodDefinition\"), def(\"VariableDeclarator\"), def(\"ClassPropertyDefinition\"), def(\"ClassProperty\"));\n  def(\"ClassProperty\").bases(\"Declaration\").build(\"key\").field(\"key\", or(def(\"Literal\"), def(\"Identifier\"), def(\"Expression\"))).field(\"computed\", Boolean, defaults[\"false\"]);\n  def(\"ClassPropertyDefinition\") // static property\n  .bases(\"Declaration\").build(\"definition\") // Yes, Virginia, circular definitions are permitted.\n  .field(\"definition\", ClassBodyElement);\n  def(\"ClassBody\").bases(\"Declaration\").build(\"body\").field(\"body\", [ClassBodyElement]);\n  def(\"ClassDeclaration\").bases(\"Declaration\").build(\"id\", \"body\", \"superClass\").field(\"id\", or(def(\"Identifier\"), null)).field(\"body\", def(\"ClassBody\")).field(\"superClass\", or(def(\"Expression\"), null), defaults[\"null\"]);\n  def(\"ClassExpression\").bases(\"Expression\").build(\"id\", \"body\", \"superClass\").field(\"id\", or(def(\"Identifier\"), null), defaults[\"null\"]).field(\"body\", def(\"ClassBody\")).field(\"superClass\", or(def(\"Expression\"), null), defaults[\"null\"]);\n  def(\"Super\").bases(\"Expression\").build(); // Specifier and ModuleSpecifier are abstract non-standard types\n  // introduced for definitional convenience.\n\n  def(\"Specifier\").bases(\"Node\"); // This supertype is shared/abused by both def/babel.js and\n  // def/esprima.js. In the future, it will be possible to load only one set\n  // of definitions appropriate for a given parser, but until then we must\n  // rely on default functions to reconcile the conflicting AST formats.\n\n  def(\"ModuleSpecifier\").bases(\"Specifier\") // This local field is used by Babel/Acorn. It should not technically\n  // be optional in the Babel/Acorn AST format, but it must be optional\n  // in the Esprima AST format.\n  .field(\"local\", or(def(\"Identifier\"), null), defaults[\"null\"]) // The id and name fields are used by Esprima. The id field should not\n  // technically be optional in the Esprima AST format, but it must be\n  // optional in the Babel/Acorn AST format.\n  .field(\"id\", or(def(\"Identifier\"), null), defaults[\"null\"]).field(\"name\", or(def(\"Identifier\"), null), defaults[\"null\"]); // import {<id [as name]>} from ...;\n\n  def(\"ImportSpecifier\").bases(\"ModuleSpecifier\").build(\"imported\", \"local\").field(\"imported\", def(\"Identifier\")); // import <id> from ...;\n\n  def(\"ImportDefaultSpecifier\").bases(\"ModuleSpecifier\").build(\"local\"); // import <* as id> from ...;\n\n  def(\"ImportNamespaceSpecifier\").bases(\"ModuleSpecifier\").build(\"local\");\n  def(\"ImportDeclaration\").bases(\"Declaration\").build(\"specifiers\", \"source\", \"importKind\").field(\"specifiers\", [or(def(\"ImportSpecifier\"), def(\"ImportNamespaceSpecifier\"), def(\"ImportDefaultSpecifier\"))], defaults.emptyArray).field(\"source\", def(\"Literal\")).field(\"importKind\", or(\"value\", \"type\"), function () {\n    return \"value\";\n  });\n  def(\"ExportNamedDeclaration\").bases(\"Declaration\").build(\"declaration\", \"specifiers\", \"source\").field(\"declaration\", or(def(\"Declaration\"), null)).field(\"specifiers\", [def(\"ExportSpecifier\")], defaults.emptyArray).field(\"source\", or(def(\"Literal\"), null), defaults[\"null\"]);\n  def(\"ExportSpecifier\").bases(\"ModuleSpecifier\").build(\"local\", \"exported\").field(\"exported\", def(\"Identifier\"));\n  def(\"ExportDefaultDeclaration\").bases(\"Declaration\").build(\"declaration\").field(\"declaration\", or(def(\"Declaration\"), def(\"Expression\")));\n  def(\"ExportAllDeclaration\").bases(\"Declaration\").build(\"source\").field(\"source\", def(\"Literal\"));\n  def(\"TaggedTemplateExpression\").bases(\"Expression\").build(\"tag\", \"quasi\").field(\"tag\", def(\"Expression\")).field(\"quasi\", def(\"TemplateLiteral\"));\n  def(\"TemplateLiteral\").bases(\"Expression\").build(\"quasis\", \"expressions\").field(\"quasis\", [def(\"TemplateElement\")]).field(\"expressions\", [def(\"Expression\")]);\n  def(\"TemplateElement\").bases(\"Node\").build(\"value\", \"tail\").field(\"value\", {\n    \"cooked\": String,\n    \"raw\": String\n  }).field(\"tail\", Boolean);\n  def(\"MetaProperty\").bases(\"Expression\").build(\"meta\", \"property\").field(\"meta\", def(\"Identifier\")).field(\"property\", def(\"Identifier\"));\n}\n\nexports.default = default_1;\nmodule.exports = exports[\"default\"];","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/jbook/node_modules/jscodeshift/node_modules/ast-types/def/es6.js"],"names":["Object","defineProperty","exports","value","tslib_1","require","core_1","__importDefault","types_1","shared_1","default_1","fork","use","default","types","def","Type","or","defaults","field","Boolean","emptyArray","bases","build","ClassBodyElement","String","module"],"mappings":"AAAA;;AAAa;AACbA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAIC,OAAO,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,IAAIC,MAAM,GAAGF,OAAO,CAACG,eAAR,CAAwBF,OAAO,CAAC,QAAD,CAA/B,CAAb;;AACA,IAAIG,OAAO,GAAGJ,OAAO,CAACG,eAAR,CAAwBF,OAAO,CAAC,cAAD,CAA/B,CAAd;;AACA,IAAII,QAAQ,GAAGL,OAAO,CAACG,eAAR,CAAwBF,OAAO,CAAC,eAAD,CAA/B,CAAf;;AACA,SAASK,SAAT,CAAmBC,IAAnB,EAAyB;AACrBA,EAAAA,IAAI,CAACC,GAAL,CAASN,MAAM,CAACO,OAAhB;AACA,MAAIC,KAAK,GAAGH,IAAI,CAACC,GAAL,CAASJ,OAAO,CAACK,OAAjB,CAAZ;AACA,MAAIE,GAAG,GAAGD,KAAK,CAACE,IAAN,CAAWD,GAArB;AACA,MAAIE,EAAE,GAAGH,KAAK,CAACE,IAAN,CAAWC,EAApB;AACA,MAAIC,QAAQ,GAAGP,IAAI,CAACC,GAAL,CAASH,QAAQ,CAACI,OAAlB,EAA2BK,QAA1C;AACAH,EAAAA,GAAG,CAAC,UAAD,CAAH,CACKI,KADL,CACW,WADX,EACwBC,OADxB,EACiCF,QAAQ,CAAC,OAAD,CADzC,EAEKC,KAFL,CAEW,YAFX,EAEyBC,OAFzB,EAEkCF,QAAQ,CAAC,OAAD,CAF1C,EAGKC,KAHL,CAGW,UAHX,EAGuB,CAACF,EAAE,CAACF,GAAG,CAAC,YAAD,CAAJ,EAAoB,IAApB,CAAH,CAHvB,EAGsDG,QAAQ,CAACG,UAH/D,EAII;AAJJ,GAKKF,KALL,CAKW,MALX,EAKmBF,EAAE,CAACF,GAAG,CAAC,YAAD,CAAJ,EAAoB,IAApB,CALrB,EAKgDG,QAAQ,CAAC,MAAD,CALxD,EANqB,CAYrB;;AACAH,EAAAA,GAAG,CAAC,aAAD,CAAH,CACKO,KADL,CACW,SADX,EAEKC,KAFL,CAEW,UAFX,EAGKJ,KAHL,CAGW,UAHX,EAGuBJ,GAAG,CAAC,SAAD,CAH1B,EAIKI,KAJL,CAIW,gBAJX,EAI6B;AAC7BF,EAAAA,EAAE,CAACF,GAAG,CAAC,gBAAD,CAAJ,EAAwBA,GAAG,CAAC,kBAAD,CAA3B,EAAiD,IAAjD,CALF,EAK0DG,QAAQ,CAAC,MAAD,CALlE;AAMAH,EAAAA,GAAG,CAAC,sBAAD,CAAH,CACKO,KADL,CACW,SADX,EAEKC,KAFL,CAEW,UAFX,EAGKJ,KAHL,CAGW,UAHX,EAGuBJ,GAAG,CAAC,SAAD,CAH1B;AAIAA,EAAAA,GAAG,CAAC,qBAAD,CAAH,CACKQ,KADL,CACW,IADX,EACiB,QADjB,EAC2B,MAD3B,EACmC,WADnC,EACgD,YADhD,EAEI;AAFJ,GAGKJ,KAHL,CAGW,IAHX,EAGiBF,EAAE,CAACF,GAAG,CAAC,YAAD,CAAJ,EAAoB,IAApB,CAHnB;AAIAA,EAAAA,GAAG,CAAC,oBAAD,CAAH,CACKQ,KADL,CACW,IADX,EACiB,QADjB,EAC2B,MAD3B,EACmC,WADnC,EACgD,YADhD;AAEAR,EAAAA,GAAG,CAAC,yBAAD,CAAH,CACKO,KADL,CACW,UADX,EACuB,YADvB,EAEKC,KAFL,CAEW,QAFX,EAEqB,MAFrB,EAE6B,YAF7B,EAGI;AACA;AAJJ,GAKKJ,KALL,CAKW,IALX,EAKiB,IALjB,EAKuBD,QAAQ,CAAC,MAAD,CAL/B,EAMI;AANJ,GAOKC,KAPL,CAOW,MAPX,EAOmBF,EAAE,CAACF,GAAG,CAAC,gBAAD,CAAJ,EAAwBA,GAAG,CAAC,YAAD,CAA3B,CAPrB,EAQI;AACA;AATJ,GAUKI,KAVL,CAUW,WAVX,EAUwB,KAVxB,EAU+BD,QAAQ,CAAC,OAAD,CAVvC;AAWAH,EAAAA,GAAG,CAAC,gBAAD,CAAH,CACKO,KADL,CACW,WADX,EAEKC,KAFL,CAEW,MAFX,EAEmB,OAFnB,EAE4B,MAF5B,EAGKJ,KAHL,CAGW,MAHX,EAGmBF,EAAE,CAACF,GAAG,CAAC,qBAAD,CAAJ,EAA6BA,GAAG,CAAC,SAAD,CAAhC,CAHrB,EAIKI,KAJL,CAIW,OAJX,EAIoBJ,GAAG,CAAC,YAAD,CAJvB,EAKKI,KALL,CAKW,MALX,EAKmBJ,GAAG,CAAC,WAAD,CALtB;AAMAA,EAAAA,GAAG,CAAC,iBAAD,CAAH,CACKO,KADL,CACW,YADX,EAEKC,KAFL,CAEW,UAFX,EAEuB,UAFvB,EAGKJ,KAHL,CAGW,UAHX,EAGuBF,EAAE,CAACF,GAAG,CAAC,YAAD,CAAJ,EAAoB,IAApB,CAHzB,EAIKI,KAJL,CAIW,UAJX,EAIuBC,OAJvB,EAIgCF,QAAQ,CAAC,OAAD,CAJxC;AAKAH,EAAAA,GAAG,CAAC,qBAAD,CAAH,CACKO,KADL,CACW,YADX,EAEKC,KAFL,CAEW,MAFX,EAEmB,QAFnB,EAE6B,QAF7B,EAGKJ,KAHL,CAGW,MAHX,EAGmBJ,GAAG,CAAC,YAAD,CAHtB,EAIKI,KAJL,CAIW,QAJX,EAIqB,CAACJ,GAAG,CAAC,oBAAD,CAAJ,CAJrB,EAKKI,KALL,CAKW,QALX,EAKqBF,EAAE,CAACF,GAAG,CAAC,YAAD,CAAJ,EAAoB,IAApB,CALvB;AAMAA,EAAAA,GAAG,CAAC,yBAAD,CAAH,CACKO,KADL,CACW,YADX,EAEKC,KAFL,CAEW,MAFX,EAEmB,QAFnB,EAE6B,QAF7B,EAGKJ,KAHL,CAGW,MAHX,EAGmBJ,GAAG,CAAC,YAAD,CAHtB,EAIKI,KAJL,CAIW,QAJX,EAIqB,CAACJ,GAAG,CAAC,oBAAD,CAAJ,CAJrB,EAKKI,KALL,CAKW,QALX,EAKqBF,EAAE,CAACF,GAAG,CAAC,YAAD,CAAJ,EAAoB,IAApB,CALvB;AAMAA,EAAAA,GAAG,CAAC,oBAAD,CAAH,CACKO,KADL,CACW,MADX,EAEKC,KAFL,CAEW,MAFX,EAEmB,OAFnB,EAE4B,MAF5B,EAGKJ,KAHL,CAGW,MAHX,EAGmBJ,GAAG,CAAC,SAAD,CAHtB,EAIKI,KAJL,CAIW,OAJX,EAIoBJ,GAAG,CAAC,YAAD,CAJvB,EAKKI,KALL,CAKW,MALX,EAKmBC,OALnB;AAMAL,EAAAA,GAAG,CAAC,UAAD,CAAH,CACKI,KADL,CACW,KADX,EACkBF,EAAE,CAACF,GAAG,CAAC,SAAD,CAAJ,EAAiBA,GAAG,CAAC,YAAD,CAApB,EAAoCA,GAAG,CAAC,YAAD,CAAvC,CADpB,EAEKI,KAFL,CAEW,OAFX,EAEoBF,EAAE,CAACF,GAAG,CAAC,YAAD,CAAJ,EAAoBA,GAAG,CAAC,SAAD,CAAvB,CAFtB,EAGKI,KAHL,CAGW,QAHX,EAGqBC,OAHrB,EAG8BF,QAAQ,CAAC,OAAD,CAHtC,EAIKC,KAJL,CAIW,WAJX,EAIwBC,OAJxB,EAIiCF,QAAQ,CAAC,OAAD,CAJzC,EAKKC,KALL,CAKW,UALX,EAKuBC,OALvB,EAKgCF,QAAQ,CAAC,OAAD,CALxC;AAMAH,EAAAA,GAAG,CAAC,gBAAD,CAAH,CACKI,KADL,CACW,WADX,EACwBC,OADxB,EACiCF,QAAQ,CAAC,OAAD,CADzC;AAEAH,EAAAA,GAAG,CAAC,iBAAD,CAAH,CACKO,KADL,CACW,SADX,EAEKC,KAFL,CAEW,KAFX,EAEkB,SAFlB,EAGKJ,KAHL,CAGW,KAHX,EAGkBF,EAAE,CAACF,GAAG,CAAC,SAAD,CAAJ,EAAiBA,GAAG,CAAC,YAAD,CAApB,EAAoCA,GAAG,CAAC,YAAD,CAAvC,CAHpB,EAIKI,KAJL,CAIW,SAJX,EAIsBJ,GAAG,CAAC,SAAD,CAJzB,EAKKI,KALL,CAKW,UALX,EAKuBC,OALvB,EAKgCF,QAAQ,CAAC,OAAD,CALxC;AAMAH,EAAAA,GAAG,CAAC,eAAD,CAAH,CACKO,KADL,CACW,SADX,EAEKC,KAFL,CAEW,YAFX,EAGKJ,KAHL,CAGW,YAHX,EAGyB,CAACF,EAAE,CAACF,GAAG,CAAC,iBAAD,CAAJ,EAAyBA,GAAG,CAAC,UAAD,CAA5B,CAAH,CAHzB;AAIAA,EAAAA,GAAG,CAAC,cAAD,CAAH,CACKO,KADL,CACW,SADX,EAEKC,KAFL,CAEW,UAFX,EAGKJ,KAHL,CAGW,UAHX,EAGuB,CAACF,EAAE,CAACF,GAAG,CAAC,SAAD,CAAJ,EAAiB,IAAjB,CAAH,CAHvB;AAIAA,EAAAA,GAAG,CAAC,eAAD,CAAH,CACKO,KADL,CACW,MADX,EAEKC,KAFL,CAEW,UAFX,EAGKJ,KAHL,CAGW,UAHX,EAGuBJ,GAAG,CAAC,YAAD,CAH1B;AAIAA,EAAAA,GAAG,CAAC,iBAAD,CAAH,CACKI,KADL,CACW,UADX,EACuB,CAACF,EAAE,CAACF,GAAG,CAAC,YAAD,CAAJ,EAAoBA,GAAG,CAAC,eAAD,CAAvB,EAA0CA,GAAG,CAAC,aAAD,CAA7C,EAA8D,IAA9D,CAAH,CADvB;AAEAA,EAAAA,GAAG,CAAC,eAAD,CAAH,CACKI,KADL,CACW,WADX,EACwB,CAACF,EAAE,CAACF,GAAG,CAAC,YAAD,CAAJ,EAAoBA,GAAG,CAAC,eAAD,CAAvB,CAAH,CADxB;AAEAA,EAAAA,GAAG,CAAC,gBAAD,CAAH,CACKI,KADL,CACW,WADX,EACwB,CAACF,EAAE,CAACF,GAAG,CAAC,YAAD,CAAJ,EAAoBA,GAAG,CAAC,eAAD,CAAvB,CAAH,CADxB,EAnGqB,CAqGrB;AACA;AACA;AACA;AACA;AACA;;AACAA,EAAAA,GAAG,CAAC,mBAAD,CAAH,CACKO,KADL,CACW,SADX,EAEKC,KAFL,CAEW,MAFX,EAEmB,OAFnB,EAGKJ,KAHL,CAGW,MAHX,EAGmBJ,GAAG,CAAC,SAAD,CAHtB,EAIKI,KAJL,CAIW,OAJX,EAIoBJ,GAAG,CAAC,YAAD,CAJvB;AAKAA,EAAAA,GAAG,CAAC,kBAAD,CAAH,CACKO,KADL,CACW,aADX,EAEKC,KAFL,CAEW,MAFX,EAEmB,KAFnB,EAE0B,OAF1B,EAEmC,QAFnC,EAGKJ,KAHL,CAGW,MAHX,EAGmBF,EAAE,CAAC,aAAD,EAAgB,QAAhB,EAA0B,KAA1B,EAAiC,KAAjC,CAHrB,EAIKE,KAJL,CAIW,KAJX,EAIkBJ,GAAG,CAAC,YAAD,CAJrB,EAKKI,KALL,CAKW,OALX,EAKoBJ,GAAG,CAAC,UAAD,CALvB,EAMKI,KANL,CAMW,UANX,EAMuBC,OANvB,EAMgCF,QAAQ,CAAC,OAAD,CANxC,EAOKC,KAPL,CAOW,QAPX,EAOqBC,OAPrB,EAO8BF,QAAQ,CAAC,OAAD,CAPtC;AAQA,MAAIM,gBAAgB,GAAGP,EAAE,CAACF,GAAG,CAAC,kBAAD,CAAJ,EAA0BA,GAAG,CAAC,oBAAD,CAA7B,EAAqDA,GAAG,CAAC,yBAAD,CAAxD,EAAqFA,GAAG,CAAC,eAAD,CAAxF,CAAzB;AACAA,EAAAA,GAAG,CAAC,eAAD,CAAH,CACKO,KADL,CACW,aADX,EAEKC,KAFL,CAEW,KAFX,EAGKJ,KAHL,CAGW,KAHX,EAGkBF,EAAE,CAACF,GAAG,CAAC,SAAD,CAAJ,EAAiBA,GAAG,CAAC,YAAD,CAApB,EAAoCA,GAAG,CAAC,YAAD,CAAvC,CAHpB,EAIKI,KAJL,CAIW,UAJX,EAIuBC,OAJvB,EAIgCF,QAAQ,CAAC,OAAD,CAJxC;AAKAH,EAAAA,GAAG,CAAC,yBAAD,CAAH,CAA+B;AAA/B,GACKO,KADL,CACW,aADX,EAEKC,KAFL,CAEW,YAFX,EAGI;AAHJ,GAIKJ,KAJL,CAIW,YAJX,EAIyBK,gBAJzB;AAKAT,EAAAA,GAAG,CAAC,WAAD,CAAH,CACKO,KADL,CACW,aADX,EAEKC,KAFL,CAEW,MAFX,EAGKJ,KAHL,CAGW,MAHX,EAGmB,CAACK,gBAAD,CAHnB;AAIAT,EAAAA,GAAG,CAAC,kBAAD,CAAH,CACKO,KADL,CACW,aADX,EAEKC,KAFL,CAEW,IAFX,EAEiB,MAFjB,EAEyB,YAFzB,EAGKJ,KAHL,CAGW,IAHX,EAGiBF,EAAE,CAACF,GAAG,CAAC,YAAD,CAAJ,EAAoB,IAApB,CAHnB,EAIKI,KAJL,CAIW,MAJX,EAImBJ,GAAG,CAAC,WAAD,CAJtB,EAKKI,KALL,CAKW,YALX,EAKyBF,EAAE,CAACF,GAAG,CAAC,YAAD,CAAJ,EAAoB,IAApB,CAL3B,EAKsDG,QAAQ,CAAC,MAAD,CAL9D;AAMAH,EAAAA,GAAG,CAAC,iBAAD,CAAH,CACKO,KADL,CACW,YADX,EAEKC,KAFL,CAEW,IAFX,EAEiB,MAFjB,EAEyB,YAFzB,EAGKJ,KAHL,CAGW,IAHX,EAGiBF,EAAE,CAACF,GAAG,CAAC,YAAD,CAAJ,EAAoB,IAApB,CAHnB,EAG8CG,QAAQ,CAAC,MAAD,CAHtD,EAIKC,KAJL,CAIW,MAJX,EAImBJ,GAAG,CAAC,WAAD,CAJtB,EAKKI,KALL,CAKW,YALX,EAKyBF,EAAE,CAACF,GAAG,CAAC,YAAD,CAAJ,EAAoB,IAApB,CAL3B,EAKsDG,QAAQ,CAAC,MAAD,CAL9D;AAMAH,EAAAA,GAAG,CAAC,OAAD,CAAH,CACKO,KADL,CACW,YADX,EAEKC,KAFL,GAnJqB,CAsJrB;AACA;;AACAR,EAAAA,GAAG,CAAC,WAAD,CAAH,CAAiBO,KAAjB,CAAuB,MAAvB,EAxJqB,CAyJrB;AACA;AACA;AACA;;AACAP,EAAAA,GAAG,CAAC,iBAAD,CAAH,CACKO,KADL,CACW,WADX,EAEI;AACA;AACA;AAJJ,GAKKH,KALL,CAKW,OALX,EAKoBF,EAAE,CAACF,GAAG,CAAC,YAAD,CAAJ,EAAoB,IAApB,CALtB,EAKiDG,QAAQ,CAAC,MAAD,CALzD,EAMI;AACA;AACA;AARJ,GASKC,KATL,CASW,IATX,EASiBF,EAAE,CAACF,GAAG,CAAC,YAAD,CAAJ,EAAoB,IAApB,CATnB,EAS8CG,QAAQ,CAAC,MAAD,CATtD,EAUKC,KAVL,CAUW,MAVX,EAUmBF,EAAE,CAACF,GAAG,CAAC,YAAD,CAAJ,EAAoB,IAApB,CAVrB,EAUgDG,QAAQ,CAAC,MAAD,CAVxD,EA7JqB,CAwKrB;;AACAH,EAAAA,GAAG,CAAC,iBAAD,CAAH,CACKO,KADL,CACW,iBADX,EAEKC,KAFL,CAEW,UAFX,EAEuB,OAFvB,EAGKJ,KAHL,CAGW,UAHX,EAGuBJ,GAAG,CAAC,YAAD,CAH1B,EAzKqB,CA6KrB;;AACAA,EAAAA,GAAG,CAAC,wBAAD,CAAH,CACKO,KADL,CACW,iBADX,EAEKC,KAFL,CAEW,OAFX,EA9KqB,CAiLrB;;AACAR,EAAAA,GAAG,CAAC,0BAAD,CAAH,CACKO,KADL,CACW,iBADX,EAEKC,KAFL,CAEW,OAFX;AAGAR,EAAAA,GAAG,CAAC,mBAAD,CAAH,CACKO,KADL,CACW,aADX,EAEKC,KAFL,CAEW,YAFX,EAEyB,QAFzB,EAEmC,YAFnC,EAGKJ,KAHL,CAGW,YAHX,EAGyB,CAACF,EAAE,CAACF,GAAG,CAAC,iBAAD,CAAJ,EAAyBA,GAAG,CAAC,0BAAD,CAA5B,EAA0DA,GAAG,CAAC,wBAAD,CAA7D,CAAH,CAHzB,EAGuHG,QAAQ,CAACG,UAHhI,EAIKF,KAJL,CAIW,QAJX,EAIqBJ,GAAG,CAAC,SAAD,CAJxB,EAKKI,KALL,CAKW,YALX,EAKyBF,EAAE,CAAC,OAAD,EAAU,MAAV,CAL3B,EAK8C,YAAY;AACtD,WAAO,OAAP;AACH,GAPD;AAQAF,EAAAA,GAAG,CAAC,wBAAD,CAAH,CACKO,KADL,CACW,aADX,EAEKC,KAFL,CAEW,aAFX,EAE0B,YAF1B,EAEwC,QAFxC,EAGKJ,KAHL,CAGW,aAHX,EAG0BF,EAAE,CAACF,GAAG,CAAC,aAAD,CAAJ,EAAqB,IAArB,CAH5B,EAIKI,KAJL,CAIW,YAJX,EAIyB,CAACJ,GAAG,CAAC,iBAAD,CAAJ,CAJzB,EAImDG,QAAQ,CAACG,UAJ5D,EAKKF,KALL,CAKW,QALX,EAKqBF,EAAE,CAACF,GAAG,CAAC,SAAD,CAAJ,EAAiB,IAAjB,CALvB,EAK+CG,QAAQ,CAAC,MAAD,CALvD;AAMAH,EAAAA,GAAG,CAAC,iBAAD,CAAH,CACKO,KADL,CACW,iBADX,EAEKC,KAFL,CAEW,OAFX,EAEoB,UAFpB,EAGKJ,KAHL,CAGW,UAHX,EAGuBJ,GAAG,CAAC,YAAD,CAH1B;AAIAA,EAAAA,GAAG,CAAC,0BAAD,CAAH,CACKO,KADL,CACW,aADX,EAEKC,KAFL,CAEW,aAFX,EAGKJ,KAHL,CAGW,aAHX,EAG0BF,EAAE,CAACF,GAAG,CAAC,aAAD,CAAJ,EAAqBA,GAAG,CAAC,YAAD,CAAxB,CAH5B;AAIAA,EAAAA,GAAG,CAAC,sBAAD,CAAH,CACKO,KADL,CACW,aADX,EAEKC,KAFL,CAEW,QAFX,EAGKJ,KAHL,CAGW,QAHX,EAGqBJ,GAAG,CAAC,SAAD,CAHxB;AAIAA,EAAAA,GAAG,CAAC,0BAAD,CAAH,CACKO,KADL,CACW,YADX,EAEKC,KAFL,CAEW,KAFX,EAEkB,OAFlB,EAGKJ,KAHL,CAGW,KAHX,EAGkBJ,GAAG,CAAC,YAAD,CAHrB,EAIKI,KAJL,CAIW,OAJX,EAIoBJ,GAAG,CAAC,iBAAD,CAJvB;AAKAA,EAAAA,GAAG,CAAC,iBAAD,CAAH,CACKO,KADL,CACW,YADX,EAEKC,KAFL,CAEW,QAFX,EAEqB,aAFrB,EAGKJ,KAHL,CAGW,QAHX,EAGqB,CAACJ,GAAG,CAAC,iBAAD,CAAJ,CAHrB,EAIKI,KAJL,CAIW,aAJX,EAI0B,CAACJ,GAAG,CAAC,YAAD,CAAJ,CAJ1B;AAKAA,EAAAA,GAAG,CAAC,iBAAD,CAAH,CACKO,KADL,CACW,MADX,EAEKC,KAFL,CAEW,OAFX,EAEoB,MAFpB,EAGKJ,KAHL,CAGW,OAHX,EAGoB;AAAE,cAAUM,MAAZ;AAAoB,WAAOA;AAA3B,GAHpB,EAIKN,KAJL,CAIW,MAJX,EAImBC,OAJnB;AAKAL,EAAAA,GAAG,CAAC,cAAD,CAAH,CACKO,KADL,CACW,YADX,EAEKC,KAFL,CAEW,MAFX,EAEmB,UAFnB,EAGKJ,KAHL,CAGW,MAHX,EAGmBJ,GAAG,CAAC,YAAD,CAHtB,EAIKI,KAJL,CAIW,UAJX,EAIuBJ,GAAG,CAAC,YAAD,CAJ1B;AAKH;;AACDb,OAAO,CAACW,OAAR,GAAkBH,SAAlB;AACAgB,MAAM,CAACxB,OAAP,GAAiBA,OAAO,CAAC,SAAD,CAAxB","sourcesContent":["\"use strict\";;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar core_1 = tslib_1.__importDefault(require(\"./core\"));\nvar types_1 = tslib_1.__importDefault(require(\"../lib/types\"));\nvar shared_1 = tslib_1.__importDefault(require(\"../lib/shared\"));\nfunction default_1(fork) {\n    fork.use(core_1.default);\n    var types = fork.use(types_1.default);\n    var def = types.Type.def;\n    var or = types.Type.or;\n    var defaults = fork.use(shared_1.default).defaults;\n    def(\"Function\")\n        .field(\"generator\", Boolean, defaults[\"false\"])\n        .field(\"expression\", Boolean, defaults[\"false\"])\n        .field(\"defaults\", [or(def(\"Expression\"), null)], defaults.emptyArray)\n        // Legacy\n        .field(\"rest\", or(def(\"Identifier\"), null), defaults[\"null\"]);\n    // The ESTree way of representing a ...rest parameter.\n    def(\"RestElement\")\n        .bases(\"Pattern\")\n        .build(\"argument\")\n        .field(\"argument\", def(\"Pattern\"))\n        .field(\"typeAnnotation\", // for Babylon. Flow parser puts it on the identifier\n    or(def(\"TypeAnnotation\"), def(\"TSTypeAnnotation\"), null), defaults[\"null\"]);\n    def(\"SpreadElementPattern\")\n        .bases(\"Pattern\")\n        .build(\"argument\")\n        .field(\"argument\", def(\"Pattern\"));\n    def(\"FunctionDeclaration\")\n        .build(\"id\", \"params\", \"body\", \"generator\", \"expression\")\n        // May be `null` in the context of `export default function () {}`\n        .field(\"id\", or(def(\"Identifier\"), null));\n    def(\"FunctionExpression\")\n        .build(\"id\", \"params\", \"body\", \"generator\", \"expression\");\n    def(\"ArrowFunctionExpression\")\n        .bases(\"Function\", \"Expression\")\n        .build(\"params\", \"body\", \"expression\")\n        // The forced null value here is compatible with the overridden\n        // definition of the \"id\" field in the Function interface.\n        .field(\"id\", null, defaults[\"null\"])\n        // Arrow function bodies are allowed to be expressions.\n        .field(\"body\", or(def(\"BlockStatement\"), def(\"Expression\")))\n        // The current spec forbids arrow generators, so I have taken the\n        // liberty of enforcing that. TODO Report this.\n        .field(\"generator\", false, defaults[\"false\"]);\n    def(\"ForOfStatement\")\n        .bases(\"Statement\")\n        .build(\"left\", \"right\", \"body\")\n        .field(\"left\", or(def(\"VariableDeclaration\"), def(\"Pattern\")))\n        .field(\"right\", def(\"Expression\"))\n        .field(\"body\", def(\"Statement\"));\n    def(\"YieldExpression\")\n        .bases(\"Expression\")\n        .build(\"argument\", \"delegate\")\n        .field(\"argument\", or(def(\"Expression\"), null))\n        .field(\"delegate\", Boolean, defaults[\"false\"]);\n    def(\"GeneratorExpression\")\n        .bases(\"Expression\")\n        .build(\"body\", \"blocks\", \"filter\")\n        .field(\"body\", def(\"Expression\"))\n        .field(\"blocks\", [def(\"ComprehensionBlock\")])\n        .field(\"filter\", or(def(\"Expression\"), null));\n    def(\"ComprehensionExpression\")\n        .bases(\"Expression\")\n        .build(\"body\", \"blocks\", \"filter\")\n        .field(\"body\", def(\"Expression\"))\n        .field(\"blocks\", [def(\"ComprehensionBlock\")])\n        .field(\"filter\", or(def(\"Expression\"), null));\n    def(\"ComprehensionBlock\")\n        .bases(\"Node\")\n        .build(\"left\", \"right\", \"each\")\n        .field(\"left\", def(\"Pattern\"))\n        .field(\"right\", def(\"Expression\"))\n        .field(\"each\", Boolean);\n    def(\"Property\")\n        .field(\"key\", or(def(\"Literal\"), def(\"Identifier\"), def(\"Expression\")))\n        .field(\"value\", or(def(\"Expression\"), def(\"Pattern\")))\n        .field(\"method\", Boolean, defaults[\"false\"])\n        .field(\"shorthand\", Boolean, defaults[\"false\"])\n        .field(\"computed\", Boolean, defaults[\"false\"]);\n    def(\"ObjectProperty\")\n        .field(\"shorthand\", Boolean, defaults[\"false\"]);\n    def(\"PropertyPattern\")\n        .bases(\"Pattern\")\n        .build(\"key\", \"pattern\")\n        .field(\"key\", or(def(\"Literal\"), def(\"Identifier\"), def(\"Expression\")))\n        .field(\"pattern\", def(\"Pattern\"))\n        .field(\"computed\", Boolean, defaults[\"false\"]);\n    def(\"ObjectPattern\")\n        .bases(\"Pattern\")\n        .build(\"properties\")\n        .field(\"properties\", [or(def(\"PropertyPattern\"), def(\"Property\"))]);\n    def(\"ArrayPattern\")\n        .bases(\"Pattern\")\n        .build(\"elements\")\n        .field(\"elements\", [or(def(\"Pattern\"), null)]);\n    def(\"SpreadElement\")\n        .bases(\"Node\")\n        .build(\"argument\")\n        .field(\"argument\", def(\"Expression\"));\n    def(\"ArrayExpression\")\n        .field(\"elements\", [or(def(\"Expression\"), def(\"SpreadElement\"), def(\"RestElement\"), null)]);\n    def(\"NewExpression\")\n        .field(\"arguments\", [or(def(\"Expression\"), def(\"SpreadElement\"))]);\n    def(\"CallExpression\")\n        .field(\"arguments\", [or(def(\"Expression\"), def(\"SpreadElement\"))]);\n    // Note: this node type is *not* an AssignmentExpression with a Pattern on\n    // the left-hand side! The existing AssignmentExpression type already\n    // supports destructuring assignments. AssignmentPattern nodes may appear\n    // wherever a Pattern is allowed, and the right-hand side represents a\n    // default value to be destructured against the left-hand side, if no\n    // value is otherwise provided. For example: default parameter values.\n    def(\"AssignmentPattern\")\n        .bases(\"Pattern\")\n        .build(\"left\", \"right\")\n        .field(\"left\", def(\"Pattern\"))\n        .field(\"right\", def(\"Expression\"));\n    def(\"MethodDefinition\")\n        .bases(\"Declaration\")\n        .build(\"kind\", \"key\", \"value\", \"static\")\n        .field(\"kind\", or(\"constructor\", \"method\", \"get\", \"set\"))\n        .field(\"key\", def(\"Expression\"))\n        .field(\"value\", def(\"Function\"))\n        .field(\"computed\", Boolean, defaults[\"false\"])\n        .field(\"static\", Boolean, defaults[\"false\"]);\n    var ClassBodyElement = or(def(\"MethodDefinition\"), def(\"VariableDeclarator\"), def(\"ClassPropertyDefinition\"), def(\"ClassProperty\"));\n    def(\"ClassProperty\")\n        .bases(\"Declaration\")\n        .build(\"key\")\n        .field(\"key\", or(def(\"Literal\"), def(\"Identifier\"), def(\"Expression\")))\n        .field(\"computed\", Boolean, defaults[\"false\"]);\n    def(\"ClassPropertyDefinition\") // static property\n        .bases(\"Declaration\")\n        .build(\"definition\")\n        // Yes, Virginia, circular definitions are permitted.\n        .field(\"definition\", ClassBodyElement);\n    def(\"ClassBody\")\n        .bases(\"Declaration\")\n        .build(\"body\")\n        .field(\"body\", [ClassBodyElement]);\n    def(\"ClassDeclaration\")\n        .bases(\"Declaration\")\n        .build(\"id\", \"body\", \"superClass\")\n        .field(\"id\", or(def(\"Identifier\"), null))\n        .field(\"body\", def(\"ClassBody\"))\n        .field(\"superClass\", or(def(\"Expression\"), null), defaults[\"null\"]);\n    def(\"ClassExpression\")\n        .bases(\"Expression\")\n        .build(\"id\", \"body\", \"superClass\")\n        .field(\"id\", or(def(\"Identifier\"), null), defaults[\"null\"])\n        .field(\"body\", def(\"ClassBody\"))\n        .field(\"superClass\", or(def(\"Expression\"), null), defaults[\"null\"]);\n    def(\"Super\")\n        .bases(\"Expression\")\n        .build();\n    // Specifier and ModuleSpecifier are abstract non-standard types\n    // introduced for definitional convenience.\n    def(\"Specifier\").bases(\"Node\");\n    // This supertype is shared/abused by both def/babel.js and\n    // def/esprima.js. In the future, it will be possible to load only one set\n    // of definitions appropriate for a given parser, but until then we must\n    // rely on default functions to reconcile the conflicting AST formats.\n    def(\"ModuleSpecifier\")\n        .bases(\"Specifier\")\n        // This local field is used by Babel/Acorn. It should not technically\n        // be optional in the Babel/Acorn AST format, but it must be optional\n        // in the Esprima AST format.\n        .field(\"local\", or(def(\"Identifier\"), null), defaults[\"null\"])\n        // The id and name fields are used by Esprima. The id field should not\n        // technically be optional in the Esprima AST format, but it must be\n        // optional in the Babel/Acorn AST format.\n        .field(\"id\", or(def(\"Identifier\"), null), defaults[\"null\"])\n        .field(\"name\", or(def(\"Identifier\"), null), defaults[\"null\"]);\n    // import {<id [as name]>} from ...;\n    def(\"ImportSpecifier\")\n        .bases(\"ModuleSpecifier\")\n        .build(\"imported\", \"local\")\n        .field(\"imported\", def(\"Identifier\"));\n    // import <id> from ...;\n    def(\"ImportDefaultSpecifier\")\n        .bases(\"ModuleSpecifier\")\n        .build(\"local\");\n    // import <* as id> from ...;\n    def(\"ImportNamespaceSpecifier\")\n        .bases(\"ModuleSpecifier\")\n        .build(\"local\");\n    def(\"ImportDeclaration\")\n        .bases(\"Declaration\")\n        .build(\"specifiers\", \"source\", \"importKind\")\n        .field(\"specifiers\", [or(def(\"ImportSpecifier\"), def(\"ImportNamespaceSpecifier\"), def(\"ImportDefaultSpecifier\"))], defaults.emptyArray)\n        .field(\"source\", def(\"Literal\"))\n        .field(\"importKind\", or(\"value\", \"type\"), function () {\n        return \"value\";\n    });\n    def(\"ExportNamedDeclaration\")\n        .bases(\"Declaration\")\n        .build(\"declaration\", \"specifiers\", \"source\")\n        .field(\"declaration\", or(def(\"Declaration\"), null))\n        .field(\"specifiers\", [def(\"ExportSpecifier\")], defaults.emptyArray)\n        .field(\"source\", or(def(\"Literal\"), null), defaults[\"null\"]);\n    def(\"ExportSpecifier\")\n        .bases(\"ModuleSpecifier\")\n        .build(\"local\", \"exported\")\n        .field(\"exported\", def(\"Identifier\"));\n    def(\"ExportDefaultDeclaration\")\n        .bases(\"Declaration\")\n        .build(\"declaration\")\n        .field(\"declaration\", or(def(\"Declaration\"), def(\"Expression\")));\n    def(\"ExportAllDeclaration\")\n        .bases(\"Declaration\")\n        .build(\"source\")\n        .field(\"source\", def(\"Literal\"));\n    def(\"TaggedTemplateExpression\")\n        .bases(\"Expression\")\n        .build(\"tag\", \"quasi\")\n        .field(\"tag\", def(\"Expression\"))\n        .field(\"quasi\", def(\"TemplateLiteral\"));\n    def(\"TemplateLiteral\")\n        .bases(\"Expression\")\n        .build(\"quasis\", \"expressions\")\n        .field(\"quasis\", [def(\"TemplateElement\")])\n        .field(\"expressions\", [def(\"Expression\")]);\n    def(\"TemplateElement\")\n        .bases(\"Node\")\n        .build(\"value\", \"tail\")\n        .field(\"value\", { \"cooked\": String, \"raw\": String })\n        .field(\"tail\", Boolean);\n    def(\"MetaProperty\")\n        .bases(\"Expression\")\n        .build(\"meta\", \"property\")\n        .field(\"meta\", def(\"Identifier\"))\n        .field(\"property\", def(\"Identifier\"));\n}\nexports.default = default_1;\nmodule.exports = exports[\"default\"];\n"]},"metadata":{},"sourceType":"script"}