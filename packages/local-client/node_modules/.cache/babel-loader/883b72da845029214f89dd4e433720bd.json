{"ast":null,"code":"Prism.languages.graphql = {\n  'comment': /#.*/,\n  'description': {\n    pattern: /(?:\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")(?=\\s*[a-z_])/i,\n    greedy: true,\n    alias: 'string',\n    inside: {\n      'language-markdown': {\n        pattern: /(^\"(?:\"\")?)(?!\\1)[\\s\\S]+(?=\\1$)/,\n        lookbehind: true,\n        inside: Prism.languages.markdown\n      }\n    }\n  },\n  'string': {\n    pattern: /\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/,\n    greedy: true\n  },\n  'number': /(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n  'boolean': /\\b(?:true|false)\\b/,\n  'variable': /\\$[a-z_]\\w*/i,\n  'directive': {\n    pattern: /@[a-z_]\\w*/i,\n    alias: 'function'\n  },\n  'attr-name': {\n    pattern: /[a-z_]\\w*(?=\\s*(?:\\((?:[^()\"]|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")*\\))?:)/i,\n    greedy: true\n  },\n  'atom-input': {\n    pattern: /[A-Z]\\w*Input(?=!?.*$)/m,\n    alias: 'class-name'\n  },\n  'scalar': /\\b(?:Boolean|Float|ID|Int|String)\\b/,\n  'constant': /\\b[A-Z][A-Z_\\d]*\\b/,\n  'class-name': {\n    pattern: /(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,\n    lookbehind: true\n  },\n  'fragment': {\n    pattern: /(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function'\n  },\n  'definition-mutation': {\n    pattern: /(\\bmutation\\s+)[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function'\n  },\n  'definition-query': {\n    pattern: /(\\bquery\\s+)[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function'\n  },\n  'keyword': /\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,\n  'operator': /[!=|&]|\\.{3}/,\n  'property-query': /\\w+(?=\\s*\\()/,\n  'object': /\\w+(?=\\s*\\{)/,\n  'punctuation': /[!(){}\\[\\]:=,]/,\n  'property': /\\w+/\n};\nPrism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {\n  if (env.language !== 'graphql') {\n    return;\n  }\n  /**\n   * get the graphql token stream that we want to customize\n   *\n   * @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n   * @type {Token[]}\n   */\n\n\n  var validTokens = env.tokens.filter(function (token) {\n    return typeof token !== 'string' && token.type !== 'comment' && token.type !== 'scalar';\n  });\n  var currentIndex = 0;\n  /**\n   * Returns whether the token relative to the current index has the given type.\n   *\n   * @param {number} offset\n   * @returns {Token | undefined}\n   */\n\n  function getToken(offset) {\n    return validTokens[currentIndex + offset];\n  }\n  /**\n   * Returns whether the token relative to the current index has the given type.\n   *\n   * @param {readonly string[]} types\n   * @param {number} [offset=0]\n   * @returns {boolean}\n   */\n\n\n  function isTokenType(types, offset) {\n    offset = offset || 0;\n\n    for (var i = 0; i < types.length; i++) {\n      var token = getToken(i + offset);\n\n      if (!token || token.type !== types[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Returns the index of the closing bracket to an opening bracket.\n   *\n   * It is assumed that `token[currentIndex - 1]` is an opening bracket.\n   *\n   * If no closing bracket could be found, `-1` will be returned.\n   *\n   * @param {RegExp} open\n   * @param {RegExp} close\n   * @returns {number}\n   */\n\n\n  function findClosingBracket(open, close) {\n    var stackHeight = 1;\n\n    for (var i = currentIndex; i < validTokens.length; i++) {\n      var token = validTokens[i];\n      var content = token.content;\n\n      if (token.type === 'punctuation' && typeof content === 'string') {\n        if (open.test(content)) {\n          stackHeight++;\n        } else if (close.test(content)) {\n          stackHeight--;\n\n          if (stackHeight === 0) {\n            return i;\n          }\n        }\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Adds an alias to the given token.\n   *\n   * @param {Token} token\n   * @param {string} alias\n   * @returns {void}\n   */\n\n\n  function addAlias(token, alias) {\n    var aliases = token.alias;\n\n    if (!aliases) {\n      token.alias = aliases = [];\n    } else if (!Array.isArray(aliases)) {\n      token.alias = aliases = [aliases];\n    }\n\n    aliases.push(alias);\n  }\n\n  for (; currentIndex < validTokens.length;) {\n    var startToken = validTokens[currentIndex++]; // add special aliases for mutation tokens\n\n    if (startToken.type === 'keyword' && startToken.content === 'mutation') {\n      // any array of the names of all input variables (if any)\n      var inputVariables = [];\n\n      if (isTokenType(['definition-mutation', 'punctuation']) && getToken(1).content === '(') {\n        // definition\n        currentIndex += 2; // skip 'definition-mutation' and 'punctuation'\n\n        var definitionEnd = findClosingBracket(/^\\($/, /^\\)$/);\n\n        if (definitionEnd === -1) {\n          continue;\n        } // find all input variables\n\n\n        for (; currentIndex < definitionEnd; currentIndex++) {\n          var t = getToken(0);\n\n          if (t.type === 'variable') {\n            addAlias(t, 'variable-input');\n            inputVariables.push(t.content);\n          }\n        }\n\n        currentIndex = definitionEnd + 1;\n      }\n\n      if (isTokenType(['punctuation', 'property-query']) && getToken(0).content === '{') {\n        currentIndex++; // skip opening bracket\n\n        addAlias(getToken(0), 'property-mutation');\n\n        if (inputVariables.length > 0) {\n          var mutationEnd = findClosingBracket(/^\\{$/, /^\\}$/);\n\n          if (mutationEnd === -1) {\n            continue;\n          } // give references to input variables a special alias\n\n\n          for (var i = currentIndex; i < mutationEnd; i++) {\n            var varToken = validTokens[i];\n\n            if (varToken.type === 'variable' && inputVariables.indexOf(varToken.content) >= 0) {\n              addAlias(varToken, 'variable-input');\n            }\n          }\n        }\n      }\n    }\n  }\n});","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/jbook/node_modules/prismjs/components/prism-graphql.js"],"names":["Prism","languages","graphql","pattern","greedy","alias","inside","lookbehind","markdown","hooks","add","afterTokenizeGraphql","env","language","validTokens","tokens","filter","token","type","currentIndex","getToken","offset","isTokenType","types","i","length","findClosingBracket","open","close","stackHeight","content","test","addAlias","aliases","Array","isArray","push","startToken","inputVariables","definitionEnd","t","mutationEnd","varToken","indexOf"],"mappings":"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","sourcesContent":["Prism.languages.graphql = {\n\t'comment': /#.*/,\n\t'description': {\n\t\tpattern: /(?:\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")(?=\\s*[a-z_])/i,\n\t\tgreedy: true,\n\t\talias: 'string',\n\t\tinside: {\n\t\t\t'language-markdown': {\n\t\t\t\tpattern: /(^\"(?:\"\")?)(?!\\1)[\\s\\S]+(?=\\1$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: Prism.languages.markdown\n\t\t\t}\n\t\t}\n\t},\n\t'string': {\n\t\tpattern: /\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/,\n\t\tgreedy: true\n\t},\n\t'number': /(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n\t'boolean': /\\b(?:true|false)\\b/,\n\t'variable': /\\$[a-z_]\\w*/i,\n\t'directive': {\n\t\tpattern: /@[a-z_]\\w*/i,\n\t\talias: 'function'\n\t},\n\t'attr-name': {\n\t\tpattern: /[a-z_]\\w*(?=\\s*(?:\\((?:[^()\"]|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")*\\))?:)/i,\n\t\tgreedy: true\n\t},\n\t'atom-input': {\n\t\tpattern: /[A-Z]\\w*Input(?=!?.*$)/m,\n\t\talias: 'class-name'\n\t},\n\t'scalar': /\\b(?:Boolean|Float|ID|Int|String)\\b/,\n\t'constant': /\\b[A-Z][A-Z_\\d]*\\b/,\n\t'class-name': {\n\t\tpattern: /(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,\n\t\tlookbehind: true\n\t},\n\t'fragment': {\n\t\tpattern: /(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))[a-zA-Z_]\\w*/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'definition-mutation': {\n\t\tpattern: /(\\bmutation\\s+)[a-zA-Z_]\\w*/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'definition-query': {\n\t\tpattern: /(\\bquery\\s+)[a-zA-Z_]\\w*/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'keyword': /\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,\n\t'operator': /[!=|&]|\\.{3}/,\n\t'property-query': /\\w+(?=\\s*\\()/,\n\t'object': /\\w+(?=\\s*\\{)/,\n\t'punctuation': /[!(){}\\[\\]:=,]/,\n\t'property': /\\w+/\n};\n\nPrism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {\n\tif (env.language !== 'graphql') {\n\t\treturn;\n\t}\n\n\t/**\n\t * get the graphql token stream that we want to customize\n\t *\n\t * @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\t * @type {Token[]}\n\t */\n\tvar validTokens = env.tokens.filter(function (token) {\n\t\treturn typeof token !== 'string' && token.type !== 'comment' && token.type !== 'scalar';\n\t});\n\n\tvar currentIndex = 0;\n\n\t/**\n\t * Returns whether the token relative to the current index has the given type.\n\t *\n\t * @param {number} offset\n\t * @returns {Token | undefined}\n\t */\n\tfunction getToken(offset) {\n\t\treturn validTokens[currentIndex + offset];\n\t}\n\n\t/**\n\t * Returns whether the token relative to the current index has the given type.\n\t *\n\t * @param {readonly string[]} types\n\t * @param {number} [offset=0]\n\t * @returns {boolean}\n\t */\n\tfunction isTokenType(types, offset) {\n\t\toffset = offset || 0;\n\t\tfor (var i = 0; i < types.length; i++) {\n\t\t\tvar token = getToken(i + offset);\n\t\t\tif (!token || token.type !== types[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns the index of the closing bracket to an opening bracket.\n\t *\n\t * It is assumed that `token[currentIndex - 1]` is an opening bracket.\n\t *\n\t * If no closing bracket could be found, `-1` will be returned.\n\t *\n\t * @param {RegExp} open\n\t * @param {RegExp} close\n\t * @returns {number}\n\t */\n\tfunction findClosingBracket(open, close) {\n\t\tvar stackHeight = 1;\n\n\t\tfor (var i = currentIndex; i < validTokens.length; i++) {\n\t\t\tvar token = validTokens[i];\n\t\t\tvar content = token.content;\n\n\t\t\tif (token.type === 'punctuation' && typeof content === 'string') {\n\t\t\t\tif (open.test(content)) {\n\t\t\t\t\tstackHeight++;\n\t\t\t\t} else if (close.test(content)) {\n\t\t\t\t\tstackHeight--;\n\n\t\t\t\t\tif (stackHeight === 0) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Adds an alias to the given token.\n\t *\n\t * @param {Token} token\n\t * @param {string} alias\n\t * @returns {void}\n\t */\n\tfunction addAlias(token, alias) {\n\t\tvar aliases = token.alias;\n\t\tif (!aliases) {\n\t\t\ttoken.alias = aliases = [];\n\t\t} else if (!Array.isArray(aliases)) {\n\t\t\ttoken.alias = aliases = [aliases];\n\t\t}\n\t\taliases.push(alias);\n\t}\n\n\tfor (; currentIndex < validTokens.length;) {\n\t\tvar startToken = validTokens[currentIndex++];\n\n\t\t// add special aliases for mutation tokens\n\t\tif (startToken.type === 'keyword' && startToken.content === 'mutation') {\n\t\t\t// any array of the names of all input variables (if any)\n\t\t\tvar inputVariables = [];\n\n\t\t\tif (isTokenType(['definition-mutation', 'punctuation']) && getToken(1).content === '(') {\n\t\t\t\t// definition\n\n\t\t\t\tcurrentIndex += 2; // skip 'definition-mutation' and 'punctuation'\n\n\t\t\t\tvar definitionEnd = findClosingBracket(/^\\($/, /^\\)$/);\n\t\t\t\tif (definitionEnd === -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// find all input variables\n\t\t\t\tfor (; currentIndex < definitionEnd; currentIndex++) {\n\t\t\t\t\tvar t = getToken(0);\n\t\t\t\t\tif (t.type === 'variable') {\n\t\t\t\t\t\taddAlias(t, 'variable-input');\n\t\t\t\t\t\tinputVariables.push(t.content);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcurrentIndex = definitionEnd + 1;\n\t\t\t}\n\n\t\t\tif (isTokenType(['punctuation', 'property-query']) && getToken(0).content === '{') {\n\t\t\t\tcurrentIndex++; // skip opening bracket\n\n\t\t\t\taddAlias(getToken(0), 'property-mutation');\n\n\t\t\t\tif (inputVariables.length > 0) {\n\t\t\t\t\tvar mutationEnd = findClosingBracket(/^\\{$/, /^\\}$/);\n\t\t\t\t\tif (mutationEnd === -1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// give references to input variables a special alias\n\t\t\t\t\tfor (var i = currentIndex; i < mutationEnd; i++) {\n\t\t\t\t\t\tvar varToken = validTokens[i];\n\t\t\t\t\t\tif (varToken.type === 'variable' && inputVariables.indexOf(varToken.content) >= 0) {\n\t\t\t\t\t\t\taddAlias(varToken, 'variable-input');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n"]},"metadata":{},"sourceType":"script"}