{"ast":null,"code":"var phrasing = require('mdast-util-to-markdown/lib/util/container-phrasing');\n\nvar defaultInlineCode = require('mdast-util-to-markdown/lib/handle/inline-code');\n\nvar markdownTable = require('markdown-table');\n\nmodule.exports = toMarkdown;\n\nfunction toMarkdown(options) {\n  var settings = options || {};\n  var padding = settings.tableCellPadding;\n  var alignDelimiters = settings.tablePipeAlign;\n  var stringLength = settings.stringLength;\n  var around = padding ? ' ' : '|';\n  return {\n    unsafe: [{\n      character: '\\r',\n      inConstruct: 'tableCell'\n    }, {\n      character: '\\n',\n      inConstruct: 'tableCell'\n    }, // A pipe, when followed by a tab or space (padding), or a dash or colon\n    // (unpadded delimiter row), could result in a table.\n    {\n      atBreak: true,\n      character: '|',\n      after: '[\\t :-]'\n    }, // A pipe in a cell must be encoded.\n    {\n      character: '|',\n      inConstruct: 'tableCell'\n    }, // A colon must be followed by a dash, in which case it could start a\n    // delimiter row.\n    {\n      atBreak: true,\n      character: ':',\n      after: '-'\n    }, // A delimiter row can also start with a dash, when followed by more\n    // dashes, a colon, or a pipe.\n    // This is a stricter version than the built in check for lists, thematic\n    // breaks, and setex heading underlines though:\n    // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>\n    {\n      atBreak: true,\n      character: '-',\n      after: '[:|-]'\n    }],\n    handlers: {\n      table: handleTable,\n      tableRow: handleTableRow,\n      tableCell: handleTableCell,\n      inlineCode: inlineCodeWithTable\n    }\n  };\n\n  function handleTable(node, _, context) {\n    return serializeData(handleTableAsData(node, context), node.align);\n  } // This function isn’t really used normally, because we handle rows at the\n  // table level.\n  // But, if someone passes in a table row, this ensures we make somewhat sense.\n\n\n  function handleTableRow(node, _, context) {\n    var row = handleTableRowAsData(node, context); // `markdown-table` will always add an align row\n\n    var value = serializeData([row]);\n    return value.slice(0, value.indexOf('\\n'));\n  }\n\n  function handleTableCell(node, _, context) {\n    var exit = context.enter('tableCell');\n    var value = phrasing(node, context, {\n      before: around,\n      after: around\n    });\n    exit();\n    return value;\n  }\n\n  function serializeData(matrix, align) {\n    return markdownTable(matrix, {\n      align: align,\n      alignDelimiters: alignDelimiters,\n      padding: padding,\n      stringLength: stringLength\n    });\n  }\n\n  function handleTableAsData(node, context) {\n    var children = node.children;\n    var index = -1;\n    var length = children.length;\n    var result = [];\n    var subexit = context.enter('table');\n\n    while (++index < length) {\n      result[index] = handleTableRowAsData(children[index], context);\n    }\n\n    subexit();\n    return result;\n  }\n\n  function handleTableRowAsData(node, context) {\n    var children = node.children;\n    var index = -1;\n    var length = children.length;\n    var result = [];\n    var subexit = context.enter('tableRow');\n\n    while (++index < length) {\n      result[index] = handleTableCell(children[index], node, context);\n    }\n\n    subexit();\n    return result;\n  }\n\n  function inlineCodeWithTable(node, parent, context) {\n    var value = defaultInlineCode(node, parent, context);\n\n    if (context.stack.indexOf('tableCell') !== -1) {\n      value = value.replace(/\\|/g, '\\\\$&');\n    }\n\n    return value;\n  }\n}","map":{"version":3,"sources":["/Users/gauravrawal/gaurav/udemy/jbook/node_modules/mdast-util-gfm-table/to-markdown.js"],"names":["phrasing","require","defaultInlineCode","markdownTable","module","exports","toMarkdown","options","settings","padding","tableCellPadding","alignDelimiters","tablePipeAlign","stringLength","around","unsafe","character","inConstruct","atBreak","after","handlers","table","handleTable","tableRow","handleTableRow","tableCell","handleTableCell","inlineCode","inlineCodeWithTable","node","_","context","serializeData","handleTableAsData","align","row","handleTableRowAsData","value","slice","indexOf","exit","enter","before","matrix","children","index","length","result","subexit","parent","stack","replace"],"mappings":"AAAA,IAAIA,QAAQ,GAAGC,OAAO,CAAC,oDAAD,CAAtB;;AACA,IAAIC,iBAAiB,GAAGD,OAAO,CAAC,+CAAD,CAA/B;;AACA,IAAIE,aAAa,GAAGF,OAAO,CAAC,gBAAD,CAA3B;;AAEAG,MAAM,CAACC,OAAP,GAAiBC,UAAjB;;AAEA,SAASA,UAAT,CAAoBC,OAApB,EAA6B;AAC3B,MAAIC,QAAQ,GAAGD,OAAO,IAAI,EAA1B;AACA,MAAIE,OAAO,GAAGD,QAAQ,CAACE,gBAAvB;AACA,MAAIC,eAAe,GAAGH,QAAQ,CAACI,cAA/B;AACA,MAAIC,YAAY,GAAGL,QAAQ,CAACK,YAA5B;AACA,MAAIC,MAAM,GAAGL,OAAO,GAAG,GAAH,GAAS,GAA7B;AAEA,SAAO;AACLM,IAAAA,MAAM,EAAE,CACN;AAACC,MAAAA,SAAS,EAAE,IAAZ;AAAkBC,MAAAA,WAAW,EAAE;AAA/B,KADM,EAEN;AAACD,MAAAA,SAAS,EAAE,IAAZ;AAAkBC,MAAAA,WAAW,EAAE;AAA/B,KAFM,EAGN;AACA;AACA;AAACC,MAAAA,OAAO,EAAE,IAAV;AAAgBF,MAAAA,SAAS,EAAE,GAA3B;AAAgCG,MAAAA,KAAK,EAAE;AAAvC,KALM,EAMN;AACA;AAACH,MAAAA,SAAS,EAAE,GAAZ;AAAiBC,MAAAA,WAAW,EAAE;AAA9B,KAPM,EAQN;AACA;AACA;AAACC,MAAAA,OAAO,EAAE,IAAV;AAAgBF,MAAAA,SAAS,EAAE,GAA3B;AAAgCG,MAAAA,KAAK,EAAE;AAAvC,KAVM,EAWN;AACA;AACA;AACA;AACA;AACA;AAACD,MAAAA,OAAO,EAAE,IAAV;AAAgBF,MAAAA,SAAS,EAAE,GAA3B;AAAgCG,MAAAA,KAAK,EAAE;AAAvC,KAhBM,CADH;AAmBLC,IAAAA,QAAQ,EAAE;AACRC,MAAAA,KAAK,EAAEC,WADC;AAERC,MAAAA,QAAQ,EAAEC,cAFF;AAGRC,MAAAA,SAAS,EAAEC,eAHH;AAIRC,MAAAA,UAAU,EAAEC;AAJJ;AAnBL,GAAP;;AA2BA,WAASN,WAAT,CAAqBO,IAArB,EAA2BC,CAA3B,EAA8BC,OAA9B,EAAuC;AACrC,WAAOC,aAAa,CAACC,iBAAiB,CAACJ,IAAD,EAAOE,OAAP,CAAlB,EAAmCF,IAAI,CAACK,KAAxC,CAApB;AACD,GApC0B,CAsC3B;AACA;AACA;;;AACA,WAASV,cAAT,CAAwBK,IAAxB,EAA8BC,CAA9B,EAAiCC,OAAjC,EAA0C;AACxC,QAAII,GAAG,GAAGC,oBAAoB,CAACP,IAAD,EAAOE,OAAP,CAA9B,CADwC,CAExC;;AACA,QAAIM,KAAK,GAAGL,aAAa,CAAC,CAACG,GAAD,CAAD,CAAzB;AACA,WAAOE,KAAK,CAACC,KAAN,CAAY,CAAZ,EAAeD,KAAK,CAACE,OAAN,CAAc,IAAd,CAAf,CAAP;AACD;;AAED,WAASb,eAAT,CAAyBG,IAAzB,EAA+BC,CAA/B,EAAkCC,OAAlC,EAA2C;AACzC,QAAIS,IAAI,GAAGT,OAAO,CAACU,KAAR,CAAc,WAAd,CAAX;AACA,QAAIJ,KAAK,GAAGrC,QAAQ,CAAC6B,IAAD,EAAOE,OAAP,EAAgB;AAACW,MAAAA,MAAM,EAAE5B,MAAT;AAAiBK,MAAAA,KAAK,EAAEL;AAAxB,KAAhB,CAApB;AACA0B,IAAAA,IAAI;AACJ,WAAOH,KAAP;AACD;;AAED,WAASL,aAAT,CAAuBW,MAAvB,EAA+BT,KAA/B,EAAsC;AACpC,WAAO/B,aAAa,CAACwC,MAAD,EAAS;AAC3BT,MAAAA,KAAK,EAAEA,KADoB;AAE3BvB,MAAAA,eAAe,EAAEA,eAFU;AAG3BF,MAAAA,OAAO,EAAEA,OAHkB;AAI3BI,MAAAA,YAAY,EAAEA;AAJa,KAAT,CAApB;AAMD;;AAED,WAASoB,iBAAT,CAA2BJ,IAA3B,EAAiCE,OAAjC,EAA0C;AACxC,QAAIa,QAAQ,GAAGf,IAAI,CAACe,QAApB;AACA,QAAIC,KAAK,GAAG,CAAC,CAAb;AACA,QAAIC,MAAM,GAAGF,QAAQ,CAACE,MAAtB;AACA,QAAIC,MAAM,GAAG,EAAb;AACA,QAAIC,OAAO,GAAGjB,OAAO,CAACU,KAAR,CAAc,OAAd,CAAd;;AAEA,WAAO,EAAEI,KAAF,GAAUC,MAAjB,EAAyB;AACvBC,MAAAA,MAAM,CAACF,KAAD,CAAN,GAAgBT,oBAAoB,CAACQ,QAAQ,CAACC,KAAD,CAAT,EAAkBd,OAAlB,CAApC;AACD;;AAEDiB,IAAAA,OAAO;AAEP,WAAOD,MAAP;AACD;;AAED,WAASX,oBAAT,CAA8BP,IAA9B,EAAoCE,OAApC,EAA6C;AAC3C,QAAIa,QAAQ,GAAGf,IAAI,CAACe,QAApB;AACA,QAAIC,KAAK,GAAG,CAAC,CAAb;AACA,QAAIC,MAAM,GAAGF,QAAQ,CAACE,MAAtB;AACA,QAAIC,MAAM,GAAG,EAAb;AACA,QAAIC,OAAO,GAAGjB,OAAO,CAACU,KAAR,CAAc,UAAd,CAAd;;AAEA,WAAO,EAAEI,KAAF,GAAUC,MAAjB,EAAyB;AACvBC,MAAAA,MAAM,CAACF,KAAD,CAAN,GAAgBnB,eAAe,CAACkB,QAAQ,CAACC,KAAD,CAAT,EAAkBhB,IAAlB,EAAwBE,OAAxB,CAA/B;AACD;;AAEDiB,IAAAA,OAAO;AAEP,WAAOD,MAAP;AACD;;AAED,WAASnB,mBAAT,CAA6BC,IAA7B,EAAmCoB,MAAnC,EAA2ClB,OAA3C,EAAoD;AAClD,QAAIM,KAAK,GAAGnC,iBAAiB,CAAC2B,IAAD,EAAOoB,MAAP,EAAelB,OAAf,CAA7B;;AAEA,QAAIA,OAAO,CAACmB,KAAR,CAAcX,OAAd,CAAsB,WAAtB,MAAuC,CAAC,CAA5C,EAA+C;AAC7CF,MAAAA,KAAK,GAAGA,KAAK,CAACc,OAAN,CAAc,KAAd,EAAqB,MAArB,CAAR;AACD;;AAED,WAAOd,KAAP;AACD;AACF","sourcesContent":["var phrasing = require('mdast-util-to-markdown/lib/util/container-phrasing')\nvar defaultInlineCode = require('mdast-util-to-markdown/lib/handle/inline-code')\nvar markdownTable = require('markdown-table')\n\nmodule.exports = toMarkdown\n\nfunction toMarkdown(options) {\n  var settings = options || {}\n  var padding = settings.tableCellPadding\n  var alignDelimiters = settings.tablePipeAlign\n  var stringLength = settings.stringLength\n  var around = padding ? ' ' : '|'\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'tableCell'},\n      {character: '\\n', inConstruct: 'tableCell'},\n      // A pipe, when followed by a tab or space (padding), or a dash or colon\n      // (unpadded delimiter row), could result in a table.\n      {atBreak: true, character: '|', after: '[\\t :-]'},\n      // A pipe in a cell must be encoded.\n      {character: '|', inConstruct: 'tableCell'},\n      // A colon must be followed by a dash, in which case it could start a\n      // delimiter row.\n      {atBreak: true, character: ':', after: '-'},\n      // A delimiter row can also start with a dash, when followed by more\n      // dashes, a colon, or a pipe.\n      // This is a stricter version than the built in check for lists, thematic\n      // breaks, and setex heading underlines though:\n      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>\n      {atBreak: true, character: '-', after: '[:|-]'}\n    ],\n    handlers: {\n      table: handleTable,\n      tableRow: handleTableRow,\n      tableCell: handleTableCell,\n      inlineCode: inlineCodeWithTable\n    }\n  }\n\n  function handleTable(node, _, context) {\n    return serializeData(handleTableAsData(node, context), node.align)\n  }\n\n  // This function isn’t really used normally, because we handle rows at the\n  // table level.\n  // But, if someone passes in a table row, this ensures we make somewhat sense.\n  function handleTableRow(node, _, context) {\n    var row = handleTableRowAsData(node, context)\n    // `markdown-table` will always add an align row\n    var value = serializeData([row])\n    return value.slice(0, value.indexOf('\\n'))\n  }\n\n  function handleTableCell(node, _, context) {\n    var exit = context.enter('tableCell')\n    var value = phrasing(node, context, {before: around, after: around})\n    exit()\n    return value\n  }\n\n  function serializeData(matrix, align) {\n    return markdownTable(matrix, {\n      align: align,\n      alignDelimiters: alignDelimiters,\n      padding: padding,\n      stringLength: stringLength\n    })\n  }\n\n  function handleTableAsData(node, context) {\n    var children = node.children\n    var index = -1\n    var length = children.length\n    var result = []\n    var subexit = context.enter('table')\n\n    while (++index < length) {\n      result[index] = handleTableRowAsData(children[index], context)\n    }\n\n    subexit()\n\n    return result\n  }\n\n  function handleTableRowAsData(node, context) {\n    var children = node.children\n    var index = -1\n    var length = children.length\n    var result = []\n    var subexit = context.enter('tableRow')\n\n    while (++index < length) {\n      result[index] = handleTableCell(children[index], node, context)\n    }\n\n    subexit()\n\n    return result\n  }\n\n  function inlineCodeWithTable(node, parent, context) {\n    var value = defaultInlineCode(node, parent, context)\n\n    if (context.stack.indexOf('tableCell') !== -1) {\n      value = value.replace(/\\|/g, '\\\\$&')\n    }\n\n    return value\n  }\n}\n"]},"metadata":{},"sourceType":"script"}