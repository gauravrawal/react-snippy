"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _ = _interopRequireDefault(require(".."));

var _utils = require("../utils");

function ControlledEditor(_ref) {
  var providedValue = _ref.value,
      onChange = _ref.onChange,
      editorDidMount = _ref.editorDidMount,
      props = (0, _objectWithoutProperties2.default)(_ref, ["value", "onChange", "editorDidMount"]);
  var editor = (0, _react.useRef)(null);
  var listener = (0, _react.useRef)(null);
  var value = (0, _react.useRef)(providedValue); // to avoid unnecessary updates in `handleEditorModelChange`
  // (that depends on the `current value` and will trigger to update `attachChangeEventListener`,
  // thus, the listener will be disposed and attached again for every value change)
  // the current value is stored in ref (useRef) instead of being a dependency of `handleEditorModelChange`

  value.current = providedValue;
  var handleEditorModelChange = (0, _react.useCallback)(function (event) {
    var editorValue = editor.current.getValue();

    if (value.current !== editorValue) {
      var directChange = onChange(event, editorValue);

      if (typeof directChange === 'string' && editorValue !== directChange) {
        editor.current.setValue(directChange);
      }
    }
  }, [onChange]);
  var attachChangeEventListener = (0, _react.useCallback)(function () {
    var _editor$current;

    listener.current = (_editor$current = editor.current) === null || _editor$current === void 0 ? void 0 : _editor$current.onDidChangeModelContent(handleEditorModelChange);
  }, [handleEditorModelChange]);
  (0, _react.useEffect)(function () {
    attachChangeEventListener();
    return function () {
      var _listener$current;

      return (_listener$current = listener.current) === null || _listener$current === void 0 ? void 0 : _listener$current.dispose();
    };
  }, [attachChangeEventListener]);
  var handleEditorDidMount = (0, _react.useCallback)(function (getValue, _editor) {
    editor.current = _editor;
    attachChangeEventListener();
    editorDidMount(getValue, _editor);
  }, [attachChangeEventListener, editorDidMount]);
  return /*#__PURE__*/_react.default.createElement(_.default, (0, _extends2.default)({
    value: providedValue,
    editorDidMount: handleEditorDidMount,
    _isControlledMode: true
  }, props));
}

ControlledEditor.propTypes = {
  value: _propTypes.default.string,
  editorDidMount: _propTypes.default.func,
  onChange: _propTypes.default.func
};
ControlledEditor.defaultProps = {
  editorDidMount: _utils.noop,
  onChange: _utils.noop
};
var _default = ControlledEditor;
exports.default = _default;