"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _MonacoContainer = _interopRequireDefault(require("../MonacoContainer"));

var _utils = require("../utils");

var _hooks = require("../hooks");

var _themes = _interopRequireDefault(require("../config/themes"));

function Editor(_ref) {
  var value = _ref.value,
      language = _ref.language,
      editorDidMount = _ref.editorDidMount,
      theme = _ref.theme,
      line = _ref.line,
      width = _ref.width,
      height = _ref.height,
      loading = _ref.loading,
      options = _ref.options,
      overrideServices = _ref.overrideServices,
      _isControlledMode = _ref._isControlledMode,
      className = _ref.className,
      wrapperClassName = _ref.wrapperClassName;

  var _useState = (0, _react.useState)(false),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      isEditorReady = _useState2[0],
      setIsEditorReady = _useState2[1];

  var _useState3 = (0, _react.useState)(true),
      _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
      isMonacoMounting = _useState4[0],
      setIsMonacoMounting = _useState4[1];

  var editorRef = (0, _react.useRef)(null);
  var monacoRef = (0, _react.useRef)(null);
  var containerRef = (0, _react.useRef)(null);
  var editorDidMountRef = (0, _react.useRef)(editorDidMount);
  (0, _hooks.useMount)(function () {
    var cancelable = _utils.monaco.init();

    cancelable.then(function (monaco) {
      return (monacoRef.current = monaco) && setIsMonacoMounting(false);
    }).catch(function (error) {
      return (error === null || error === void 0 ? void 0 : error.type) !== 'cancelation' && console.error('Monaco initialization: error:', error);
    });
    return function () {
      return editorRef.current ? disposeEditor() : cancelable.cancel();
    };
  });
  (0, _hooks.useUpdate)(function () {
    editorRef.current.updateOptions(options);
  }, [options], isEditorReady);
  (0, _hooks.useUpdate)(function () {
    if (editorRef.current.getOption(monacoRef.current.editor.EditorOption.readOnly)) {
      editorRef.current.setValue(value);
    } else {
      if (value !== editorRef.current.getValue()) {
        editorRef.current.executeEdits('', [{
          range: editorRef.current.getModel().getFullModelRange(),
          text: value,
          forceMoveMarkers: true
        }]);

        if (_isControlledMode) {
          var model = editorRef.current.getModel();
          model.forceTokenization(model.getLineCount());
        }

        editorRef.current.pushUndoStop();
      }
    }
  }, [value], isEditorReady);
  (0, _hooks.useUpdate)(function () {
    monacoRef.current.editor.setModelLanguage(editorRef.current.getModel(), language);
  }, [language], isEditorReady);
  (0, _hooks.useUpdate)(function () {
    editorRef.current.setScrollPosition({
      scrollTop: line
    });
  }, [line], isEditorReady);
  (0, _hooks.useUpdate)(function () {
    monacoRef.current.editor.setTheme(theme);
  }, [theme], isEditorReady);
  var createEditor = (0, _react.useCallback)(function () {
    editorRef.current = monacoRef.current.editor.create(containerRef.current, (0, _objectSpread2.default)({
      value: value,
      language: language,
      automaticLayout: true
    }, options), overrideServices);
    monacoRef.current.editor.defineTheme('dark', _themes.default['night-dark']);
    monacoRef.current.editor.setTheme(theme);
    setIsEditorReady(true);
  }, [language, options, overrideServices, theme, value]);
  (0, _react.useEffect)(function () {
    if (isEditorReady) {
      editorDidMountRef.current(editorRef.current.getValue.bind(editorRef.current), editorRef.current);
    }
  }, [isEditorReady]);
  (0, _react.useEffect)(function () {
    !isMonacoMounting && !isEditorReady && createEditor();
  }, [isMonacoMounting, isEditorReady, createEditor]);

  var disposeEditor = function disposeEditor() {
    return editorRef.current.dispose();
  };

  return /*#__PURE__*/_react.default.createElement(_MonacoContainer.default, {
    width: width,
    height: height,
    isEditorReady: isEditorReady,
    loading: loading,
    _ref: containerRef,
    className: className,
    wrapperClassName: wrapperClassName
  });
}

Editor.propTypes = {
  value: _propTypes.default.string,
  language: _propTypes.default.string,
  editorDidMount: _propTypes.default.func,
  theme: _propTypes.default.string,
  line: _propTypes.default.number,
  width: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
  height: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
  loading: _propTypes.default.oneOfType([_propTypes.default.element, _propTypes.default.string]),
  options: _propTypes.default.object,
  className: _propTypes.default.string,
  wrapperClassName: _propTypes.default.string,
  overrideServices: _propTypes.default.object,
  _isControlledMode: _propTypes.default.bool
};
Editor.defaultProps = {
  editorDidMount: _utils.noop,
  theme: 'light',
  width: '100%',
  height: '100%',
  loading: 'Loading...',
  options: {},
  overrideServices: {},
  _isControlledMode: false
};
var _default = Editor;
exports.default = _default;